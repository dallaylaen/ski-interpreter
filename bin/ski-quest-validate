#!/usr/bin/env node

const fs = require('node:fs/promises');
const path = require('node:path');
const cac = require('cac');

const { SKI } = require('../lib/ski-interpreter.cjs');
const { Quest } = SKI;

const cli = cac('ski-quest-validate');

cli
  .command('[solutionFile] [...chapterFiles]', 'Validate quest data and solutions')
  .option('-q, --quiet', 'Quiet mode, only show errors')
  .option('-v, --verbose', 'Verbose output')
  .action(async (solutionFile, chapterFiles, options) => {
    try {
      if (!solutionFile || !chapterFiles || chapterFiles.length === 0) {
        cli.outputHelp();
        process.exit(1);
      }
      const result = await validateQuests(solutionFile, chapterFiles, options);
      process.exit(result ? 0 : 1);
    } catch (err) {
      console.error('Error:', err.message);
      process.exit(2);
    }
  });

cli.help();
cli.version('1.0.0');

cli.parse();

async function validateQuests (solutionFile, chapterFiles, options) {
  const { quiet, verbose } = options;

  // Load solutions
  let questSolutions = {};
  try {
    const solutionData = await fs.readFile(solutionFile, 'utf8');
    questSolutions = JSON.parse(solutionData);
  } catch (err) {
    console.error(`Failed to load solutions from ${solutionFile}:`, err.message);
    return false;
  }

  let passCount = 0;
  let failCount = 0;
  const uniqQuest = new Set();
  const uniqChapter = new Set();

  // Process each chapter file
  for (const chapterFile of chapterFiles) {
    let chapterData;
    try {
      const content = await fs.readFile(chapterFile, 'utf8');
      chapterData = JSON.parse(content);
    } catch (err) {
      console.error(`Failed to load chapter ${chapterFile}:`, err.message);
      failCount++;
      continue;
    }

    // Handle both array and object formats
    const chapter = Array.isArray(chapterData) ? { content: chapterData } : chapterData;

    if (!quiet)
      console.log(`\n=== ${chapterFile} ===`);

    // Verify chapter metadata
    const chapterErrors = verifyChapter(chapter, chapterFile, quiet);
    if (chapterErrors.length > 0) {
      for (const error of chapterErrors)
        console.error(`  Chapter error: ${error}`);

      failCount++;
      continue;
    }

    // Check uniqueness
    if (uniqChapter.has(chapter.id)) {
      console.error(`  Chapter error: duplicate chapter id: ${chapter.id}`);
      failCount++;
      continue;
    }
    uniqChapter.add(chapter.id);

    // Validate each quest
    const content = chapter.content ?? [];
    for (let i = 0; i < content.length; i++) {
      const questData = content[i];
      let quest;
      const questErr = null;

      try {
        quest = new Quest(questData);
      } catch (err) {
        console.error(`  Quest [${i}] ${questData.id ?? 'unknown'}: Failed to create quest: ${err.message}`);
        failCount++;
        continue;
      }

      const questErrors = verifyQuest(quest, questData, verbose);
      if (questErrors.length > 0) {
        for (const error of questErrors)
          console.error(`  Quest [${i}] ${quest.id}: ${error}`);

        failCount++;
        continue;
      }

      // Check quest ID uniqueness
      if (uniqQuest.has(quest.meta.id)) {
        console.error(`  Quest [${i}] ${quest.meta.id}: duplicate quest id`);
        failCount++;
        continue;
      }
      uniqQuest.add(quest.meta.id);

      // Verify solutions if provided
      const selfCheckResult = quest.selfCheck(questSolutions);
      if (selfCheckResult !== null) {
        const errors = [];
        for (const item of selfCheckResult.shouldPass)
          errors.push(`  Solution should pass but failed: ${item.input.join(' ')}`);

        for (const item of selfCheckResult.shouldFail)
          errors.push(`  Solution should fail but passed: ${item.input.join(' ')}`);

        if (errors.length > 0) {
          for (const error of errors)
            console.error(`  Quest [${i}] ${quest.meta.id}: ${error}`);

          failCount++;
          continue;
        }
      }

      if (!quiet)
        console.log(`  Quest [${i}] ${quest.meta.id}: OK`);

      passCount++;
    }
  }

  if (!quiet) {
    console.log('\n=== Summary ===');
    console.log(`Passed: ${passCount}`);
    console.log(`Failed: ${failCount}`);
  }

  return failCount === 0;
}

function verifyChapter (chapter, filename, quiet) {
  const errors = [];

  // If content is not an array or is empty, skip chapter validation
  if (!Array.isArray(chapter.content) || chapter.content.length === 0) {
    errors.push('missing or empty chapter content');
    return errors;
  }

  // Only require chapter id and name if they're not already metadata-only chapters
  if (typeof chapter.id !== 'string')
    errors.push('missing or non-string chapter id');

  if (typeof chapter.name !== 'string')
    errors.push('missing or non-string chapter name');

  if (chapter.intro && typeof chapter.intro !== 'string' && !Array.isArray(chapter.intro))
    errors.push('invalid chapter intro (should be string or array)');
  else if (chapter.intro) {
    const intro = Array.isArray(chapter.intro) ? chapter.intro.join(' ') : chapter.intro;
    const htmlErrors = checkHtml(intro);
    if (htmlErrors.length > 0)
      errors.push(`invalid HTML in intro: ${htmlErrors[0]}`);
  }

  return errors;
}

function verifyQuest (quest, originalData, verbose) {
  const errors = [];

  if (typeof quest.name !== 'string')
    errors.push('missing or non-string quest name');

  if (typeof quest.intro !== 'string')
    errors.push('missing or non-string quest intro');
  else {
    const htmlErrors = checkHtml(quest.intro);
    if (htmlErrors.length > 0)
      errors.push(`invalid HTML in intro: ${htmlErrors[0]}`);
  }

  // Verify metadata
  const date = quest.meta.created_at;
  if (!date || typeof date !== 'string')
    errors.push('missing or non-string created_at date');
  else {
    try {
      const d = new Date(date);
      if (!(d instanceof Date) || isNaN(d))
        errors.push('invalid created_at date format');

      const minDate = new Date('2024-07-15');
      if (d < minDate)
        errors.push(`created_at date is before 2024-07-15: ${date}`);

      if (d > new Date())
        errors.push(`created_at date is in the future: ${date}`);
    } catch (err) {
      errors.push('invalid created_at date');
    }
  }

  if (typeof quest.meta.id !== 'string' || !quest.meta.id.match(/\S/))
    errors.push('missing or invalid quest id');

  if (quest.cases.length < 1)
    errors.push('quest has no test cases');

  return errors;
}

function checkHtml (text) {
  // HTML tag pattern: <tagname attr="value"> or </tagname>
  // We'll use a simple regex-based tokenizer
  const tagPattern = /<\/?[a-z][a-z_0-9]*[^>]*>/gi;
  const entities = /&[A-Za-z_0-9#]+;/g;

  let match;
  const stack = [];
  const errors = [];
  const lastIndex = 0;

  // Extract all tags using regex
  const allMatches = [];
  while ((match = tagPattern.exec(text)) !== null) {
    allMatches.push({
      tag:   match[0],
      index: match.index
    });
  }

  // Process each tag with a push-down automaton (stack-based approach)
  for (const { tag } of allMatches) {
    if (tag[1] === '/') {
      // Closing tag
      if (stack.length === 0) {
        errors.push(`Unexpected closing tag: ${tag}`);
        continue;
      }

      // Extract tag name from closing tag
      const closeMatch = tag.match(/^<\/([a-z][a-z_0-9]*)/i);
      if (!closeMatch) {
        errors.push(`Invalid closing tag: ${tag}`);
        continue;
      }

      const closeName = closeMatch[1];
      const openName = stack[stack.length - 1];

      if (closeName.toLowerCase() !== openName.toLowerCase())
        errors.push(`Mismatched closing tag: </${closeName}> does not match <${openName}>`);

      stack.pop();
    } else {
      // Opening tag (check if it's self-closing)
      const openMatch = tag.match(/^<([a-z][a-z_0-9]*)/i);
      if (!openMatch) {
        errors.push(`Invalid opening tag: ${tag}`);
        continue;
      }

      const tagName = openMatch[1];

      // Check if it's a self-closing tag (ends with />)
      if (!tag.endsWith('/>'))
        stack.push(tagName);
    }
  }

  // Check for unclosed tags
  if (stack.length > 0)
    errors.push(`Unclosed tags: ${stack.map(t => `<${t}>`).join(', ')}`);

  return errors;
}
