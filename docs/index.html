<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8"/>
    <title>Simple Kombinator Interpreter</title>
    <meta name="description" content="Online combinatory logic and lambda calculus playground">
    <meta name="author" content="Konstantin S. Uvarin">
    <link rel="canonical" href="http://dallaylaen.github.io/ski-interpreter/">
    <link rel="shortcut icon" type="image/png" href="img/ski-64.png">
    <link rel="stylesheet" href="css/main.css">
    <link rel="prefetch" href="img/mock1.png">
    <link rel="prefetch" href="img/mock2.png">
    <script src="build/js/ski-interpreter.min.js"></script>
    <script src="build/js/util.min.js"></script>
    <style>
        /* page layout */
        body {
            display: grid;
            grid-template-columns: 70% 30%;
            grid-template-rows: auto 1fr 0 auto auto;
            grid-template-areas:
                "header header"
                "teletype info"
                "history-placeholder history-placeholder"
                "prompt prompt"
                "footer footer";
            padding: 0;
            margin: 0;
            height: 100vh;
        }
        header {
            grid-area: header;
        }
        #teletype {
            grid-area: teletype;
            padding: 0.3em;
            overflow-y: auto;
        }
        #info {
            overflow: auto;
            grid-area: info;
        }
        #around-history {
            grid-area: history-placeholder;
            position: relative;
            margin: 0 0.5em;
        }
        #prompt {
            display: flex;
            flex-direction: row;
            grid-area: prompt;
            font-size: 1rem;
        }
        footer {
            grid-area: footer;
            padding: 1px .5em;
            margin-top: 1ex;
            background: #F3F3F3;
        }

        /* page-specific elements */
        #entry-field {
            flex: 1 auto;
        }
        #history-main {
            position: absolute;
            left: 0;
            bottom: 0;
            z-index: 50; /* menu is 100, be below it */
            max-height: 70vh;
            min-width: 30%;
            overflow-y: auto;
            background-color: lightgray;
        }

        header, #teletype, #prompt {
            padding: 0 .5em;
        }

        /* TODO wtf these do? */
        footer::first-letter {
            padding: 0pt 1pt;
        }

        p.caption {
            font-weight: bold;
            margin: 0;
        }

        /* main button :) */
        #runstop-btn {
            flex: 0 auto;
            font-family: monospace;
            font-size: 120%;
            line-height: 80%;
            height: 100%;
            width: 2em;
            padding: 0;
        }

        #runstop-btn::before {
            display: inline-block;
            vertical-align: 20%;

            content: '\25B6\FE0E';
            color: darkGreen;
        }

        #runstop-btn.running::before {
            content: '\25A0\FE0E';
            color: darkRed;
        }

        #entry-field {
            font-family: monospace;
        }
    </style>
</head>
<body>
    <header>
        <div class="float-left"><span id="menu" class="big">&#9776;</span></div>
        <h1><img src="img/mock1.png" alt=""> Simple Kombinator <nobr>Interpreter <img src="img/mock2.png" alt=""></nobr></h1>
    </header>
    <div id="teletype">
        <div>
            <p>Welcome to the
                <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus" target="_blank">combinatory logic</a>
                interpreter.
            </p>
            <p>Type an expression in the entry field and click <tt title="Run!" class="icon-run">▶︎</tt>.
                A valid expression contains one or more terms and parenthesis around groups of terms.
                Unknown terms will be considered free variables and left as is.
            </p>
            <p>New terms can be declared by prepending <code>"name&nbsp;=&nbsp;"</code> to the expression.
                They will appear in the box on the right and can be clicked to add them to the expression.
            </p>
            <p>
                The interpreter supports <a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank">lambda calculus</a>
                and <a href="https://en.wikipedia.org/wiki/Church_encoding" target="_blank">Church numerals</a>.
                Lambda expressions are written as <code>x-&gt;y-&gt;z-&gt;&lt;expression&gt;</code>.
                Church numerals are written as non-negative integers.
            </p>
            <p>
                The <b>&rarr;SK</b> button converts an expression into the SKI basis, term by term, and
                the <b>&rarr;&lambda;</b> button attempts to find the shortest equivalent lambda term.
            </p>
            <p>
                Enter <code>?</code> to get detailed info on syntax.
            </p>
        </div>
        <div id="help" hidden>
            <img src="img/mock2.png" alt="" style="height: 5em; margin: 1ex; float: right;">
            <p>The interpreter honors the following rules:</p>
            <ul>
                <li>
                    Terms are accepted in the form of upper-case latin letters, or lower case identifiers.
                    Uppercase letter terms are assumed to always be one letter and do not require spaces
                    around them.
                </li>
                <li>
                    A program consists of one or more statements, separated by semicolons (<code>;</code>).
                    A statement may contain terms, parentheses (<code>(</code> and <code>)</code>),
                    and whitespace. Parentheses may be omitted.
                </li>
                <li>
                    Unknown terms are assumed to be free variables and will be left as is.
                    Known terms and their reduction rules (or implementations) are listed in the right panel.
                </li>
                <li>
                    If a statement is prepended with <code>identifier = </code>, it defines a new <i>temporary</i>
                    term that can be used in further expressions.
                </li>
                <li>
                    If that happens to the <i>last</i> statement in the group,
                    it will be permanently added to list of available terms, overriding the existing
                    term with the same name.
                </li>
                <li>
                    An <code>x->y->z->&lt;some expression&gt;</code> is a lambda expression.
                    Lambdas may be mixed with ordinary combinators.
                    <s>Please use Haskell instead</s>.
                </li>
                <li>
                    A non-negative integer is assumed to be a Church numeral, i.e. a term with
                    two arguments <code>x</code> and <code>y</code>
                    returning <code>x(...{n times}...(x(y)...)</code>.
                </li>
            </ul>
            <p>Examples: </p>
            <ul>
                <li><code>SIIx</code> evaluates to <code>x(x)</code> <i>// where x is a free variable;</i></li>
                <li><code>T = S(K(SI))K</code> declares the T combinator;</li>
                <li><code>M = SII; Mx</code> evaluates to x(x), M will <b>not</b> be available afterwards;</li>
                <li><code>5 x y</code> evaluates to <code>x(x(x(x(x(y)))))</code>;</li>
                <li><code>x-&gt;y-&gt;x</code> is an equivalent of <code>Kx</code>.</li>
            </ul>
            <p>Enter '?' to get this message again.</p>
        </div>
    </div>

    <div id="info">
        <p class="caption">Term inventory:</p>
        <dl id="inventory" class="term-list"></dl>
    </div>
    <div id="around-history">
        <div class="history-main" id="history-main" hidden></div>
    </div>
    <div id="prompt">
        <button id="history-show">H</button>
        <input id="entry-field">
        <button id="runstop-btn" type="submit"></button>
        <button id="to-ski" title="Convert to SKI basis">&rarr;SK</button>
        <button id="to-lambda" title="Attempt to find the shortest equivalent &lambda;-term">&rarr;&lambda;</button>
    </div>
    <footer>
        <small>&copy;&thinsp;2024&thinsp;&ndash;&thinsp;2025
        <a href="https://github.com/dallaylaen" target="_blank">dallaylaen</a>
        (<a href="https://github.com/dallaylaen/ski-interpreter" target="_blank">sources</a>)</small>
    </footer>
<script>
    /**
     *   References to static page elements
     */
    const view = util.grabView('inventory', 'teletype', 'help', 'menu',
      'entryField', 'runstopBtn', 'toSki', 'toLambda', 'historyShow', 'historyMain');
    const store = new Store('playground');
    const history = new History({
      store: new Store('playground-history'),
      limit: 10000,
    });

    /**
     *   Global state of the interpreter
     */

    let ski; // @type {SKI}
    let autosave = false;
    let greet;
    let currentBox = null;
    const evalOptions = {
        delay: 300,
        height: 7,
    };
    // Display options compatible with Expr.format()
    let format = {
      html: true,
    };
    let evalId = 0;

    // Initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    function init() {
        setupMenu();
        setupMain();
    }

    function setupMain() {
        view.entryField.addEventListener('keydown', onKey);
        view.entryField.addEventListener('input', saveInput);
        view.historyShow.addEventListener('click', showHistory);

        const oldHash = util.readOldLink(window.location.search);
        if (oldHash) {
            window.location.hash = oldHash;
            window.history.replaceState({}, document.title, window.location.pathname + window.location.hash);
        }

        const hotlink = util.readlink(window.location.hash);
        if (hotlink && hotlink.expr) {
            ski = new SKI();
            autosave = false;
            ski.bulkAdd(hotlink.decls);
            view.entryField.value = hotlink.expr;
        } else {
            ski = new SKI(store.load('engine') ?? {} );
            autosave = true;
            view.entryField.value = loadInput() ?? 'S(K(SI))K x y';
        }
        showInventory();

        view.runstopBtn.addEventListener('click', ev => {
            run();
        });

        view.toSki.addEventListener('click', ev => {
            run({src: view.entryField.value, action: 'toSKI'});
        });

        view.toLambda.addEventListener('click', ev => {
            run({src: view.entryField.value, action: 'toLambda'});
        });

        greet = new EvalBox({parent: view.teletype})
        greet.print(
            "Interpreter ready. Your output goes here. ",
            {color: "green", line: ''}
        );

       // TODO window.addEventListener('hashchange', onHashChange);
    }

    function setupMenu() {
        const menu = new Hamburger(view.menu);
        const ctlSpeed = new SMCtl({
          onchange: val => { evalOptions.delay = val; if (currentBox) currentBox.delay = val; },
          storage: [store, 'eval-delay'],
          default: 300,
          check: val => val >= 0,
        })
        menu.addChoice('speed (ms)', ctlSpeed, [0, 50, 100, 200, 300, 500, 1000]);
        const ctlHeight = new SMCtl({
          onchange: val => { evalOptions.height = val; if (currentBox) currentBox.setHeight(val); },
          storage: [store, 'eval-height'],
          default: 7,
          check: val => val >= 1,
        })
        menu.addChoice('history lines', ctlHeight, [3, 5, 7, 10, 20, ['&infin;', Infinity]]);
        menu.addFlags('display', [
          [
            'terse',
            new SMCtl({
              storage: [store, 'display-terse'],
              default: true,
              check: val => typeof val === 'boolean',
              onchange: on => { setFormat({terse: on}); },
            })
          ],
          [
            'fancy',
            new SMCtl({
                storage: [store, 'display-fancy'],
                default: true,
                check: val => typeof val === 'boolean',
                onchange: on => {
                  setFormat(on ? {
                    redex: ['<b>', '</b>'],
                    brackets: ['<span class="bracket">(</span>', '<span class="bracket">)</span>'],
                    var: ['<var>', '</var>'],
                  } : {
                    redex: ['',''],
                    brackets: ['(', ')'],
                    var: ['',''],
                  });
                },
            })
          ],
          [
            'outline',
            new SMCtl({
                storage: [store, 'display-outline'],
                default: false,
                check: val => typeof val === 'boolean',
                onchange: on => { setFormat( on ? {
                  around: ['<span class="outline">', '</span>'],
                  lambda: ['<span class="outline">', '-&gt;', '</span>'],
                } : {
                  around: ['', ''],
                  lambda: ['', '-&gt;', ''],
                });},
            })
          ]
        ]);
        menu.addAction('reset terms', () => {
            if (!window.confirm('Really erase all terms?'))
                return;
            ski = new SKI();
            store.save('engine', ski);
            showInventory();
        });
        menu.addSeparator();
        menu.addLink('quest mode', 'quest.html', '_blank');
        menu.addLink('combinator cheat sheet', 'https://angelfire.com/tx4/cus/combinator/birds.html', '_blank');
        menu.addLink('ski calculus', 'https://en.wikipedia.org/wiki/SKI_combinator_calculus', '_blank');
        menu.addSeparator();
        menu.addAction('help', () => new EvalBox({ parent: view.teletype }).print(view.help.innerHTML, {raw: true}));
    }

    /**
     * Page-specific functions
     */

    let historyVisible = false;

    function showHistory() {
      if (historyVisible) {
        hideHistory();
        return;
      }
      view.historyMain.innerHTML = '';
      append(view.historyMain, 'div', { class: ['history-title'], content: 'input history'});
      const list = append(view.historyMain, 'ol', { class: ['history-list']});
      for (const entry of history.list({last: view.entryField.value})) {
        const item = append(list, 'li', { class: ['history-item'], content: entry });
        item.addEventListener('click', ev => {
          ev.preventDefault();
          view.entryField.value = entry;
          hideHistory();
        });
      }
      view.historyMain.hidden = false;
      historyVisible = true;
    }

    function hideHistory() {
        view.historyMain.hidden = true;
        view.historyMain.innerHTML = '';
        historyVisible = false;
    }

    function setFormat(options) {
      for (const key of Object.keys(options)) {
        if (options[key] === undefined)
          delete format[key];
        else
          format[key] = options[key];
      }
    }

    function onKey (event) {
        if (event.keyCode === 13) {
            event.preventDefault();
            run({src: view.entryField.value});
            return false;
        }
        return true;
    }

    function saveInput() {
        store.save('current-input', this.value);
    }

    function loadInput () {
        return store.load('current-input');
    }

    // ---- page functions ----

    const generator = {
        toSKI: e => e.toSKI(),
        toLambda: e => e.toLambda(),
    }

    function run(options = {}) {
        if (currentBox) {
          if (!options.src && !options.action) {
            currentBox.stop('Stopped by the user');
            return false; // already running + nothing special to run = stop
          }
          currentBox.stop('Interrupted by a different command');
        }

        if (greet)
            greet.remove();

        const src = options.src ?? view.entryField.value;


        if (src.match(/^\s*\?[\s?]*$/)) {
            const helpdiv = append(view.teletype, 'div', {class: ['console']});
            helpdiv.innerHTML = view.help.innerHTML; // no escape because HTML as planned
            helpdiv.scrollIntoView();
            return false;
        }

        history.push(src);

        createRunner(src, {action: options.action, id: ++evalId})?.start();
        return false;
    }

    /**
     *
     * @param {string} src
     * @param {Object} options
     * @returns {EvalBox}
     */
    function createRunner(src, options={}) {
        const container = evalFrame({parent: view.teletype, id: options.id});

        const runner = new EvalBox({
            parent:  container.content,
            scroll:  view.teletype,
            height:  evalOptions.height,
            delay:   evalOptions.delay,
            engine:  ski,
            generator: generator[options.action],
            format:  format,
            onStart: function() {
                if (currentBox)
                    currentBox.stop('Interrupted by a different command'); // only one box runnning at a time
                currentBox = this;
                view.runstopBtn.classList.add('running');
                if (this.expr instanceof SKI.classes.Alias) {
                    // user defined a new term
                    this.engine.add(this.expr);
                    showInventory();
                }
            },
            onStop:  function () {
                view.runstopBtn.classList.remove('running');
                currentBox = null;
            },
            onStep:  function(value) {
              if (value && value.steps !== undefined)
                container.steps.innerHTML = '' + value.steps;
            }
        });

        container.src.innerHTML = util.sanitize(src);
        container.permalink.innerHTML = util.sanitize('#' + options.id);
        container.permalink.href = util.permalink(ski, src);

        try {
            runner.set(src);
            return runner;
        } catch (e) {
            runner.stop('Error: ' + util.sanitize(e.message));
        }
        return null;
    }

    /**
     * @desc Create decorative and control elements for EvalBox to be attached to
     * @return {{
     *     main: HTMLElement,
     *     content: HTMLElement,
     *     permalink: HTMLElement,
     *     src: HTMLElement,
     *     steps: HTMLElement,
     *     footer: HTMLElement,
     *  }}
     */

    function evalFrame(options = {}) {
      const main = append(options.parent, 'div', {class: ['console']});
      const header = append(main, 'div', {class: ['con-header']});
      const permalink = append(header, 'a', {class: ['permalink'], content: '#' + options.id},
          e => { e.target = '_blank'; });
      append(header, 'span', {content: ' '}); // spacer
      const src = append(header, 'span', {class: ['src'], content: options.src});
      const steps = append(header, 'span', {class: ['steps', 'float-right'], content: '-'});
      const content = append(main, 'div', {}); // no class here because EvalBox has enough
      const footer = append(main, 'div', {class: ['con-footer']});
      return {main, content, permalink, src, steps, footer};
    }

    function showInventory() {
      // TODO should not be here but still
      if (autosave)
        store.save('engine', ski);

      view.inventory.innerHTML = '';
      const list = ski.getTerms();
      for (let name of Object.keys(list).filter(s => s.match(/^[a-z_]/i)).sort()) {
        const entry = list[name];
        const entryDiv = append(view.inventory, 'div');
            const entrySpan = append(entryDiv, 'a', {class: ['term-def', 'ellipsis']} );
            entrySpan.href = "#";
            entrySpan.onclick = event => insertInventoryItem(name);
            append(entrySpan, 'dt', {
                content: name,
            });
            append(entrySpan, 'dd', {
                content: '= '+(entry.note ?? entry.impl.format({terse: true, html: true, lambda: ['', ' &mapsto; ', '']}))
            });
            const placeholder = append(entryDiv, 'span', {class: [ 'float-right' ], content: '&Xi;'});
            const menu = new Hamburger(placeholder, {right: true});
            menu.addLabel('manage ' + name);
            if (entry instanceof SKI.classes.Alias) {
                menu.addAction('copy definition', () => navigator.clipboard.writeText(
                    `${name} = ${entry.impl}`));
                menu.addAction('play in terminal', () => {
                    run({src: entry.name + ' = ' + entry.impl});
                });
            }
            menu.addAction('&cross; remove', () => removeInventoryEntry(name));
        }
        if (ski.hasLambdas) {
            append(view.inventory, 'div', {
                content: '<span class="term-def ellipsis"><dt><span class="note"><a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank">λ-terms</a> </span><var>x-&gt;y-&gt;z-&gt;&lt;expression&gt;</var></dt></span>'
            });
        }
        if (ski.hasNumbers) {
            append(view.inventory, 'div', {
                content: '<span class="term-def ellipsis"><dt><var>&lt;n&gt;</var></dt><dd> = <var>f</var> &mapsto; <var>x</var> &mapsto; f(…{n times}…(f(x))…) <i>>// aka <a href="https://en.wikipedia.org/wiki/Church_encoding#Church_numerals">Church numerals</a></i></dd></span>'
            });
        }
    }

    function removeInventoryEntry(name) {
        ski.remove(name);
        showInventory();
    }

    function insertInventoryItem(text) {
        const orig = view.entryField.value;
        const prefix = orig.substring(0,  view.entryField.selectionStart);
        const postfix = orig.substring(view.entryField.selectionEnd);

        // add spaces around if we're not an elementary term
        if (!text.match(/^[()A-Z]$/))
            text = (prefix.match(/(?:^| )$/) ? '' : ' ') + text + (postfix.match(/^(?: |$)/) ? '' : ' ');

        view.entryField.value = prefix + text + postfix;
        view.entryField.selectionStart = prefix.length + text.length;
        view.entryField.selectionEnd   = prefix.length + text.length;

        return false;
    }

</script>

</body>
</html>
