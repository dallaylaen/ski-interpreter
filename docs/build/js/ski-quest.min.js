"use strict";
(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // src/internal.js
  var require_internal = __commonJS({
    "src/internal.js"(exports, module) {
      var Tokenizer = class {
        /**
         * @desc Create a tokenizer that splits strings into tokens according to the given terms.
         * The terms are interpreted as regular expressions, and are sorted by length
         * to ensure that longer matches are preferred over shorter ones.
         * @param {...string|RegExp} terms
         */
        constructor(...terms) {
          const src = "$|(\\s+)|" + terms.map((s) => "(?:" + s + ")").sort((a, b) => b.length - a.length).join("|");
          this.rex = new RegExp(src, "gys");
        }
        /**
         * @desc Split the given string into tokens according to the terms specified in the constructor.
         * @param {string} str
         * @return {string[]}
         */
        split(str) {
          this.rex.lastIndex = 0;
          const list = [...str.matchAll(this.rex)];
          const eol = list.pop();
          const last = eol?.index ?? 0;
          if (last !== str.length) {
            throw new Error("Unknown tokens at pos " + last + "/" + str.length + " starting with " + str.substring(last));
          }
          return list.filter((x) => x[1] === void 0).map((x) => x[0]);
        }
      };
      var tokRestrict = new Tokenizer("[-=+]", "[A-Z]", "\\b[a-z_][a-z_0-9]*\\b");
      function restrict(set, spec) {
        if (!spec)
          return set;
        let out = /* @__PURE__ */ new Set([...set]);
        const act = {
          "=": (sym) => {
            out = /* @__PURE__ */ new Set([sym]);
            mode = "+";
          },
          "+": (sym) => {
            out.add(sym);
          },
          "-": (sym) => {
            out.delete(sym);
          }
        };
        let mode = "=";
        for (const sym of tokRestrict.split(spec)) {
          if (act[sym])
            mode = sym;
          else
            act[mode](sym);
        }
        return out;
      }
      var TraverseControl = class {
        /**
         * @desc A wrapper for values returned by fold/traverse callbacks
         *       which instructs the traversal to alter its behavior while
         *       retaining the value in question.
         *
         *       This class is instantiated internally be `SKI.control.*` functions,
         *       and is not intended to be used directly by client code.
         *
         * @template T
         * @param {T} value
         * @param {function(T): TraverseControl<T>} decoration
         */
        constructor(value, decoration) {
          this.value = value;
          this.decoration = decoration;
        }
      };
      function unwrap(value) {
        if (value instanceof TraverseControl)
          return [value.value ?? void 0, value.decoration];
        return [value ?? void 0, void 0];
      }
      function prepareWrapper(label) {
        const fun = (value) => new TraverseControl(value, fun);
        fun.label = label;
        fun.toString = () => "TraverseControl::" + label;
        return fun;
      }
      module.exports = { Tokenizer, restrict, unwrap, prepareWrapper };
    }
  });

  // src/expr.js
  var require_expr = __commonJS({
    "src/expr.js"(exports, module) {
      "use strict";
      var { unwrap, prepareWrapper } = require_internal();
      var DEFAULTS = {
        max: 1e3,
        maxArgs: 32
      };
      var control = {
        descend: prepareWrapper("descend"),
        prune: prepareWrapper("prune"),
        redo: prepareWrapper("redo"),
        stop: prepareWrapper("stop")
      };
      var Expr = class _Expr {
        /**
         *  @descr A combinatory logic expression.
         *
         *  Applications, variables, and other terms like combinators per se
         *  are subclasses of this class.
         *
         *  @abstract
         *  @property {{
         *    scope?: any,
         *    env?: { [key: string]: Expr },
         *    src?: string,
         *    parser: object,
         *  }} [context]
         */
        constructor() {
          if (new.target === _Expr)
            throw new Error("Attempt to instantiate abstract class Expr");
        }
        /**
         * @desc apply self to zero or more terms and return the resulting term,
         * without performing any calculations whatsoever
         * @param {Expr} args
         * @return {Expr}
         */
        apply(...args) {
          let expr = this;
          for (const arg of args)
            expr = new App(expr, arg);
          return expr;
        }
        /**
         * @desc Replace all aliases in the expression with their definitions, recursively.
         * @return {Expr}
         */
        expand() {
          return this.traverse((e) => {
            if (e instanceof Alias)
              return e.impl.expand();
          }) ?? this;
        }
        /**
         * @desc Returns true if the expression contains only free variables and applications, false otherwise.
         * @returns {boolean}
         */
        freeOnly() {
          return !this.any((e) => !(e instanceof FreeVar || e instanceof App));
        }
        /**
         * @desc Traverse the expression tree, applying change() to each node.
         *       If change() returns an Expr, the node is replaced with that value.
         *       Otherwise, the node is descended further (if applicable)
         *       or left unchanged.
         *
         *       The traversal order is leftmost-outermost (LO), i.e. the same order as reduction steps are taken.
         *
         *       Returns null if no changes were made, or the new expression otherwise.
         *
         * @param {(e:Expr) => (Expr|null)} change
         * @returns {Expr|null}
         */
        traverse(change) {
          return change(this);
        }
        /**
         * @desc Returns true if predicate() is true for any subterm of the expression, false otherwise.
         *
         * @param {(e: Expr) => boolean} predicate
         * @returns {boolean}
         */
        any(predicate) {
          return predicate(this);
        }
        /**
         * @desc Fold the expression into a single value by recursively applying combine() to its subterms.
         *       Nodes are traversed in leftmost-outermost order, i.e. the same order as reduction steps are taken.
         *
         * null or undefined return value from combine() means "keep current value and descend further".
         *
         * SKI.control provides primitives to control the folding flow:
         *  - SKI.control.prune(value) means "use value and don't descend further into this branch";
         *  - SKI.control.stop(value) means "stop folding immediately and return value".
         *  - SKI.control.descend(value) is the default behavior, meaning "use value and descend further".
         *
         * This method is experimental and may change in the future.
         *
         * @experimental
         * @template T
         * @param {T} initial
         * @param {(acc: T, expr: Expr) => TraverseValue<T>} combine
         * @returns {T}
         */
        fold(initial, combine) {
          const [value, _] = unwrap(this._fold(initial, combine));
          return value ?? initial;
        }
        /**
         * @template T
         * @param {T} initial
         * @param {(acc: T, expr: Expr) => TraverseValue<T>} combine
         * @returns {TraverseValue<T>}
         * @private
         */
        _fold(initial, combine) {
          return combine(initial, this);
        }
        /**
         * @desc rough estimate of the term's complexity
         * @return {number}
         */
        weight() {
          return 1;
        }
        /**
         * @desc Try to empirically find an equivalent lambda term for the expression,
         *       returning also the term's arity and some other properties.
         *
         *       This is used internally when declaring a Native / Alias term,
         *       unless {canonize: false} is used.
         *
         *       As of current it only recognizes terms that have a normal form,
         *       perhaps after adding some variables. This may change in the future.
         *
         *       Use toLambda() if you want to get a lambda term in any case.
         *
         * @param {{max?: number, maxArgs?: number}} options
         * @return {{
         *    normal: boolean,
         *    steps: number,
         *    expr?: Expr,
         *    arity?: number,
         *    proper?: boolean,
         *    discard?: boolean,
         *    duplicate?: boolean,
         *    skip?: Set<number>,
         *    dup?: Set<number>,
         * }}
         */
        infer(options = {}) {
          const max = options.max ?? DEFAULTS.max;
          const maxArgs = options.maxArgs ?? DEFAULTS.maxArgs;
          const out = this._infer({ max, maxArgs, index: 0 });
          return out;
        }
        /**
         *
         * @param {{max: number, maxArgs: number, index: number}} options
         * @param {FreeVar[]} preArgs
         * @param {number} steps
         * @returns {{
         *    normal: boolean,
         *    steps: number,
         *    expr?: Expr,
         *    arity?: number,
         *    skip?: Set<number>,
         *    dup?: Set<number>,
         *    duplicate, discard, proper: boolean
         * }
         * @private
         */
        _infer(options, preArgs = [], steps = 0) {
          if (preArgs.length > options.maxArgs || steps > options.max)
            return { normal: false, steps };
          if (this.freeOnly()) {
            return {
              normal: true,
              steps,
              ...maybeLambda(preArgs, this)
            };
          }
          const next = this.run({ max: (options.max - steps) / 3 });
          steps += next.steps;
          if (!next.final)
            return { normal: false, steps };
          if (next.steps !== 0)
            return next.expr._infer(options, preArgs, steps);
          if (this.unroll()[0] instanceof FreeVar)
            return { normal: false, steps };
          const push = nthvar(preArgs.length + options.index);
          return this.apply(push)._infer(options, [...preArgs, push], steps);
        }
        /**
         * @desc Expand an expression into a list of terms
         * that give the initial expression when applied from left to right:
         * ((a, b), (c, d)) => [a, b, (c, d)]
         *
         * This can be thought of as an opposite of apply:
         * fun.apply(...arg).unroll() is exactly [fun, ...args]
         * (even if ...arg is in fact empty).
         *
         * @returns {Expr[]}
         */
        unroll() {
          return [this];
        }
        /**
         * @desc Returns a series of lambda terms equivalent to the given expression,
         *       up to the provided computation steps limit,
         *       in decreasing weight order.
         *
         *       Unlike infer(), this method will always return something,
         *       even if the expression has no normal form.
         *
         *       See also Expr.walk() and Expr.toSKI().
         *
         * @param {{
         *   max?: number,
         *   maxArgs?: number,
         *   varGen?: function(void): FreeVar,
         *   steps?: number,
         *   html?: boolean,
         *   latin?: number,
         * }} options
         * @param {number} [maxWeight] - maximum allowed weight of terms in the sequence
         * @return {IterableIterator<{expr: Expr, steps?: number, comment?: string}>}
         */
        *toLambda(options = {}) {
          const expr = this.traverse((e) => {
            if (e instanceof FreeVar || e instanceof App || e instanceof Lambda || e instanceof Alias)
              return null;
            const guess = e.infer({ max: options.max, maxArgs: options.maxArgs });
            if (!guess.normal)
              throw new Error("Failed to infer an equivalent  lambda term for " + e);
            return guess.expr;
          }) ?? this;
          yield* simplifyLambda(expr, options);
        }
        /**
         * @desc Rewrite the expression into S, K, and I combinators step by step.
         *     Returns an iterator yielding the intermediate expressions,
         *     along with the number of steps taken to reach them.
         *
         *     See also Expr.walk() and Expr.toLambda().
         *
         * @param {{max?: number}} [options]
         * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}
         */
        *toSKI(options = {}) {
          let steps = 0;
          let expr = this;
          while (true) {
            const opt = { max: options.max ?? 1, steps: 0 };
            const next = expr._rski(opt);
            const final = opt.steps === 0;
            yield { expr, steps, final };
            if (final)
              break;
            expr = next;
            steps += opt.steps;
          }
        }
        /**
         * @desc Internal method for toSKI, which performs one step of the conversion.
         * @param {{max: number, steps: number}} options
         * @returns {Expr}
         * @private
         */
        _rski(options) {
          return this;
        }
        /**
         * Replace all instances of plug in the expression with value and return the resulting expression,
         * or null if no changes could be made.
         * Lambda terms and applications will never match if used as plug
         * as they are impossible co compare without extensive computations.
         * Typically used on variables but can also be applied to other terms, e.g. aliases.
         * See also Expr.traverse().
         * @param {Expr} search
         * @param {Expr} replace
         * @return {Expr|null}
         */
        subst(search, replace) {
          return this === search ? replace : null;
        }
        /**
         * @desc Apply term reduction rules, if any, to the given argument.
         * A returned value of null means no reduction is possible.
         * A returned value of Expr means the reduction is complete and the application
         *     of this and arg can be replaced with the result.
         * A returned value of a function means that further arguments are needed,
         *     and can be cached for when they arrive.
         *
         * This method is between apply() which merely glues terms together,
         *     and step() which reduces the whole expression.
         *
         * foo.invoke(bar) is what happens inside foo.apply(bar).step() before
         *     reduction of either foo or bar is attempted.
         *
         * The name 'invoke' was chosen to avoid confusion with either 'apply' or 'reduce'.
         *
         * @param {Expr} arg
         * @returns {Partial | null}
         */
        invoke(arg) {
          return null;
        }
        /**
         * @desc iterate one step of a calculation.
         * @return {{expr: Expr, steps: number, changed: boolean}}
         */
        step() {
          return { expr: this, steps: 0, changed: false };
        }
        /**
         * @desc Run uninterrupted sequence of step() applications
         *       until the expression is irreducible, or max number of steps is reached.
         *       Default number of steps = 1000.
         * @param {{max?: number, steps?: number, throw?: boolean}|Expr} [opt]
         * @param {Expr} args
         * @return {{expr: Expr, steps: number, final: boolean}}
         */
        run(opt = {}, ...args) {
          if (opt instanceof _Expr) {
            args.unshift(opt);
            opt = {};
          }
          let expr = args ? this.apply(...args) : this;
          let steps = opt.steps ?? 0;
          const max = Math.max(opt.max ?? DEFAULTS.max, 1) + steps;
          let final = false;
          for (; steps < max; ) {
            const next = expr.step();
            if (!next.changed) {
              final = true;
              break;
            }
            steps += next.steps;
            expr = next.expr;
          }
          if (opt.throw && !final)
            throw new Error("Failed to compute expression in " + max + " steps");
          return { final, steps, expr };
        }
        /**
         * Execute step() while possible, yielding a brief description of events after each step.
         * Mnemonics: like run() but slower.
         * @param {{max?: number}} options
         * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}
         */
        *walk(options = {}) {
          const max = options.max ?? Infinity;
          let steps = 0;
          let expr = this;
          let final = false;
          while (steps < max) {
            const next = expr.step();
            if (!next.changed)
              final = true;
            yield { expr, steps, final };
            if (final)
              break;
            steps += next.steps;
            expr = next.expr;
          }
        }
        /**
         * @desc True is the expressions are identical, false otherwise.
         *       Aliases are expanded.
         *       Bound variables in lambda terms are renamed consistently.
         *       However, no reductions are attempted.
         *
         *       E.g. a->b->a == x->y->x is true, but a->b->a == K is false.
         *
         * @param {Expr} other
         * @return {boolean}
         */
        equals(other) {
          return !this.diff(other);
        }
        /**
         * @desc Recursively compare two expressions and return a string
         *       describing the first point of difference.
         *       Returns null if expressions are identical.
         *
         *       Aliases are expanded.
         *       Bound variables in lambda terms are renamed consistently.
         *       However, no reductions are attempted.
         *
         *       Members of the FreeVar class are considered different
         *       even if they have the same name, unless they are the same object.
         *       To somewhat alleviate confusion, the output will include
         *       the internal id of the variable in square brackets.
         *
         * @example  "K(S != I)" is the result of comparing "KS" and "KI"
         * @example  "S(K([x[13] != x[14]]))K"
         *
         * @param {Expr} other
         * @param {boolean} [swap]  If true, the order of expressions is reversed in the output.
         * @returns {string|null}
         */
        diff(other, swap = false) {
          if (this === other)
            return null;
          if (other instanceof Alias)
            return other.impl.diff(this, !swap);
          return swap ? "[" + other + " != " + this + "]" : "[" + this + " != " + other + "]";
        }
        /**
         * @desc Assert expression equality. Can be used in tests.
         * @param {Expr} expected
         * @param {string} comment
         */
        expect(expected, comment = "") {
          comment = comment ? comment + ": " : "";
          if (!(expected instanceof _Expr))
            throw new Error(comment + "attempt to expect a combinator to equal something else: " + expected);
          const diff = this.diff(expected);
          if (!diff)
            return;
          const poorMans = new Error(comment + diff);
          poorMans.expected = expected + "";
          poorMans.actual = this + "";
          throw poorMans;
        }
        /**
         * @desc Returns string representation of the expression.
         *       Same as format() without options.
         * @return {string}
         */
        toString() {
          return this.format();
        }
        /**
         * @desc Whether the expression needs parentheses when printed.
         * @param {boolean} [first] - whether this is the first term in a sequence
         * @return {boolean}
         */
        _braced(first) {
          return false;
        }
        /**
         * @desc Whether the expression can be printed without a space when followed by arg.
         * @param {Expr} arg
         * @returns {boolean}
         * @private
         */
        _unspaced(arg) {
          return this._braced(true);
        }
        /**
         * @desc    Stringify the expression with fancy formatting options.
         *          Said options mostly include wrappers around various constructs in form of ['(', ')'],
         *          as well as terse and html flags that set up the defaults.
         *          Format without options is equivalent to toString() and can be parsed back.
         *
         * @param   {Object} [options]  - formatting options
         * @param   {boolean} [options.terse]   - whether to use terse formatting (omitting unnecessary spaces and parentheses)
         * @param   {boolean} [options.html]    - whether to default to HTML tags & entities.
         *                                If a named term has fancyName property set, it will be used instead of name in this mode.
         * @param   {[string, string]} [options.brackets]  - wrappers for application arguments, typically ['(', ')']
         * @param   {[string, string]} [options.var]       - wrappers for variable names
         *                                (will default to &lt;var&gt; and &lt;/var&gt; in html mode).
         * @param   {[string, string, string]} [options.lambda]    - wrappers for lambda abstractions, e.g. ['&lambda;', '.', '']
         *                                where the middle string is placed between argument and body
         *                                default is ['', '->', ''] or ['', '-&gt;', ''] for html
         * @param   {[string, string]} [options.around]    - wrappers around (sub-)expressions.
         *                                individual applications will not be wrapped, i.e. (a b c) but not ((a b) c)
         * @param   {[string, string]} [options.redex]     - wrappers around the starting term(s) that have enough arguments to be reduced
         * @param   {Object<string, Expr>} [options.inventory]     - if given, output aliases in the set as their names
         *                                and any other aliases as the expansion of their definitions.
         *                                The default is a cryptic and fragile mechanism dependent on a hidden mutable property.
         * @returns {string}
         *
         * @example foo.format() // equivalent to foo.toString()
         * @example foo.format({terse: false}) // spell out all parentheses
         * @example foo.format({html: true}) // use HTML tags and entities
         * @example foo.format({ around: ['(', ')'], brackets: ['', ''], lambda: ['(', '->', ')'] }) // lisp style, still back-parsable
         * @exapmle foo.format({ lambda: ['&lambda;', '.', ''] }) // pretty-print for the math department
         * @example foo.format({ lambda: ['', '=>', ''], terse: false }) // make it javascript
         * @example foo.format({ inventory: { T } }) // use T as a named term, expand all others
         *
         */
        format(options = {}) {
          const fallback = options.html ? {
            brackets: ["(", ")"],
            space: " ",
            var: ["<var>", "</var>"],
            lambda: ["", "-&gt;", ""],
            around: ["", ""],
            redex: ["", ""]
          } : {
            brackets: ["(", ")"],
            space: " ",
            var: ["", ""],
            lambda: ["", "->", ""],
            around: ["", ""],
            redex: ["", ""]
          };
          return this._format({
            terse: options.terse ?? true,
            brackets: options.brackets ?? fallback.brackets,
            space: options.space ?? fallback.space,
            var: options.var ?? fallback.var,
            lambda: options.lambda ?? fallback.lambda,
            around: options.around ?? fallback.around,
            redex: options.redex ?? fallback.redex,
            inventory: options.inventory,
            // TODO better name
            html: options.html ?? false
          }, 0);
        }
        /**
         * @desc Internal method for format(), which performs the actual formatting.
         * @param {Object} options
         * @param {number} nargs
         * @returns {string}
         * @private
         */
        _format(options, nargs) {
          throw new Error("No _format() method defined in class " + this.constructor.name);
        }
        /**
         * @desc Returns a string representation of the expression tree, with indentation to show structure.
         *
         *       Applications are flattened to avoid excessive nesting.
         *       Variables include ids to distinguish different instances of the same variable name.
         *
         *       May be useful for debugging.
         *
         * @returns {string}
         *
         * @example
         * > console.log(ski.parse('C 5 x (x->x x)').diag())
         * App:
         *   Native: C
         *   Church: 5
         *   FreeVar: x[53]
         *   Lambda (x[54]):
         *     App:
         *       FreeVar: x[54]
         *       FreeVar: x[54]
         */
        diag() {
          const rec = (e, indent) => {
            if (e instanceof App)
              return [indent + "App:", ...e.unroll().flatMap((s) => rec(s, indent + "  "))];
            if (e instanceof Lambda)
              return [`${indent}Lambda (${e.arg}[${e.arg.id}]):`, ...rec(e.impl, indent + "  ")];
            if (e instanceof Alias)
              return [`Alias (${e.name}):`, ...rec(e.impl, indent + "  ")];
            if (e instanceof FreeVar)
              return [`${indent}FreeVar: ${e.name}[${e.id}]`];
            return [`${indent}${e.constructor.name}: ${e}`];
          };
          const out = rec(this, "");
          return out.join("\n");
        }
        /**
         * @desc Convert the expression to a JSON-serializable format.
         * @returns {string}
         */
        toJSON() {
          return this.format();
        }
      };
      var App = class _App extends Expr {
        /**
         * @desc Application of fun() to args.
         * Never ever use new App(fun, arg) directly, use fun.apply(...args) instead.
         * @param {Expr} fun
         * @param {Expr} arg
         */
        constructor(fun, arg) {
          super();
          this.arg = arg;
          this.fun = fun;
          this.final = false;
          this.arity = this.fun.arity > 0 ? this.fun.arity - 1 : 0;
        }
        weight() {
          return this.fun.weight() + this.arg.weight();
        }
        _infer(options, preArgs = [], steps = 0) {
          if (preArgs.length > options.maxArgs || steps > options.max)
            return { normal: false, steps };
          const proxy = super._infer(options, preArgs, steps);
          if (proxy.normal)
            return proxy;
          steps = proxy.steps;
          const [first, ...list] = this.unroll();
          if (!(first instanceof FreeVar))
            return { normal: false, steps };
          let discard = false;
          let duplicate = false;
          const out = [];
          for (const term of list) {
            const guess = term._infer({
              ...options,
              maxArgs: options.maxArgs - preArgs.length,
              max: options.max - steps,
              index: preArgs.length + options.index
            });
            steps += guess.steps;
            if (!guess.normal)
              return { normal: false, steps };
            out.push(guess.expr);
            discard = discard || guess.discard;
            duplicate = duplicate || guess.duplicate;
          }
          return {
            normal: true,
            steps,
            ...maybeLambda(preArgs, first.apply(...out), {
              discard,
              duplicate
            })
          };
        }
        traverse(change) {
          const replaced = change(this);
          if (replaced instanceof Expr)
            return replaced;
          const fun = this.fun.traverse(change);
          const arg = this.arg.traverse(change);
          if (!fun && !arg)
            return null;
          return (fun ?? this.fun).apply(arg ?? this.arg);
        }
        any(predicate) {
          return predicate(this) || this.fun.any(predicate) || this.arg.any(predicate);
        }
        _fold(initial, combine) {
          const [value = initial, action = "descend"] = unwrap(combine(initial, this));
          if (action === control.prune)
            return value;
          if (action === control.stop)
            return control.stop(value);
          const [fValue = value, fAction = "descend"] = unwrap(this.fun._fold(value, combine));
          if (fAction === control.stop)
            return control.stop(fValue);
          const [aValue = fValue, aAction = "descend"] = unwrap(this.arg._fold(fValue, combine));
          if (aAction === control.stop)
            return control.stop(aValue);
          return aValue;
        }
        subst(search, replace) {
          const fun = this.fun.subst(search, replace);
          const arg = this.arg.subst(search, replace);
          return fun || arg ? (fun ?? this.fun).apply(arg ?? this.arg) : null;
        }
        /**
         * @return {{expr: Expr, steps: number}}
         */
        step() {
          if (!this.final) {
            const partial = this.fun.invoke(this.arg);
            if (partial instanceof Expr)
              return { expr: partial, steps: 1, changed: true };
            else if (typeof partial === "function")
              this.invoke = partial;
            const fun = this.fun.step();
            if (fun.changed)
              return { expr: fun.expr.apply(this.arg), steps: fun.steps, changed: true };
            const arg = this.arg.step();
            if (arg.changed)
              return { expr: this.fun.apply(arg.expr), steps: arg.steps, changed: true };
            this.final = true;
          }
          return { expr: this, steps: 0, changed: false };
        }
        invoke(arg) {
          const partial = this.fun.invoke(this.arg);
          if (partial instanceof Expr)
            return partial.apply(arg);
          else if (typeof partial === "function") {
            this.invoke = partial;
            return partial(arg);
          } else {
            this.invoke = (_) => null;
            return null;
          }
        }
        unroll() {
          return [...this.fun.unroll(), this.arg];
        }
        _rski(options) {
          if (options.steps >= options.max)
            return this;
          return this.fun._rski(options).apply(this.arg._rski(options));
        }
        diff(other, swap = false) {
          if (!(other instanceof _App))
            return super.diff(other, swap);
          const fun = this.fun.diff(other.fun, swap);
          if (fun)
            return fun + "(...)";
          const arg = this.arg.diff(other.arg, swap);
          if (arg)
            return this.fun + "(" + arg + ")";
          return null;
        }
        _braced(first) {
          return !first;
        }
        _format(options, nargs) {
          const fun = this.fun._format(options, nargs + 1);
          const arg = this.arg._format(options, 0);
          const wrap = nargs ? ["", ""] : options.around;
          if (options.terse && !this.arg._braced(false))
            return wrap[0] + fun + (this.fun._unspaced(this.arg) ? "" : options.space) + arg + wrap[1];
          else
            return wrap[0] + fun + options.brackets[0] + arg + options.brackets[1] + wrap[1];
        }
        _unspaced(arg) {
          return this.arg._braced(false) ? true : this.arg._unspaced(arg);
        }
      };
      var Named = class _Named extends Expr {
        /**
         * @desc An abstract class representing a term named 'name'.
         *
         * @param {String} name
         */
        constructor(name) {
          super();
          if (typeof name !== "string" || name.length === 0)
            throw new Error("Attempt to create a named term with improper name");
          this.name = name;
        }
        _unspaced(arg) {
          return !!(arg instanceof _Named && (this.name.match(/^[A-Z+]$/) && arg.name.match(/^[a-z+]/i) || this.name.match(/^[a-z+]/i) && arg.name.match(/^[A-Z+]$/)));
        }
        _format(options, nargs) {
          const name = options.html ? this.fancyName ?? this.name : this.name;
          return this.arity > 0 && this.arity <= nargs ? options.redex[0] + name + options.redex[1] : name;
        }
      };
      var freeId = 0;
      var FreeVar = class _FreeVar extends Named {
        /**
         * @desc A named variable.
         *
         * Given the functional nature of combinatory logic, variables are treated
         * as functions that we don't know how to evaluate just yet.
         *
         * By default, two different variables even with the same name are considered different.
         * They display it via a hidden id property.
         *
         * If a scope object is given, however, two variables with the same name and scope
         * are considered identical.
         *
         * @param {string} name - name of the variable
         * @param {any} scope - an object representing where the variable belongs to.
         */
        constructor(name, scope) {
          super(name);
          this.id = ++freeId;
          this.scope = scope === void 0 ? this : scope;
        }
        weight() {
          return 0;
        }
        diff(other, swap = false) {
          if (!(other instanceof _FreeVar))
            return super.diff(other, swap);
          if (this.name === other.name && this.scope === other.scope)
            return null;
          const lhs = this.name + "[" + this.id + "]";
          const rhs = other.name + "[" + other.id + "]";
          return swap ? "[" + rhs + " != " + lhs + "]" : "[" + lhs + " != " + rhs + "]";
        }
        subst(search, replace) {
          if (search instanceof _FreeVar && search.name === this.name && search.scope === this.scope)
            return replace;
          return null;
        }
        _format(options, nargs) {
          const name = options.html ? this.fancyName ?? this.name : this.name;
          return options.var[0] + name + options.var[1];
        }
      };
      var Native = class extends Named {
        /**
         * @desc A named term with a known rewriting rule.
         *       'impl' is a function with signature Expr => Expr => ... => Expr
         *       (see typedef Partial).
         *       This is how S, K, I, and company are implemented.
         *
         *       Note that as of current something like a=>b=>b(a) is not possible,
         *       use full form instead: a=>b=>b.apply(a).
         *
         * @example new Native('K', x => y => x); // constant
         * @example new Native('Y', function(f) { return f.apply(this.apply(f)); }); // self-application
         *
         * @param {String} name
         * @param {Partial} impl
         * @param {{note?: string, arity?: number, canonize?: boolean, apply?: function(Expr):(Expr|null) }} [opt]
         */
        constructor(name, impl, opt = {}) {
          super(name);
          this.invoke = impl;
          const guess = opt.canonize ?? true ? this.infer() : { normal: false };
          this.arity = opt.arity || guess.arity || 1;
          this.note = opt.note ?? guess.expr?.format({ terse: true, html: true, lambda: ["", " &mapsto; ", ""] });
        }
        _rski(options) {
          if (this === native.I || this === native.K || this === native.S || options.steps >= options.max)
            return this;
          const canon = this.infer().expr;
          if (!canon)
            return this;
          options.steps++;
          return canon._rski(options);
        }
      };
      var native = {};
      function addNative(name, impl, opt) {
        native[name] = new Native(name, impl, opt);
      }
      var Lambda = class _Lambda extends Expr {
        /**
         * @desc Lambda abstraction of arg over impl.
         *     Upon evaluation, all occurrences of 'arg' within 'impl' will be replaced
         *     with the provided argument.
         *
         * Note that 'arg' will be replaced by a localized placeholder, so the original
         * variable can be used elsewhere without interference.
         * Listing symbols contained in the lambda will omit such placeholder.
         *
         * Legacy ([FreeVar], impl) constructor is supported but deprecated.
         * It will create a nested lambda expression.
         *
         * @param {FreeVar} arg
         * @param {Expr} impl
         */
        constructor(arg, impl) {
          if (Array.isArray(arg)) {
            if (arg.length === 0)
              throw new Error("empty argument list in lambda constructor");
            const [my, ...tail] = arg;
            const known = /* @__PURE__ */ new Set([my.name]);
            while (tail.length > 0) {
              const last = tail.pop();
              if (known.has(last.name))
                throw new Error("Duplicate free var name " + last + " in lambda expression");
              known.add(last.name);
              impl = new _Lambda(last, impl);
            }
            arg = my;
          }
          super();
          const local = new FreeVar(arg.name, this);
          this.arg = local;
          this.impl = impl.subst(arg, local) ?? impl;
          this.arity = 1;
        }
        weight() {
          return this.impl.weight() + 1;
        }
        _infer(options, preArgs = [], steps = 0) {
          if (preArgs.length > options.maxArgs)
            return { normal: false, steps };
          const push = nthvar(preArgs.length + options.index);
          return this.invoke(push)._infer(options, [...preArgs, push], steps + 1);
        }
        invoke(arg) {
          return this.impl.subst(this.arg, arg) ?? this.impl;
        }
        traverse(change) {
          const replaced = change(this);
          if (replaced instanceof Expr)
            return replaced;
          const impl = this.impl.traverse(change);
          if (!impl)
            return null;
          return new _Lambda(this.arg, impl);
        }
        any(predicate) {
          return predicate(this) || this.impl.any(predicate);
        }
        _fold(initial, combine) {
          const [value = initial, action = "descend"] = unwrap(combine(initial, this));
          if (action === control.prune)
            return value;
          if (action === control.stop)
            return control.stop(value);
          const [iValue, iAction] = unwrap(this.impl._fold(value, combine));
          if (iAction === control.stop)
            return control.stop(iValue);
          return iValue ?? value;
        }
        subst(search, replace) {
          if (search === this.arg)
            return null;
          const change = this.impl.subst(search, replace);
          return change ? new _Lambda(this.arg, change) : null;
        }
        _rski(options) {
          const impl = this.impl._rski(options);
          if (options.steps >= options.max)
            return new _Lambda(this.arg, impl);
          options.steps++;
          if (impl === this.arg)
            return native.I;
          if (!impl.any((e) => e === this.arg))
            return native.K.apply(impl);
          if (impl instanceof App) {
            const { fun, arg } = impl;
            if (arg === this.arg && !fun.any((e) => e === this.arg))
              return fun._rski(options);
            return native.S.apply(
              new _Lambda(this.arg, fun)._rski(options),
              new _Lambda(this.arg, arg)._rski(options)
            );
          }
          throw new Error("Don't know how to convert to SKI" + this);
        }
        diff(other, swap = false) {
          if (!(other instanceof _Lambda))
            return super.diff(other, swap);
          const t = new FreeVar("t");
          const diff = this.invoke(t).diff(other.invoke(t), swap);
          if (diff)
            return "(t->" + diff + ")";
          return null;
        }
        _format(options, nargs) {
          return (nargs > 0 ? options.brackets[0] : "") + options.lambda[0] + this.arg._format(options, 0) + options.lambda[1] + this.impl._format(options, 0) + options.lambda[2] + (nargs > 0 ? options.brackets[1] : "");
        }
        _braced(first) {
          return true;
        }
      };
      var Church = class _Church extends Native {
        /**
         * @desc Church numeral representing non-negative integer n:
         *      n f x = f(f(...(f x)...)) with f applied n times.
         * @param {number} n
         */
        constructor(n) {
          const p = Number.parseInt(n);
          if (!(p >= 0))
            throw new Error("Church number must be a non-negative integer");
          const name = "" + p;
          const impl = (x) => (y) => {
            let expr = y;
            for (let i = p; i-- > 0; )
              expr = x.apply(expr);
            return expr;
          };
          super(name, impl, { arity: 2, canonize: false, note: name });
          this.n = p;
          this.arity = 2;
        }
        diff(other, swap = false) {
          if (!(other instanceof _Church))
            return super.diff(other, swap);
          if (this.n === other.n)
            return null;
          return swap ? "[" + other.n + " != " + this.n + "]" : "[" + this.n + " != " + other.n + "]";
        }
        _unspaced(arg) {
          return false;
        }
      };
      function waitn(expr, n) {
        return (arg) => n <= 1 ? expr.apply(arg) : waitn(expr.apply(arg), n - 1);
      }
      var Alias = class extends Named {
        /**
         * @desc A named alias for an existing expression.
         *
         *     Upon evaluation, the alias expands into the original expression,
         *     unless it has a known arity > 0 and is marked terminal,
         *     in which case it waits for enough arguments before expanding.
         *
         *     A hidden mutable property 'outdated' is used to silently
         *     replace the alias with its definition in all contexts.
         *     This is used when declaring named terms in an interpreter,
         *     to avoid confusion between old and new terms with the same name.
         *
         * @param {String} name
         * @param {Expr} impl
         * @param {{canonize?: boolean, max?: number, maxArgs?: number, note?: string, terminal?: boolean}} [options]
         */
        constructor(name, impl, options = {}) {
          super(name);
          if (!(impl instanceof Expr))
            throw new Error("Attempt to create an alias for a non-expression: " + impl);
          this.impl = impl;
          if (options.note)
            this.note = options.note;
          const guess = options.canonize ? impl.infer({ max: options.max, maxArgs: options.maxArgs }) : { normal: false };
          this.arity = guess.proper && guess.arity || 0;
          this.proper = guess.proper ?? false;
          this.terminal = options.terminal ?? this.proper;
          this.canonical = guess.expr;
          this.invoke = waitn(impl, this.arity);
        }
        /**
         * @property {boolean} [outdated] - whether the alias is outdated
         *     and should be replaced with its definition when encountered.
         * @property {boolean} [terminal] - whether the alias should behave like a standalone term
         *     // TODO better name?
         * @property {boolean} [proper] - whether the alias is a proper combinator (i.e. contains no free variables or constants)
         * @property {number} [arity] - the number of arguments the alias waits for before expanding
         * @property {Expr} [canonical] - equivalent lambda term.
         */
        weight() {
          return this.terminal ? 1 : this.impl.weight();
        }
        traverse(change) {
          return change(this) ?? this.impl.traverse(change);
        }
        any(predicate) {
          return predicate(this) || this.impl.any(predicate);
        }
        _fold(initial, combine) {
          const [value = initial, action] = unwrap(combine(initial, this));
          if (action === control.prune)
            return value;
          if (action === control.stop)
            return control.stop(value);
          const [iValue, iAction] = unwrap(this.impl._fold(value, combine));
          if (iAction === control.stop)
            return control.stop(iValue);
          return iValue ?? value;
        }
        subst(search, replace) {
          if (this === search)
            return replace;
          return this.impl.subst(search, replace);
        }
        _infer(options, preArgs = [], steps = 0) {
          return this.impl._infer(options, preArgs, steps);
        }
        // DO NOT REMOVE TYPE or tsc chokes with
        //       TS2527: The inferred type of 'Alias' references an inaccessible 'this' type.
        /**
         * @return {{expr: Expr, steps: number, changed: boolean}}
         */
        step() {
          if (this.arity > 0)
            return { expr: this, steps: 0, changed: false };
          return { expr: this.impl, steps: 0, changed: true };
        }
        diff(other, swap = false) {
          if (this === other)
            return null;
          return other.diff(this.impl, !swap);
        }
        _rski(options) {
          return this.impl._rski(options);
        }
        _braced(first) {
          return this.outdated ? this.impl._braced(first) : false;
        }
        _format(options, nargs) {
          const outdated = options.inventory ? options.inventory[this.name] !== this : this.outdated;
          return outdated ? this.impl._format(options, nargs) : super._format(options, nargs);
        }
      };
      addNative("I", (x) => x);
      addNative("K", (x) => (_) => x);
      addNative("S", (x) => (y) => (z) => x.apply(z, y.apply(z)));
      addNative("B", (x) => (y) => (z) => x.apply(y.apply(z)));
      addNative("C", (x) => (y) => (z) => x.apply(z).apply(y));
      addNative("W", (x) => (y) => x.apply(y).apply(y));
      addNative(
        "+",
        (n) => n instanceof Church ? new Church(n.n + 1) : (f) => (x) => f.apply(n.apply(f, x)),
        {
          note: "Increase a Church numeral argument by 1, otherwise n => f => x => f(n f x)"
        }
      );
      function maybeLambda(args, expr, caps = {}) {
        const count = new Array(args.length).fill(0);
        let proper = true;
        expr.traverse((e) => {
          if (e instanceof FreeVar) {
            const index = args.findIndex((a) => a.name === e.name);
            if (index >= 0) {
              count[index]++;
              return;
            }
          }
          if (!(e instanceof App))
            proper = false;
        });
        const skip = /* @__PURE__ */ new Set();
        const dup = /* @__PURE__ */ new Set();
        for (let i = 0; i < args.length; i++) {
          if (count[i] === 0)
            skip.add(i);
          else if (count[i] > 1)
            dup.add(i);
        }
        return {
          expr: args.length ? new Lambda(args, expr) : expr,
          ...caps.synth ? {} : { arity: args.length },
          ...skip.size ? { skip } : {},
          ...dup.size ? { dup } : {},
          duplicate: !!dup.size || caps.duplicate || false,
          discard: !!skip.size || caps.discard || false,
          proper
        };
      }
      function nthvar(n) {
        return new FreeVar("abcdefgh"[n] ?? "x" + n);
      }
      function* simplifyLambda(expr, options = {}, state = { steps: 0 }) {
        yield { expr, steps: state.steps, comment: "(self)" };
        if (expr.freeOnly())
          return;
        let maxWeight = expr.weight();
        if (expr instanceof Lambda) {
          for (const term of simplifyLambda(expr.impl, options, state)) {
            const candidate = new Lambda(expr.arg, term.expr);
            if (candidate.weight() < maxWeight) {
              maxWeight = candidate.weight();
              yield { expr: candidate, steps: state.steps, comment: "(lambda)" + term.comment };
            }
          }
        }
        if (expr instanceof App) {
          let { fun, arg } = expr;
          for (const term of simplifyLambda(fun, options, state)) {
            const candidate = term.expr.apply(arg);
            if (candidate.weight() < maxWeight) {
              maxWeight = candidate.weight();
              fun = term.expr;
              yield { expr: candidate, steps: state.steps, comment: "(fun)" + term.comment };
            }
          }
          for (const term of simplifyLambda(arg, options, state)) {
            const candidate = fun.apply(term.expr);
            if (candidate.weight() < maxWeight) {
              maxWeight = candidate.weight();
              yield { expr: candidate, steps: state.steps, comment: "(arg)" + term.comment };
            }
          }
        }
        const canon = expr.infer({ max: options.max, maxArgs: options.maxArgs });
        state.steps += canon.steps;
        if (canon.expr && canon.expr.weight() < maxWeight)
          yield { expr: canon.expr, steps: state.steps, comment: "(canonical)" };
      }
      function toposort(list, env) {
        if (list instanceof Expr)
          list = [list];
        if (env) {
          if (!list)
            list = Object.keys(env).sort().map((k) => env[k]);
        } else {
          if (!list)
            return [];
          if (!env) {
            env = {};
            for (const item of list) {
              if (!(item instanceof Named))
                continue;
              if (env[item.name])
                throw new Error("duplicate name " + item);
              env[item.name] = item;
            }
          }
        }
        const out = [];
        const seen = /* @__PURE__ */ new Set();
        const rec = (term) => {
          if (seen.has(term))
            return;
          term.fold(null, (acc, e) => {
            if (e !== term && e instanceof Named && env[e.name] === e) {
              rec(e);
              return Expr.control.prune(null);
            }
          });
          out.push(term);
          seen.add(term);
        };
        for (const term of list)
          rec(term);
        return {
          list: out,
          env
        };
      }
      Expr.native = native;
      Expr.control = control;
      Expr.extras = { toposort };
      module.exports = { Expr, App, Named, FreeVar, Lambda, Native, Alias, Church };
    }
  });

  // src/parser.js
  var require_parser = __commonJS({
    "src/parser.js"(exports, module) {
      "use strict";
      var { Tokenizer, restrict } = require_internal();
      var classes = require_expr();
      var { Expr, Named, Native, Alias, FreeVar, Lambda, Church } = classes;
      var { native } = Expr;
      var Empty = class extends Expr {
        apply(...args) {
          return args.length ? args.shift().apply(...args) : this;
        }
        postParse() {
          throw new Error("Attempt to use empty expression () as a term");
        }
      };
      var PartialLambda = class _PartialLambda extends Empty {
        // TODO mutable! rewrite ro when have time
        constructor(term, known = {}) {
          super();
          this.impl = new Empty();
          if (term instanceof FreeVar)
            this.terms = [term];
          else if (term instanceof _PartialLambda) {
            if (!(term.impl instanceof FreeVar))
              throw new Error("Expected FreeVar->...->FreeVar->Expr");
            this.terms = [...term.terms, term.impl];
          } else
            throw new Error("Expected FreeVar or PartialLambda");
        }
        apply(term, ...tail) {
          if (term === null || tail.length !== 0)
            throw new Error("bad syntax in partial lambda expr");
          this.impl = this.impl.apply(term);
          return this;
        }
        postParse() {
          return new Lambda(this.terms, this.impl);
        }
        // uncomment if debugging with prints
        /* toString () {
          return this.terms.join('->') + '->' + (this.impl ?? '???');
        } */
      };
      function postParse(expr) {
        return expr.postParse ? expr.postParse() : expr;
      }
      var combChars = new Tokenizer(
        "[()]",
        "[A-Z]",
        "[a-z_][a-z_0-9]*",
        "\\b[0-9]+\\b",
        "->",
        "\\+"
      );
      var SKI = class _SKI {
        /**
         *
         * @param {{
         *    allow?: string,
         *    numbers?: boolean,
         *    lambdas?: boolean,
         *    terms?: { [key: string]: Expr|string} | string[],
         *    annotate?: boolean,
         * }} [options]
         */
        constructor(options = {}) {
          this.annotate = options.annotate ?? false;
          this.known = { ...native };
          this.hasNumbers = true;
          this.hasLambdas = true;
          this.allow = new Set(Object.keys(this.known));
          if (Array.isArray(options.terms))
            this.bulkAdd(options.terms);
          else if (options.terms) {
            for (const name in options.terms) {
              if (!options.terms[name].match(/^Native:/))
                this.add(name, options.terms[name]);
            }
          }
          this.hasNumbers = options.numbers ?? true;
          this.hasLambdas = options.lambdas ?? true;
          if (options.allow)
            this.restrict(options.allow);
        }
        /**
         * @desc Declare a new term
         * If the first argument is an Alias, it is added as is.
         * Otherwise, a new Alias or Native term (depending on impl type) is created.
         * If note is not provided and this.annotate is true, an automatic note is generated.
         *
         * If impl is a function, it should have signature (Expr) => ... => Expr
         * (see typedef Partial at top of expr.js)
         *
         * @example ski.add('T', 'S(K(SI))K', 'swap combinator')
         * @example ski.add( ski.parse('T = S(K(SI))K') ) // ditto but one-arg form
         * @example ski.add('T', x => y => y.apply(x), 'swap combinator') // heavy artillery
         * @example ski.add('Y', function (f) { return f.apply(this.apply(f)); }, 'Y combinator')
         *
         * @param {Alias|String} term
         * @param {String|Expr|function(Expr):Partial} [impl]
         * @param {String} [note]
         * @return {SKI} chainable
         */
        add(term, impl, note) {
          term = this._named(term, impl);
          if (this.annotate && note === void 0) {
            const guess = term.infer();
            if (guess.expr)
              note = guess.expr.format({ terse: true, html: true, lambda: ["", " &mapsto; ", ""] });
          }
          if (note !== void 0)
            term.note = note;
          if (this.known[term.name])
            this.known[term.name].outdated = true;
          this.known[term.name] = term;
          this.allow.add(term.name);
          return this;
        }
        /**
         * @desc Internal helper for add() that creates an Alias or Native term from the given arguments.
         * @param {Alias|string} term
         * @param {string|Expr|function(Expr):Partial} impl
         * @returns {Native|Alias}
         * @private
         */
        _named(term, impl) {
          if (term instanceof Alias)
            return new Alias(term.name, term.impl, { canonize: true });
          if (typeof term !== "string")
            throw new Error("add(): term must be an Alias or a string");
          if (impl === void 0)
            throw new Error("add(): impl must be provided when term is a string");
          if (typeof impl === "string")
            return new Alias(term, this.parse(impl), { canonize: true });
          if (impl instanceof Expr)
            return new Alias(term, impl, { canonize: true });
          if (typeof impl === "function")
            return new Native(term, impl);
          throw new Error("add(): impl must be an Expr, a string, or a function with a signature Expr => ... => Expr");
        }
        /**
         * @desc Declare a new term if it is not known, otherwise just allow it.
         *       Currently only used by quests.
         *       Use with caution, this function may change its signature, behavior, or even be removed in the future.
         *
         * @experimental
         * @param {string|Alias} name
         * @param {string|Expr|function(Expr):Partial} impl
         * @returns {SKI}
         */
        maybeAdd(name, impl) {
          if (this.known[name])
            this.allow.add(name);
          else
            this.add(name, impl);
          return this;
        }
        /**
         * @desc Declare and remove multiple terms at once
         *       term=impl adds term
         *       term= removes term
         * @param {string[]} list
         * @return {SKI} chainable
         */
        bulkAdd(list) {
          for (const item of list) {
            const m = item.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);
            if (!m)
              throw new Error("bulkAdd: invalid declaration: " + item);
            if (m[2] === "")
              this.remove(m[1]);
            else
              this.add(m[1], this.parse(m[2]));
          }
          return this;
        }
        /**
         * Restrict the interpreter to given terms. Terms prepended with '+' will be added
         * and terms preceeded with '-' will be removed.
         * @example ski.restrict('SK') // use the basis
         * @example ski.restrict('+I') // allow I now
         * @example ski.restrict('-SKI +BCKW' ); // switch basis
         * @example ski.restrict('-foo -bar'); // forbid some user functions
         * @param {string} spec
         * @return {SKI} chainable
         */
        restrict(spec) {
          this.allow = restrict(this.allow, spec);
          return this;
        }
        /**
         *
         * @param {string} spec
         * @return {string}
         */
        showRestrict(spec = "+") {
          const out = [];
          let prevShort = true;
          for (const term of [...restrict(this.allow, spec)].sort()) {
            const nextShort = term.match(/^[A-Z]$/);
            if (out.length && !(prevShort && nextShort))
              out.push(" ");
            out.push(term);
            prevShort = nextShort;
          }
          return out.join("");
        }
        /**
         *
         * @param {String} name
         * @return {SKI}
         */
        remove(name) {
          this.known[name].outdated = true;
          delete this.known[name];
          this.allow.delete(name);
          return this;
        }
        /**
         *
         * @return {{[key:string]: Native|Alias}}
         */
        getTerms() {
          const out = {};
          for (const name of Object.keys(this.known)) {
            if (this.allow.has(name))
              out[name] = this.known[name];
          }
          return out;
        }
        /**
         * @desc Export term declarations for use in bulkAdd().
         * Currently only Alias terms are serialized.
         * @returns {string[]}
         */
        declare() {
          const env = this.getTerms();
          for (const name in env) {
            if (!(env[name] instanceof Alias))
              delete env[name];
          }
          const needDetour = {};
          let i = 1;
          for (const name in native) {
            if (!(env[name] instanceof Alias))
              continue;
            while ("tmp" + i in env)
              i++;
            const temp = new Alias("tmp" + i, env[name]);
            needDetour[temp] = env[name];
            env[temp] = temp;
            delete env[name];
          }
          const list = Expr.extras.toposort(void 0, env).list;
          const detour = /* @__PURE__ */ new Map();
          if (Object.keys(needDetour).length) {
            const rework = (expr) => {
              return expr.traverse((e) => {
                if (!(e instanceof Alias))
                  return null;
                const newAlias = detour.get(e);
                if (newAlias)
                  return newAlias;
                return new Alias(e.name, rework(e.impl));
              }) ?? expr;
            };
            for (let i2 = 0; i2 < list.length; i2++) {
              list[i2] = rework(list[i2], detour);
              detour.set(needDetour[list[i2].name], list[i2]);
              env[list[i2].name] = list[i2];
              console.log(`list[${i2}] = ${list[i2].name}=${list[i2].impl};`);
            }
            console.log("detour:", detour);
          }
          const out = list.map(
            (e) => needDetour[e] ? e.name + "=" + needDetour[e].name + "=" + e.impl.format({ inventory: env }) : e.name + "=" + e.impl.format({ inventory: env })
          );
          for (const [name, temp] of detour)
            out.push(name + "=" + temp, temp + "=");
          return out;
        }
        /**
         * @template T
         * @param {string} source
         * @param {Object} [options]
         * @param {{[keys: string]: Expr}} [options.env]
         * @param {T} [options.scope]
         * @param {boolean} [options.numbers]
         * @param {boolean} [options.lambdas]
         * @param {string} [options.allow]
         * @return {Expr}
         */
        parse(source, options = {}) {
          if (typeof source !== "string")
            throw new Error("parse: source must be a string, got " + typeof source);
          const lines = source.replace(/\/\/[^\n]*$/gm, " ").replace(/\/\*.*?\*\//gs, " ").trim().split(/\s*;[\s;]*/).filter((s) => s.match(/\S/));
          const jar = { ...options.env };
          let expr = new Empty();
          for (const item of lines) {
            if (expr instanceof Alias)
              expr.outdated = true;
            const def = item.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=(.*)$/s);
            if (def && def[2] === "")
              expr = new FreeVar(def[1], options.scope ?? _SKI);
            else
              expr = this.parseLine(item, jar, options);
            if (def) {
              if (jar[def[1]] !== void 0)
                throw new Error("Attempt to redefine a known term: " + def[1]);
              jar[def[1]] = expr;
            }
          }
          expr.context = {
            env: { ...this.getTerms(), ...jar },
            // also contains pre-parsed terms
            scope: options.scope,
            src: source,
            parser: this
          };
          return expr;
        }
        /**
         * @desc Parse a single line of source code, without splitting it into declarations.
         *       Internal, always use parse() instead.
         * @template T
         * @param {String} source S(KI)I
         * @param {{[keys: string]: Expr}} env
         * @param {Object} [options]
         * @param {{[keys: string]: Expr}} [options.env] - unused, see 'env' argument
         * @param {T} [options.scope]
         * @param {boolean} [options.numbers]
         * @param {boolean} [options.lambdas]
         * @param {string} [options.allow]
         * @return {Expr} parsed expression
         */
        parseLine(source, env = {}, options = {}) {
          const aliased = source.match(/^\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);
          if (aliased)
            return new Alias(aliased[1], this.parseLine(aliased[2], env, options));
          const opt = {
            numbers: options.numbers ?? this.hasNumbers,
            lambdas: options.lambdas ?? this.hasLambdas,
            allow: restrict(this.allow, options.allow)
          };
          opt.numbers ? opt.allow.add("+") : opt.allow.delete("+");
          const tokens = combChars.split(source);
          const empty = new Empty();
          const stack = [empty];
          const context = options.scope || _SKI;
          for (const c of tokens) {
            if (c === "(")
              stack.push(empty);
            else if (c === ")") {
              if (stack.length < 2)
                throw new Error("unbalanced input: extra closing parenthesis" + source);
              const x = postParse(stack.pop());
              const f = stack.pop();
              stack.push(f.apply(x));
            } else if (c === "->") {
              if (!opt.lambdas)
                throw new Error("Lambdas not supported, allow them explicitly");
              stack.push(new PartialLambda(stack.pop(), env));
            } else if (c.match(/^[0-9]+$/)) {
              if (!opt.numbers)
                throw new Error("Church numbers not supported, allow them explicitly");
              const f = stack.pop();
              stack.push(f.apply(new Church(c)));
            } else {
              const f = stack.pop();
              if (!env[c] && this.known[c] && !opt.allow.has(c)) {
                throw new Error("Term '" + c + "' is not in the restricted set " + [...opt.allow].sort().join(" "));
              }
              const x = env[c] ?? this.known[c] ?? (env[c] = new FreeVar(c, context));
              stack.push(f.apply(x));
            }
          }
          if (stack.length !== 1) {
            throw new Error("unbalanced input: missing " + (stack.length - 1) + " closing parenthesis:" + source);
          }
          return postParse(stack.pop());
        }
        toJSON() {
          return {
            version: "1.1.1",
            // set to incremented package.json version whenever SKI serialization changes
            allow: this.showRestrict("+"),
            numbers: this.hasNumbers,
            lambdas: this.hasLambdas,
            annotate: this.annotate,
            terms: this.declare()
          };
        }
      };
      SKI.vars = function(scope = {}) {
        const cache = {};
        return new Proxy({}, {
          get: (target, name) => {
            if (!(name in cache))
              cache[name] = new FreeVar(name, scope);
            return cache[name];
          }
        });
      };
      SKI.church = (n) => new Church(n);
      for (const name in native)
        SKI[name] = native[name];
      SKI.classes = classes;
      SKI.native = native;
      SKI.control = Expr.control;
      module.exports = { SKI };
    }
  });

  // src/quest.js
  var require_quest = __commonJS({
    "src/quest.js"(exports, module) {
      var { SKI } = require_parser();
      var { Expr, FreeVar, Alias, Lambda } = SKI.classes;
      var Quest = class {
        /**
         * @description A combinator problem with a set of test cases for the proposed solution.
         * @param {QuestSpec} options
         * @example const quest = new Quest({
         *    input: 'identity',
         *    cases: [
         *      ['identity x', 'x'],
         *    ],
         *    allow: 'SK',
         *    intro: 'Find a combinator that behaves like the identity function.',
         * });
         * quest.check('S K K'); // { pass: true, details: [...], ... }
         * quest.check('K S');   // { pass: false, details: [...], ... }
         * quest.check('K x');   // fail! internal variable x is not equal to free variable x,
         *                       //     despite having the same name.
         * quest.check('I');     // fail! I not in the allowed list.
         */
        constructor(options) {
          const { input, cases, allow, numbers, lambdas, engine, engineFull, ...meta } = options;
          const env = options.env ?? options.vars;
          this.engine = engine ?? new SKI();
          this.engineFull = engineFull ?? new SKI();
          this.restrict = { allow, numbers: numbers ?? false, lambdas: lambdas ?? false };
          this.env = {};
          const jar = {};
          for (const term of env ?? []) {
            const expr = this.engineFull.parse(term, { env: jar, scope: this });
            if (expr instanceof SKI.classes.Alias)
              this.env[expr.name] = new Alias(expr.name, expr.impl, { terminal: true, canonize: false });
            else if (expr instanceof SKI.classes.FreeVar)
              this.env[expr.name] = expr;
            else
              throw new Error("Unsupported given variable type: " + term);
          }
          this.input = [];
          for (const term of Array.isArray(input) ? input : [input])
            this.addInput(term);
          if (!this.input.length)
            throw new Error("Quest needs at least one input placeholder");
          this.envFull = { ...this.env, ...jar };
          for (const term of this.input) {
            if (term.name in this.envFull)
              throw new Error("input placeholder name is duplicated or clashes with env: " + term.name);
            this.envFull[term.name] = term.placeholder;
          }
          this.cases = [];
          this.name = meta.name ?? meta.title;
          meta.intro = list2str(meta.intro ?? meta.descr);
          this.intro = meta.intro;
          this.id = meta.id;
          this.meta = meta;
          for (const c of cases ?? [])
            this.add(...c);
        }
        /**
         *   Display allowed terms based on what engine thinks of this.env + this.restrict.allow
         *   @return {string}
         */
        allowed() {
          const allow = this.restrict.allow ?? "";
          const env = Object.keys(this.env).sort();
          return allow ? this.engine.showRestrict(allow + "+" + env.join(" ")) : env.map((s) => "+" + s).join(" ");
        }
        addInput(term) {
          if (typeof term !== "object")
            term = { name: term };
          if (typeof term.name !== "string")
            throw new Error("quest 'input' field must be a string or a {name: string, ...} object");
          term.placeholder = new SKI.classes.FreeVar(term.name);
          this.input.push(term);
        }
        /**
         *
         * @param {{} | string} opt
         * @param {string} terms
         * @return {Quest}
         */
        add(opt, ...terms) {
          if (typeof opt === "string") {
            terms.unshift(opt);
            opt = {};
          } else
            opt = { ...opt };
          opt.engine = opt.engine ?? this.engineFull;
          opt.env = opt.env ?? this.envFull;
          const input = this.input.map((t) => t.placeholder);
          this.cases.push(
            opt.caps ? new PropertyCase(input, opt, terms) : new ExprCase(input, opt, terms)
          );
          return this;
        }
        /**
         * @description Statefully parse a list of strings into expressions or fancy aliases thereof.
         * @param {string[]} input
         * @return {{terms: Expr[], weight: number}}
         */
        prepare(...input) {
          if (input.length !== this.input.length)
            throw new Error("Solutions provided " + input.length + " terms where " + this.input.length + " are expected");
          let weight = 0;
          const prepared = [];
          const jar = { ...this.env };
          for (let i = 0; i < input.length; i++) {
            const spec = this.input[i];
            const impl = this.engine.parse(input[i], {
              env: jar,
              allow: spec.allow ?? this.restrict.allow,
              numbers: spec.numbers ?? this.restrict.numbers,
              lambdas: spec.lambdas ?? this.restrict.lambdas
            });
            const arsenal = { ...this.engine.getTerms(), ...jar };
            weight += impl.fold(0, (a, e) => {
              if (e instanceof SKI.classes.Named && arsenal[e.name] === e)
                return SKI.control.prune(a + 1);
            });
            const expr = impl instanceof FreeVar ? impl : new Alias(spec.fancy ?? spec.name, impl, { terminal: true, canonize: false });
            jar[spec.name] = expr;
            prepared.push(expr);
          }
          return {
            prepared,
            weight
          };
        }
        /**
         *
         * @param {string} input
         * @return {QuestResult}
         */
        check(...input) {
          try {
            const { prepared, weight } = this.prepare(...input);
            const details = this.cases.map((c) => c.check(...prepared));
            const pass = details.reduce((acc, val) => acc && val.pass, true);
            const steps = details.reduce((acc, val) => acc + val.steps, 0);
            return {
              expr: prepared[0],
              input: prepared,
              pass,
              steps,
              details,
              weight
            };
          } catch (e) {
            return { pass: false, details: [], exception: e, steps: 0, input };
          }
        }
        /**
           *
           * @return {TestCase[]}
           */
        show() {
          return [...this.cases];
        }
      };
      var Case = class {
        /**
         * @param {FreeVar[]} input
         * @param {{
         *   max?: number,
         *   note?: string,
         *   env?: {[key:string]: Expr},
         *   engine: SKI
         * }} options
         */
        constructor(input, options) {
          this.max = options.max ?? 1e3;
          this.note = options.note;
          this.env = { ...options.env ?? {} };
          this.input = input;
          this.engine = options.engine;
        }
        parse(src) {
          return new Subst(this.engine.parse(src, { env: this.env, scope: this }), this.input);
        }
        /**
         * @param {Expr} expr
         * @return {CaseResult}
         */
        check(...expr) {
          throw new Error("not implemented");
        }
      };
      var ExprCase = class extends Case {
        /**
         * @param {FreeVar[]} input
         * @param {{
         *    max?: number,
         *    note?: string,
         *    env?: {string: Expr},
         *    engine?: SKI
         * }} options
         * @param {[e1: string, e2: string]} terms
         */
        constructor(input, options, terms) {
          if (terms.length !== 2)
            throw new Error("Case accepts exactly 2 strings");
          super(input, options);
          [this.e1, this.e2] = terms.map((s) => this.parse(s));
        }
        check(...args) {
          const e1 = this.e1.apply(args);
          const r1 = e1.run({ max: this.max });
          const e2 = this.e2.apply(args);
          const r2 = e2.run({ max: this.max });
          let reason = null;
          if (!r1.final || !r2.final)
            reason = "failed to reach normal form in " + this.max + " steps";
          else
            reason = r1.expr.diff(r2.expr);
          return {
            pass: !reason,
            reason,
            steps: r1.steps,
            start: e1,
            found: r1.expr,
            expected: r2.expr,
            note: this.note,
            args,
            case: this
          };
        }
      };
      var knownCaps = {
        normal: true,
        proper: true,
        discard: true,
        duplicate: true,
        linear: true,
        affine: true,
        arity: true
      };
      var PropertyCase = class extends Case {
        // test that an expression uses all of its inputs exactly once
        constructor(input, options, terms) {
          super(input, options);
          if (terms.length > 1)
            throw new Error("PropertyCase accepts exactly 1 string");
          if (!options.caps || typeof options.caps !== "object" || !Object.keys(options.caps).length)
            throw new Error("PropertyCase requires a caps object with at least one capability");
          const unknown = Object.keys(options.caps).filter((c) => !knownCaps[c]);
          if (unknown.length)
            throw new Error("PropertyCase: don't know how to test these capabilities: " + unknown.join(", "));
          this.expr = this.parse(terms[0]);
          this.caps = options.caps;
          if (this.caps.linear) {
            delete this.caps.linear;
            this.caps.duplicate = false;
            this.caps.discard = false;
            this.caps.normal = true;
          }
          if (this.caps.affine) {
            delete this.caps.affine;
            this.caps.normal = true;
            this.caps.duplicate = false;
          }
        }
        check(...expr) {
          const start = this.expr.apply(expr);
          const r = start.run({ max: this.max });
          const guess = r.expr.infer({ max: this.max });
          const reason = [];
          for (const cap in this.caps) {
            if (guess[cap] !== this.caps[cap])
              reason.push("expected property " + cap + " to be " + this.caps[cap] + ", found " + guess[cap]);
          }
          return {
            pass: !reason.length,
            reason: reason ? reason.join("\n") : null,
            steps: r.steps,
            start,
            found: r.expr,
            case: this,
            note: this.note,
            args: expr
          };
        }
      };
      var Subst = class {
        /**
         * @descr A placeholder object with exactly n free variables to be substituted later.
         * @param {Expr} expr
         * @param {FreeVar[]} env
         */
        constructor(expr, env) {
          this.expr = expr;
          this.env = env;
        }
        apply(list) {
          if (list.length !== this.env.length)
            throw new Error("Subst: expected " + this.env.length + " terms, got " + list.length);
          let expr = this.expr;
          for (let i = 0; i < this.env.length; i++)
            expr = expr.subst(this.env[i], list[i]) ?? expr;
          return expr;
        }
      };
      function list2str(str) {
        if (str === void 0 || typeof str === "string")
          return str;
        return Array.isArray(str) ? str.join(" ") : "" + str;
      }
      module.exports = { Quest };
    }
  });

  // src/extras.js
  var require_extras = __commonJS({
    "src/extras.js"(exports, module) {
      "use strict";
      var { Expr, Alias, FreeVar } = require_expr();
      function search(seed, options, predicate) {
        const {
          depth = 16,
          infer = true,
          progressInterval = 1e3
        } = options;
        const hasSeen = infer && !options.noskip;
        const cache = [[]];
        let total = 0;
        let probed = 0;
        const seen = {};
        const maybeProbe = (term) => {
          total++;
          const props = infer ? term.infer({ max: options.max, maxArgs: options.maxArgs }) : null;
          if (hasSeen && props.expr) {
            if (seen[props.expr])
              return { res: -1 };
            seen[props.expr] = true;
          }
          probed++;
          const res = predicate(term, props);
          return { res, props };
        };
        for (const term of seed) {
          const { res } = maybeProbe(term);
          if (res > 0)
            return { expr: term, total, probed, gen: 1 };
          else if (res < 0)
            continue;
          cache[0].push(term);
        }
        let lastProgress;
        for (let gen = 1; gen < depth; gen++) {
          if (options.progress) {
            options.progress({ gen, total, probed, step: true });
            lastProgress = total;
          }
          for (let i = 0; i < gen; i++) {
            for (const a of cache[gen - i - 1] || []) {
              for (const b of cache[i] || []) {
                if (total >= options.tries)
                  return { total, probed, gen, ...options.retain ? { cache } : {} };
                if (options.progress && total - lastProgress >= progressInterval) {
                  options.progress({ gen, total, probed, step: false });
                  lastProgress = total;
                }
                const term = a.apply(b);
                const { res, props } = maybeProbe(term);
                if (res > 0)
                  return { expr: term, total, probed, gen, ...options.retain ? { cache } : {} };
                else if (res < 0)
                  continue;
                const offset = infer ? (props.expr ? 0 : 3) + (props.dup ? 1 : 0) + (props.proper ? 0 : 1) : 0;
                if (!cache[gen + offset])
                  cache[gen + offset] = [];
                cache[gen + offset].push(term);
              }
            }
          }
        }
        return { total, probed, gen: depth, ...options.retain ? { cache } : {} };
      }
      function deepFormat(obj, options = {}) {
        if (obj instanceof Expr)
          return obj.format(options);
        if (Array.isArray(obj))
          return obj.map(deepFormat);
        if (typeof obj !== "object" || obj === null || obj.constructor !== Object)
          return obj;
        const out = {};
        for (const key in obj)
          out[key] = deepFormat(obj[key]);
        return out;
      }
      function declare(expr, env) {
        const res = Expr.extras.toposort([expr], env);
        return res.list.map((s) => {
          if (s instanceof Alias)
            return s.name + "=" + s.impl.format({ inventory: res.env });
          if (s instanceof FreeVar)
            return s.name + "=";
          return s.format({ inventory: res.env });
        }).join("; ");
      }
      module.exports = { search, deepFormat, declare };
    }
  });

  // index.js
  var require_index = __commonJS({
    "index.js"(exports, module) {
      var { SKI } = require_parser();
      var { Quest } = require_quest();
      var extras = require_extras();
      SKI.Quest = Quest;
      SKI.extras = { ...extras, ...SKI.classes.Expr.extras };
      if (typeof process === "object" && process.env.SKI_REPL && typeof global !== "undefined") {
        global.SKI = SKI;
        console.log("SKI_REPL activated, try `new SKI();`");
      }
      if (typeof window !== "undefined")
        window.SKI = SKI;
      module.exports = { SKI, Quest };
    }
  });

  // site-src/store.js
  var require_store = __commonJS({
    "site-src/store.js"(exports, module) {
      var Store = class {
        constructor(namespace) {
          this.ns = namespace + ":";
        }
        save(key, value) {
          window.localStorage.setItem(this.ns + key, JSON.stringify(value));
        }
        load(key) {
          return JSON.parse(window.localStorage.getItem(this.ns + key));
        }
        scan() {
          const st = window.localStorage;
          const out = [];
          for (let i = 0; i < st.length; i++) {
            const key = st.key(i);
            if (key.startsWith(this.ns))
              out.push(key.substring(this.ns.length));
          }
          return out;
        }
        delete(key) {
          window.localStorage.removeItem(this.ns + key);
        }
      };
      module.exports = { Store };
    }
  });

  // site-src/html-util.js
  var require_html_util = __commonJS({
    "site-src/html-util.js"(exports, module) {
      "use strict";
      function grabView(...ids) {
        const view = {};
        for (const name of ids) {
          const hyphen = name.replace(/[A-Z]/g, (char) => "-" + char.toLowerCase());
          view[name] = document.getElementById(hyphen);
          if (!view[name])
            throw new Error(`View element not found: ${hyphen}`);
        }
        return view;
      }
      function append(parent, tagname, options = {}, decorate = null) {
        const child = document.createElement(tagname);
        if (options.class)
          child.classList.add(...options.class);
        if (options.content !== void 0)
          child.innerHTML = "" + options.content;
        if (options.hidden)
          child.hidden = true;
        if (options.color)
          child.style.color = options.color;
        if (parent)
          parent.appendChild(child);
        if (decorate)
          decorate(child);
        return child;
      }
      function traverse(node, func) {
        func(node);
        for (const child of node.childNodes)
          traverse(child, func);
      }
      function sanitize(text) {
        if (typeof text !== "string")
          text = "" + text;
        const escape = {
          "<": "&lt;",
          ">": "&gt;",
          "&": "&amp;"
        };
        return text.replace(/[<>&]/g, (c) => escape[c]);
      }
      function encode(s) {
        const parens = {
          "(": "%28",
          ")": "%29"
        };
        return encodeURIComponent(s).replace(/[()]/g, (c) => parens[c]).replace(/%20/g, "+");
      }
      function decode(s) {
        return decodeURIComponent(("" + s).replace(/\+/g, " "));
      }
      module.exports = { append, decode, encode, grabView, sanitize, traverse };
    }
  });

  // site-src/eval-box.js
  var require_eval_box = __commonJS({
    "site-src/eval-box.js"(exports, module) {
      "use strict";
      var { append } = require_html_util();
      var EvalBox = class {
        /**
         * @desc  Create a visual container that can run SKI code step by step and display the results.
         *
         * @param {{
         *      expr: string | Expr | [string, Expr],
         *      engine: SKI,
         *      generator?: function(e:Expr): IterableIterator<{final: boolean, expr: Expr, steps: number}>,
         *      max?: number,
         *      height?: number,
         *      onStop?: function,
         *      onStart?: function,
         *      onStep?: function,
         *      delay?: number,
         *      id?: number,
         *      parent?: Element,
         * }} options
         */
        constructor(options = {}) {
          this.options = options;
          this.height = options.height ?? 5;
          this.running = false;
          this.delay = options.delay ?? 0;
          this.maxSteps = options.max ?? Infinity;
          this.onStart = options.onStart ?? (() => {
          });
          this.onStop = options.onStop ?? (() => {
          });
          this.onStep = options.onStep ?? (() => {
          });
          this.engine = options.engine;
          this.format = options.format ?? { html: true };
          this.generator = options.generator ?? ((e) => e.walk());
          this.set(options.expr);
          this.view = {};
          this.view.parent = options.parent;
          this.view.scroll = options.scroll ?? options.parent;
          this.view.main = append(options.parent, "ol", { class: ["ski-eval-box"] });
        }
        /**
         * @descr   set this.src and this.expr according to arg, which may be:
         *          - string: set this.src to arg, this.expr to this.engine.parse(arg)
         *          - Expr: set this.expr to arg, this.src to arg.format()
         *          - [src: string, expr: Expr]: set both directly
         * @param {string|Expr|[src: string, expr: Expr]} arg
         * @return this
         */
        set(arg) {
          if (typeof arg === "string") {
            this.src = arg;
            this.expr = this.engine.parse(arg);
          } else if (Array.isArray(arg) && arg.length === 2) {
            this.src = arg[0];
            this.expr = arg[1];
          } else if (!arg) {
            this.expr = null;
            this.src = null;
          } else if (typeof arg === "object" && typeof arg.format === "function") {
            this.expr = arg;
            this.src = arg.format();
          } else
            throw new Error("EvalBox.set() expects a string, Expr, or [string, Expr]");
          return this;
        }
        /**
         *
         * @param {string} [src] Set new source code to run
         * @return EvalBox this
         */
        start(src) {
          if (this.running)
            this.stop();
          try {
            if (src !== void 0)
              this.set(src);
            this.seq = this.generator(this.expr);
          } catch (e) {
            console.error(e);
            return this.stop(e.message);
          }
          this.view.main.innerHTML = "";
          this.onStart();
          this.running = true;
          this.tick();
          return this;
        }
        stop(reason) {
          this.running = false;
          if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
          }
          if (reason)
            this.print(reason, { class: ["ski-eval-error"], line: "" });
          this.onStop();
        }
        /**
         * @desc resume execution after stopping, if the sequence is not finished yet
         */
        resume() {
          if (this.running || !this.seq)
            return;
          this.running = true;
          this.onStart();
          this.tick();
        }
        tick() {
          if (!this.running) return;
          const { value, done } = this.seq.next();
          if (value)
            this.print(value.expr.format(this.format), { line: value.steps });
          this.onStep(value, done || value.final);
          if (done || value.final) {
            if (this.view.last)
              this.view.last.classList.add("ski-eval-success");
            this.seq = null;
            return this.stop();
          }
          if (value.steps >= this.maxSteps)
            return this.stop("Max steps reached: " + this.maxSteps);
          this.timer = setTimeout(() => this.tick(), this.delay);
        }
        remove() {
          if (this.view.parent) {
            this.view.parent.removeChild(this.view.main);
            this.view.parent = null;
          }
        }
        clear() {
          this.stop();
          this.view.main.innerHTML = "";
        }
        setHeight(height) {
          this.height = height;
        }
        print(text, options = {}) {
          const line = append(this.view.main, "li", options);
          if (options.line !== 0 && !options.line)
            line.style["list-style"] = "none";
          else {
            this.view.main.style["padding-left"] = ("" + options.line).length + 2.5 + "ch";
            line.value = options.line;
          }
          this.view.last = line;
          if (options.raw)
            line.innerHTML = text;
          else {
            append(line, "span", {
              class: options.class ?? ["ski-eval-line"],
              color: options.color,
              content: text
            });
            while (this.view.main.children.length > this.height)
              this.view.main.removeChild(this.view.main.firstChild);
          }
          if (this.view.scroll)
            this.view.scroll.scrollTop = line.offsetTop;
          return line;
        }
      };
      module.exports = { EvalBox };
    }
  });

  // site-src/quest.js
  var require_quest2 = __commonJS({
    "site-src/quest.js"(exports, module) {
      "use strict";
      var { SKI } = require_index();
      var { Store } = require_store();
      var { EvalBox } = require_eval_box();
      var { append } = require_html_util();
      var QuestPage = class {
        /**
         * @desc  A collection of combinatory logic quests organized into chapters
         *        and attached to specific elements for display.
         *
         *        Quest progress is saved in the localStorage under a given prefix.
         *
         *        The engine is also saved and loaded from the store,
         *        so that unlocked terms persist across sessions and can be used in later quests.
         *
         * @param {{
         *   index: string, // URL to fetch quest list from
         *   baseUrl?: string, // root URL to fetch quest data from, default 'data/quests/'
         *   storePrefix?: string, // prefix for localStorage keys, required unless 'store' object itself is provided
         *   // page elements to attach to:
         *   indexBox: HTMLElement, // element to attach chapter list to
         *   contentBox: HTMLElement, // element to attach chapter content to
         *   inventoryBox: HTMLElement, // element to attach inventory to
         *   // extra stuff
         *   linkedTo?: string, // id of element to scroll into view after loading
         *   store: Store, // TODO move out into callbacks, also make async
         *   engine?: SKI, // defautl = new SKI()
         *   onLoad?: function, // callback for when quests are loaded, gets list of QuestChapter objects as argument
         *   onSolved?: function, // callback for when a quest is solved
         *   onFailed?: function, // callback for when a quest is attempted but not solved
         *   onUnlock?: function, // callback for when a quest is solved and unlocks something in the engine
         *   chapterList?: QuestChapter[], // optional write-only list for observability only
         * }} options
         */
        constructor(options) {
          this.view = {};
          this.root = options.baseUrl ?? ".";
          if (!options.store && !options.storePrefix)
            throw new Error("No storePrefix provided");
          this.store = options.store ?? new Store(options.storePrefix);
          this.engine = options.engine ?? new SKI(this.store.load("engine") ?? { annotate: true, allow: "SKI" });
          if (options.inventoryBox) {
            this.view.inventory = options.inventoryBox;
            this.showKnown();
          }
          this.view.content = options.contentBox;
          this.view.index = options.indexBox;
          this._onSolved = options.onSolved;
          this._onFailed = options.onFailed;
          this._onUnlock = options.onUnlock;
          this.chapters = [];
        }
        load(index, linkedTo, onLoad) {
          fetch(this.mkLink(index)).then((resp) => resp.json()).then((list) => {
            let chapterId = 0;
            this.chapters = [];
            const joint = [];
            for (const item of list) {
              const chapter = new QuestChapter({
                number: ++chapterId,
                link: this.mkLink(item),
                engine: this.engine,
                store: this.store,
                onUnlock: (x) => this.onUnlock(x),
                onSolved: (x) => this._onSolved(x),
                onFailed: (x) => this._onFailed(x)
              });
              this.chapters.push(chapter);
              chapter.attach(this.view.content, { placeholder: "loading chapter" + chapter.number + "..." });
              chapter.addLink(this.view.index);
              joint.push(chapter.fetch().then((chapter2) => {
                chapter2.draw();
              }));
            }
            Promise.all(joint).then(() => {
              if (linkedTo) {
                const target = document.getElementById(linkedTo);
                if (target)
                  target.scrollIntoView();
              }
              if (onLoad)
                onLoad(this);
            });
          });
        }
        mkLink(str) {
          return str.match(/^\w+:\/\//) || str.match(/^[/.]/) ? str : this.root + "/" + str;
        }
        onUnlock(term) {
          this.engine.maybeAdd(term.name, term.impl);
          if (this.store)
            this.store.save("engine", this.engine);
          this.showKnown();
          if (this._onUnlock)
            this._onUnlock(term);
        }
        showKnown() {
          if (!this.view.inventory)
            return;
          const elem = this.view.inventory;
          elem.innerHTML = "";
          const terms = this.engine.getTerms();
          for (const entry of Object.keys(terms).sort().map((x) => [x, terms[x]]))
            append(elem, "div", { content: `<dt>${entry[0]}</dt><dd>= ${showTerm(entry[1])}</dd>` });
        }
        demolish() {
          for (const key of this.store.scan()) {
            this.store.delete(key);
          }
          ;
        }
      };
      var QuestBox = class {
        /**
         * @desc Create a quest box with given spec and options
         * @param {QuestSpec} spec
         * @param {{
         *   engine?: SKI,
         *   chapter?: QuestChapter,
         *   number?: number,
         *   store?: Store,
         * }}options
         */
        constructor(spec, options) {
          const engine = options.engine ?? options.chapter?.engine;
          if (!engine)
            throw new Error("QuestBox requires an engine: SKI in either options or chapter");
          const store = options.store ?? options.chapter?.store;
          if (!store)
            throw new Error("QuestBox requires a store: Store in either options or chapter");
          this.impl = new SKI.Quest({ ...spec, engine });
          this.name = this.impl.id ? "quest-" + this.impl.id : "";
          this.chapter = options.chapter;
          if (this.chapter && options.number)
            this.number = this.chapter.number + "." + options.number;
          this.store = store;
          this.engine = engine;
          this.view = {};
          this.input = [];
        }
        load() {
          const data = this.store.load(this.name) ?? {};
          this.status = {
            solved: data.solved ?? false,
            steps: data.steps ?? 0,
            attempts: data.attempts ?? 0,
            weight: data.weight ?? 0,
            total: data.total ?? 0
          };
          if (this.status.solved)
            this.onSolved();
          return this;
        }
        save() {
          this.store.save(this.name, this.status);
          return this;
        }
        update(result) {
          if (this.status.solved)
            return;
          this.status.attempts++;
          this.status.total += result.steps;
          this.status.steps = result.steps;
          this.status.weight = result.weight;
          if (result.pass) {
            this.status.solved = true;
            this.onSolved(result);
          }
          this.save();
          this.showStatus();
        }
        onSolved(result) {
          if (this.impl.meta.unlock && result) {
            const term = new SKI.classes.Alias(this.impl.meta.unlock, result.expr.expand());
            this.chapter?.onUnlock(term);
          }
          if (this.chapter)
            this.chapter.addSolved(this.impl.id);
        }
        check() {
          if (this.view.display)
            this.view.display.innerHTML = "running...";
          const got = this.input.map((x) => x.value);
          const result = this.impl.check(...got);
          this.showResult(result);
          this.update(result);
        }
        draw(element) {
          this.view.frame = append(element, "div", { class: ["ski-quest-box"] });
          this.view.frame.id = this.name;
          const title = append(this.view.frame, "h3");
          const body = append(this.view.frame, "div");
          const expand2 = append(title, "a", { content: this.number ? "#" + this.number : "Quest" });
          expand2.href = "#" + this.name;
          expand2.onclick = () => showhide(body, true);
          append(title, "span", { content: " " + this.impl.name });
          const allowed = this.impl.allowed();
          if (allowed)
            append(title, "span", { content: " [" + allowed + "]" });
          this.view.stat = append(title, "span", { class: ["ski-quest-float-right"] });
          const descr = append(body, "div");
          append(descr, "div", { content: cat(this.impl.intro), class: ["ski-quest-note"] });
          if (this.impl.meta.hint)
            hint(descr, " Hint:...", " Hint: " + this.impl.meta.hint);
          this.view.display = append(body, "div", { class: ["ski-quest-display"], content: "....." });
          this.view.solution = append(body, "div", { class: ["ski-quest-solution"] });
          this.drawInput(this.view.solution);
          this.showStatus();
        }
        drawInput(element) {
          const spec = this.impl.input;
          const multi = spec.length !== 1;
          for (const item of spec) {
            if (multi) {
              const label = append(element, "div", { class: ["ski-quest-label"] });
              append(label, "b", { content: item.name });
              if (item.note)
                append(label, "span", { content: " // " + item.note, class: ["ski-quest-comment"] });
            }
            const input = append(element, "input");
            input.type = "text";
            input.onkeydown = (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                this.check();
              }
            };
            this.input.push(input);
            append(element, "br");
          }
          const btn = append(element, "button", { content: "solve!" });
          btn.onclick = () => this.check();
        }
        showStatus() {
          if (!this.view.stat)
            return;
          if (this.status.attempts) {
            const tries = "in " + this.status.attempts + (this.status.attempts === 1 ? " try" : " tries");
            const steps = this.status.solved ? "&check; " + this.status.steps + " steps/" + this.status.weight + " terms " : this.status.total + " total steps ";
            this.view.stat.innerHTML = steps + " " + tries;
          }
        }
        /**
         *
         * @param {QuestResult} result
         */
        showResult(result) {
          if (!this.view.display)
            return;
          this.view.display.innerHTML = "";
          const echo = append(this.view.display, "div");
          append(echo, "span", { content: "Your solution: " + expand(result.expr) + " " });
          if (result.exception)
            append(this.view.display, "div", { class: ["ski-quest-error"], content: "Execution failed: " + result.exception });
          for (const item of result.details) {
            const line = append(this.view.display, "div", { class: item.pass ? ["ski-quest-success"] : ["ski-quest-error"] });
            append(line, "span", { content: item.pass ? "&check; " : "&cross; " });
            append(line, "span", { content: `${item.start} &rarr; ${item.found} ` });
            const showSteps = append(line, "a", { content: `in ${item.steps} steps`, class: ["ski-quest-control"] });
            append(line, "span", { content: " " });
            const hideSteps = append(line, "a", { content: " (hide)", class: ["ski-quest-control"], hidden: true });
            if (!item.pass) {
              append(line, "br");
              if (item.expected !== void 0) {
                append(line, "span", { content: "&nbsp;&nbsp;expected: " + item.expected });
                append(line, "br");
              }
              if (item.reason) {
                append(line, "span", { content: "&nbsp;&nbsp;" + item.reason });
                append(line, "br");
              }
            }
            const termDiv = append(line, "div", {});
            showSteps.onclick = () => {
              termDiv.innerHTML = "";
              hideSteps.hidden = false;
              const box = new EvalBox({ parent: termDiv, engine: this.engine, height: Infinity, max: item.steps + 2, headless: true });
              box.start(item.start);
            };
            hideSteps.onclick = () => {
              termDiv.innerHTML = "";
              hideSteps.hidden = true;
            };
          }
        }
      };
      var QuestChapter = class {
        /**
         * @desc A collection of quests, typically related,
         *       with a title and intro text. Optionally numbered, too.
         * @param {{
         *   name?: string,
         *   intro?: string|string[],
         *   link: string, // URL to fetch quest list from
         *   number?: number,
         *   engine: SKI,
         *   store: Store,
         *   onUnlock?: function, // callback for when a quest is solved and unlocks something in the engine
         * }}options
         */
        constructor(options) {
          this.options = options;
          this.quests = [];
          this.solved = /* @__PURE__ */ new Set();
          this.view = {};
          this.number = options.number ?? 0;
          this.engine = options.engine;
          this.store = options.store;
          this.onUnlock = options.onUnlock ?? (() => {
          });
          this.updateMeta();
        }
        updateMeta(meta = {}) {
          this.options = { ...this.options, ...meta };
          this.id = "chapter-" + (meta.id ?? this.number);
          if (this.view.frame)
            this.view.frame.id = this.id;
          if (this.view.link)
            this.view.link.href = "#" + this.id;
          if (this.options.name && this.view.linkText)
            this.view.linkText.innerHTML = "Chapter " + this.number + ": " + this.options.name;
        }
        fetch() {
          return fetch(this.options.link).then((resp) => resp.json()).then((data) => {
            if (Array.isArray(data))
              data = { content: data };
            if (!Array.isArray(data.content))
              throw new Error("Invalid quest list in " + this.options.link);
            this.updateMeta(data);
            let k = 0;
            for (const item of data.content)
              this.quests.push(new QuestBox(item, { chapter: this, number: ++k }));
            return this;
          });
        }
        addSolved(questId) {
          if (this.solved.has(questId))
            return;
          this.solved.add(questId);
          this.showStatus();
        }
        getProgress() {
          return {
            total: this.quests.length,
            solved: this.solved.size,
            complete: this.solved.size === this.quests.length,
            percentage: Math.round(this.solved.size / this.quests.length * 100)
          };
        }
        attach(element, options) {
          this.view.frame = append(element, "div", { class: ["ski-quest-chapter"] });
          this.view.frame.id = this.id;
          if (options.placeholder)
            this.view.placeholder = append(this.view.frame, "div", { content: options.placeholder });
          return this;
        }
        draw() {
          this.visible = true;
          this.view.placeholder?.remove();
          const title = append(this.view.frame, "h2");
          const body = append(this.view.frame, "div");
          append(title, "span", { content: "Chapter " + this.number + ": " + this.options.name });
          this.view.stat = append(title, "span", { class: ["ski-quest-float-right"] });
          title.onclick = () => {
            showhide(body, this.visible = !this.visible);
          };
          this.view.intro = append(body, "div", { content: cat(this.options.intro), class: ["ski-quest-note", "ski-quest-chapter-intro"] });
          this.view.content = append(body, "div", { class: ["ski-quest-chapter-content"] });
          for (const quest of this.quests) {
            quest.load();
            quest.draw(this.view.content);
          }
          this.showStatus();
        }
        showStatus() {
          if (!this.view.stat)
            return;
          const progress = this.getProgress();
          this.view.stat.innerHTML = "Progress: " + progress.solved + "/" + progress.total + " (" + progress.percentage + "%)";
          if (progress.complete)
            this.view.stat.classList.add("success");
          if (this.view.progressbar) {
            this.view.progressbar.style.paddingRight = progress.percentage + "%";
            this.view.progressbar.style.marginRight = -progress.percentage + "%";
          }
        }
        addLink(element) {
          const link = append(element, "a");
          link.href = "#" + this.id;
          this.view.link = link;
          this.view.progressbar = append(link, "span", { class: ["ski-quest-completion"] });
          this.view.linkText = append(link, "span", { content: "Chapter " + this.number + "..." });
        }
        // TODO hide solved chapters
      };
      function hint(element, shown, hidden) {
        const container = append(element, "span", {});
        const clickme = append(container, "span", { content: shown, class: ["ski-quest-hint"] });
        clickme.onclick = () => {
          clickme.remove();
          append(container, "span", { content: hidden });
        };
      }
      function cat(input) {
        if (Array.isArray(input))
          return input.join(" ");
        else
          return "" + input;
      }
      function expand(expr) {
        return expr instanceof SKI.classes.Expr ? expr instanceof SKI.classes.Alias ? expr.name + " = " + expr.expand() : "" + expr.expand() : "" + expr;
      }
      function showhide(element, show) {
        if (show === void 0)
          show = element.hidden;
        element.hidden = !show;
      }
      function showTerm(term) {
        return term.note ?? (term.impl ?? term).format({ html: true, lambda: ["", " &mapsto; ", ""] });
      }
      module.exports = { QuestPage, QuestChapter, QuestBox };
    }
  });

  // site-src/index-quest.js
  var require_index_quest = __commonJS({
    "site-src/index-quest.js"() {
      var { QuestBox, QuestChapter, QuestPage } = require_quest2();
      if (typeof window !== "undefined") {
        window.QuestBox = QuestBox;
        window.QuestChapter = QuestChapter;
        window.QuestPage = QuestPage;
      }
    }
  });
  require_index_quest();
})();
//# sourceMappingURL=ski-quest.min.js.map
