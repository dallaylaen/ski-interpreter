{
  "version": 3,
  "sources": ["../../../src/internal.js", "../../../src/expr.js", "../../../src/parser.js", "../../../src/quest.js", "../../../src/extras.js", "../../../index.js", "../../../site-src/store.js", "../../../site-src/html-util.js", "../../../site-src/eval-box.js", "../../../site-src/quest.js", "../../../site-src/index-quest.js"],
  "sourcesContent": ["class Tokenizer {\n  /**\n   * @desc Create a tokenizer that splits strings into tokens according to the given terms.\n   * The terms are interpreted as regular expressions, and are sorted by length\n   * to ensure that longer matches are preferred over shorter ones.\n   * @param {...string|RegExp} terms\n   */\n  constructor (...terms) {\n    const src = '$|(\\\\s+)|' + terms\n      .map(s => '(?:' + s + ')')\n      .sort((a, b) => b.length - a.length)\n      .join('|');\n    this.rex = new RegExp(src, 'gys');\n  }\n\n  /**\n   * @desc Split the given string into tokens according to the terms specified in the constructor.\n   * @param {string} str\n   * @return {string[]}\n   */\n  split (str) {\n    this.rex.lastIndex = 0;\n    const list = [...str.matchAll(this.rex)];\n\n    // did we parse everything?\n    const eol = list.pop();\n    const last = eol?.index ?? 0;\n\n    if (last !== str.length) {\n      throw new Error('Unknown tokens at pos ' + last + '/' + str.length\n                + ' starting with ' + str.substring(last));\n    }\n\n    // skip whitespace\n    return list.filter(x => x[1] === undefined).map(x => x[0]);\n  }\n}\n\nconst tokRestrict = new Tokenizer('[-=+]', '[A-Z]', '\\\\b[a-z_][a-z_0-9]*\\\\b');\n\n/**\n * @desc Add ot remove tokens from a set according to a spec string.\n * The spec string is a sequence of tokens, with each group optionally prefixed\n * by one of the operators '=', '+', or '-'.\n * The '=' operator resets the set to contain only the following token(s).\n * @param {Set<string>} set\n * @param {string} [spec]\n * @returns {Set<string>}\n */\nfunction restrict (set, spec) {\n  if (!spec)\n    return set;\n  let out = new Set([...set]);\n  const act = {\n    '=': sym => { out = new Set([sym]); mode = '+'; },\n    '+': sym => { out.add(sym); },\n    '-': sym => { out.delete(sym); },\n  };\n\n  let mode = '=';\n  for (const sym of tokRestrict.split(spec)) {\n    if (act[sym])\n      mode = sym;\n    else\n      act[mode](sym);\n  }\n  return out;\n}\n\nclass TraverseControl {\n  /**\n   * @desc A wrapper for values returned by fold/traverse callbacks\n   *       which instructs the traversal to alter its behavior while\n   *       retaining the value in question.\n   *\n   *       This class is instantiated internally be `SKI.control.*` functions,\n   *       and is not intended to be used directly by client code.\n   *\n   * @template T\n   * @param {T} value\n   * @param {function(T): TraverseControl<T>} decoration\n   */\n  constructor (value, decoration) {\n    this.value = value;\n    this.decoration = decoration;\n  }\n}\n\n/**\n * @private\n * @template T\n * @param {T|TraverseControl<T>|null} value\n * @returns {[T?, function|undefined]}\n */\nfunction unwrap (value) {\n  // `?? undefined` so that null is not 'an object'\n  if (value instanceof TraverseControl)\n    return [value.value ?? undefined, value.decoration];\n  return [value ?? undefined, undefined];\n}\n\n/**\n * @desc Prepare a self-referencing wrapper function for use as a fold/traverse control decorator.\n *\n *       If `fun` is created by `prepareWrapper`, then\n *       unwrap(fun(x)) will always return exactly [x, fun], and the second value can be checked with ===.\n *\n *       An optional label can be provided for debugging purposes.\n *\n * @private\n * @template T\n * @param {string} [label]\n * @returns {function(T): TraverseControl<T>}\n */\nfunction prepareWrapper (label) {\n  const fun = value => new TraverseControl(value, fun);\n  fun.label = label;\n  fun.toString = () => 'TraverseControl::' + label;\n  return fun;\n}\n\nmodule.exports = { Tokenizer, restrict, unwrap, prepareWrapper };\n", "'use strict';\n\nconst { unwrap, prepareWrapper } = require('./internal');\n\nconst DEFAULTS = {\n  max:     1000,\n  maxArgs: 32,\n};\n\n/**\n * @template T\n * @typedef {T | TraverseControl<T> | null} TraverseValue\n */\n/**\n * @desc Control primitives for fold() and traverse() methods.\n * @template T\n * @type {{[name: string]: function(T): TraverseControl<T>}}\n */\nconst control = {\n  descend: prepareWrapper('descend'),\n  prune:   prepareWrapper('prune'),\n  redo:    prepareWrapper('redo'),\n  stop:    prepareWrapper('stop'),\n};\n\n/**\n * @typedef {Expr | function(Expr): Partial} Partial\n */\n\nclass Expr {\n  /**\n   *  @descr A combinatory logic expression.\n   *\n   *  Applications, variables, and other terms like combinators per se\n   *  are subclasses of this class.\n   *\n   *  @abstract\n   *  @property {{\n   *    scope?: any,\n   *    env?: { [key: string]: Expr },\n   *    src?: string,\n   *    parser: object,\n   *  }} [context]\n   * @property {number} [arity] - number of arguments the term is waiting for (if known)\n   */\n\n  /**\n   * @desc apply self to zero or more terms and return the resulting term,\n   * without performing any calculations whatsoever\n   * @param {Expr} args\n   * @return {Expr}\n   */\n  apply (...args) {\n    let expr = this;\n    for (const arg of args)\n      expr = new App(expr, arg);\n    return expr;\n  }\n\n  /**\n   * @desc Replace all aliases in the expression with their definitions, recursively.\n   * @return {Expr}\n   */\n  expand () {\n    return this.traverse(e => {\n      if (e instanceof Alias)\n        return e.impl.expand();\n    }) ?? this;\n  }\n\n  /**\n   * @desc Returns true if the expression contains only free variables and applications, false otherwise.\n   * @returns {boolean}\n   */\n  freeOnly () {\n    return !this.any(e => !(e instanceof FreeVar || e instanceof App));\n  }\n\n  /**\n   * @desc Traverse the expression tree, applying change() to each node.\n   *       If change() returns an Expr, the node is replaced with that value.\n   *       A null/undefined value is interpreted as\n   *       \"descend further if applicable, or leave the node unchanged\".\n   *\n   *       Returned values may be decorated:\n   *\n   *       SKI.control.prune will suppress further descending even if nothing was returned\n   *       SKI.control.stop will terminate further changes.\n   *       SKI.control.redo will apply the callback to the returned subtree, recursively.\n   *\n   *       Note that if redo was applied at least once to a subtree, a null return from the same subtree\n   *       will be replaced by the last non-null value returned.\n   *\n   *       The traversal order is leftmost-outermost (LO), i.e. the same order as reduction steps are taken.\n   *\n   *       Returns null if no changes were made, or the new expression otherwise.\n   *\n   * @param {(e:Expr) => TraverseValue<Expr>} change\n   * @returns {Expr|null}\n   */\n  traverse (change) {\n    const [expr, _] = unwrap(this._traverse_redo(change));\n    return expr;\n  }\n\n  /**\n   * @private\n   * @param {(e:Expr) => TraverseValue<Expr>} change\n   * @returns {TraverseValue<Expr>}\n   */\n  _traverse_redo (change) {\n    let action;\n    let expr = this;\n    let prev;\n    do {\n      prev = expr;\n      [expr, action] = unwrap(expr._traverse(change));\n    } while (expr && action === control.redo);\n    if (!expr && prev !== this)\n      expr = prev; // we were in redo at least once\n    return action ? action(expr) : expr;\n  }\n\n  /**\n   * @private\n   * @param {(e:Expr) => TraverseValue<Expr>} change\n   * @returns {TraverseValue<Expr>}\n   */\n  _traverse (change) {\n    return change(this);\n  }\n\n  /**\n   * @desc Returns true if predicate() is true for any subterm of the expression, false otherwise.\n   *\n   * @param {(e: Expr) => boolean} predicate\n   * @returns {boolean}\n   */\n  any (predicate) {\n    return predicate(this);\n  }\n\n  /**\n   * @desc Fold the expression into a single value by recursively applying combine() to its subterms.\n   *       Nodes are traversed in leftmost-outermost order, i.e. the same order as reduction steps are taken.\n   *\n   * null or undefined return value from combine() means \"keep current value and descend further\".\n   *\n   * SKI.control provides primitives to control the folding flow:\n   *  - SKI.control.prune(value) means \"use value and don't descend further into this branch\";\n   *  - SKI.control.stop(value) means \"stop folding immediately and return value\".\n   *  - SKI.control.descend(value) is the default behavior, meaning \"use value and descend further\".\n   *\n   * This method is experimental and may change in the future.\n   *\n   * @experimental\n   * @template T\n   * @param {T} initial\n   * @param {(acc: T, expr: Expr) => TraverseValue<T>} combine\n   * @returns {T}\n   */\n  fold (initial, combine) {\n    const [value, _] = unwrap(this._fold(initial, combine));\n    return value ?? initial;\n  }\n\n  /**\n   * @template T\n   * @param {T} initial\n   * @param {(acc: T, expr: Expr) => TraverseValue<T>} combine\n   * @returns {TraverseValue<T>}\n   * @private\n   */\n  _fold (initial, combine) {\n    return combine(initial, this);\n  }\n\n  /**\n   * @desc rough estimate of the term's complexity\n   * @return {number}\n   */\n  weight () {\n    // TODO remove in next breaking release\n    return 1;\n  }\n\n  /**\n   * @desc Try to empirically find an equivalent lambda term for the expression,\n   *       returning also the term's arity and some other properties.\n   *\n   *       This is used internally when declaring a Native / Alias term,\n   *       unless {canonize: false} is used.\n   *\n   *       As of current it only recognizes terms that have a normal form,\n   *       perhaps after adding some variables. This may change in the future.\n   *\n   *       Use toLambda() if you want to get a lambda term in any case.\n   *\n   * @param {{max?: number, maxArgs?: number}} options\n   * @return {{\n   *    normal: boolean,\n   *    steps: number,\n   *    expr?: Expr,\n   *    arity?: number,\n   *    proper?: boolean,\n   *    discard?: boolean,\n   *    duplicate?: boolean,\n   *    skip?: Set<number>,\n   *    dup?: Set<number>,\n   * }}\n   */\n  infer (options = {}) {\n    const max = options.max ?? DEFAULTS.max;\n    const maxArgs = options.maxArgs ?? DEFAULTS.maxArgs;\n    const out = this._infer({ max, maxArgs, index: 0 });\n    return out;\n  }\n\n  /**\n   *\n   * @param {{max: number, maxArgs: number, index: number}} options\n   * @param {FreeVar[]} preArgs\n   * @param {number} steps\n   * @returns {{\n   *    normal: boolean,\n   *    steps: number,\n   *    expr?: Expr,\n   *    arity?: number,\n   *    skip?: Set<number>,\n   *    dup?: Set<number>,\n   *    duplicate, discard, proper: boolean\n   * }\n   * @private\n   */\n  _infer (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs || steps > options.max)\n      return { normal: false, steps };\n\n    // happy case\n    if (this.freeOnly()) {\n      return {\n        normal: true,\n        steps,\n        ...maybeLambda(preArgs, this),\n      };\n    }\n\n    // try reaching the normal form\n    const next = this.run({ max: (options.max - steps) / 3 });\n    steps += next.steps;\n    if (!next.final)\n      return { normal: false, steps };\n\n    // normal form != this, redo exercise\n    if (next.steps !== 0)\n      return next.expr._infer(options, preArgs, steps);\n\n    // adding more args won't help, bail out\n    // if we're an App, the App's _infer will take care of further args\n    if (this.unroll()[0] instanceof FreeVar)\n      return { normal: false, steps };\n\n    // try adding more arguments, maybe we'll get a normal form then\n    const push = nthvar(preArgs.length + options.index);\n    return this.apply(push)._infer(options, [...preArgs, push], steps);\n  }\n\n  /**\n   * @desc Expand an expression into a list of terms\n   * that give the initial expression when applied from left to right:\n   * ((a, b), (c, d)) => [a, b, (c, d)]\n   *\n   * This can be thought of as an opposite of apply:\n   * fun.apply(...arg).unroll() is exactly [fun, ...args]\n   * (even if ...arg is in fact empty).\n   *\n   * @returns {Expr[]}\n   */\n  unroll () {\n    // currently only used by infer() but may be useful\n    // to convert binary App trees to n-ary or smth\n    return [this];\n  }\n\n  /**\n   * @desc Returns a series of lambda terms equivalent to the given expression,\n   *       up to the provided computation steps limit,\n   *       in decreasing weight order.\n   *\n   *       Unlike infer(), this method will always return something,\n   *       even if the expression has no normal form.\n   *\n   *       See also Expr.walk() and Expr.toSKI().\n   *\n   * @param {{\n   *   max?: number,\n   *   maxArgs?: number,\n   *   varGen?: function(void): FreeVar,\n   *   steps?: number,\n   *   html?: boolean,\n   *   latin?: number,\n   * }} options\n   * @param {number} [maxWeight] - maximum allowed weight of terms in the sequence\n   * @return {IterableIterator<{expr: Expr, steps?: number, comment?: string}>}\n   */\n  * toLambda (options = {}) {\n    const expr = this.traverse(e => {\n      if (e instanceof FreeVar || e instanceof App || e instanceof Lambda || e instanceof Alias)\n        return null; // no change\n      const guess = e.infer({ max: options.max, maxArgs: options.maxArgs });\n      if (!guess.normal)\n        throw new Error('Failed to infer an equivalent  lambda term for ' + e);\n      return guess.expr;\n    }) ?? this;\n    yield * simplifyLambda(expr, options);\n  }\n\n  /**\n   * @desc Rewrite the expression into S, K, and I combinators step by step.\n   *     Returns an iterator yielding the intermediate expressions,\n   *     along with the number of steps taken to reach them.\n   *\n   *     See also Expr.walk() and Expr.toLambda().\n   *\n   * @param {{max?: number}} [options]\n   * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}\n   */\n  * toSKI (options = {}) {\n    // TODO options.max is not actually max, it's the number of steps in one iteration\n    let steps = 0;\n    let expr = this;\n    while (true) {\n      const opt = { max: options.max ?? 1, steps: 0 };\n      const next = expr._rski(opt);\n      const final = opt.steps === 0;\n      yield { expr, steps, final };\n      if (final)\n        break;\n      expr = next;\n      steps += opt.steps;\n    }\n  }\n\n  /**\n   * @desc Internal method for toSKI, which performs one step of the conversion.\n   * @param {{max: number, steps: number}} options\n   * @returns {Expr}\n   * @private\n   */\n  _rski (options) {\n    return this;\n  }\n\n  /**\n   * Replace all instances of plug in the expression with value and return the resulting expression,\n   * or null if no changes could be made.\n   * Lambda terms and applications will never match if used as plug\n   * as they are impossible co compare without extensive computations.\n   * Typically used on variables but can also be applied to other terms, e.g. aliases.\n   * See also Expr.traverse().\n   * @param {Expr} search\n   * @param {Expr} replace\n   * @return {Expr|null}\n   */\n  subst (search, replace) {\n    return this === search ? replace : null;\n  }\n\n  /**\n   * @desc Apply term reduction rules, if any, to the given argument.\n   * A returned value of null means no reduction is possible.\n   * A returned value of Expr means the reduction is complete and the application\n   *     of this and arg can be replaced with the result.\n   * A returned value of a function means that further arguments are needed,\n   *     and can be cached for when they arrive.\n   *\n   * This method is between apply() which merely glues terms together,\n   *     and step() which reduces the whole expression.\n   *\n   * foo.invoke(bar) is what happens inside foo.apply(bar).step() before\n   *     reduction of either foo or bar is attempted.\n   *\n   * The name 'invoke' was chosen to avoid confusion with either 'apply' or 'reduce'.\n   *\n   * @param {Expr} arg\n   * @returns {Partial | null}\n   */\n  invoke (arg) {\n    return null;\n  }\n\n  /**\n   * @desc iterate one step of a calculation.\n   * @return {{expr: Expr, steps: number, changed: boolean}}\n   */\n  step () { return { expr: this, steps: 0, changed: false } }\n\n  /**\n   * @desc Run uninterrupted sequence of step() applications\n   *       until the expression is irreducible, or max number of steps is reached.\n   *       Default number of steps = 1000.\n   * @param {{max?: number, steps?: number, throw?: boolean}|Expr} [opt]\n   * @param {Expr} args\n   * @return {{expr: Expr, steps: number, final: boolean}}\n   */\n  run (opt = {}, ...args) {\n    if (opt instanceof Expr) {\n      args.unshift(opt);\n      opt = {};\n    }\n    let expr = args ? this.apply(...args) : this;\n    let steps = opt.steps ?? 0;\n    // make sure we make at least 1 step, to tell whether we've reached the normal form\n    const max = Math.max(opt.max ?? DEFAULTS.max, 1) + steps;\n    let final = false;\n    for (; steps < max; ) {\n      const next = expr.step();\n      if (!next.changed) {\n        final = true;\n        break;\n      }\n      steps += next.steps;\n      expr = next.expr;\n    }\n    if (opt.throw && !final)\n      throw new Error('Failed to compute expression in ' + max + ' steps');\n    return { final, steps, expr };\n  }\n\n  /**\n   * Execute step() while possible, yielding a brief description of events after each step.\n   * Mnemonics: like run() but slower.\n   * @param {{max?: number}} options\n   * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}\n   */\n  * walk (options = {}) {\n    const max = options.max ?? Infinity;\n    let steps = 0;\n    let expr = this;\n    let final = false;\n\n    while (steps < max) {\n      // 1. calculate\n      // 2. yield _unchanged_ expression\n      // 3. either advance or stop\n      const next = expr.step();\n      if (!next.changed)\n        final = true;\n      yield { expr, steps, final };\n      if (final)\n        break;\n      steps += next.steps;\n      expr = next.expr;\n    }\n  }\n\n  /**\n   * @desc True is the expressions are identical, false otherwise.\n   *       Aliases are expanded.\n   *       Bound variables in lambda terms are renamed consistently.\n   *       However, no reductions are attempted.\n   *\n   *       E.g. a->b->a == x->y->x is true, but a->b->a == K is false.\n   *\n   * @param {Expr} other\n   * @return {boolean}\n   */\n  equals (other) {\n    return !this.diff(other);\n  }\n\n  /**\n   * @desc Recursively compare two expressions and return a string\n   *       describing the first point of difference.\n   *       Returns null if expressions are identical.\n   *\n   *       Aliases are expanded.\n   *       Bound variables in lambda terms are renamed consistently.\n   *       However, no reductions are attempted.\n   *\n   *       Members of the FreeVar class are considered different\n   *       even if they have the same name, unless they are the same object.\n   *       To somewhat alleviate confusion, the output will include\n   *       the internal id of the variable in square brackets.\n   *\n   * @example  \"K(S != I)\" is the result of comparing \"KS\" and \"KI\"\n   * @example  \"S(K([x[13] != x[14]]))K\"\n   *\n   * @param {Expr} other\n   * @param {boolean} [swap]  If true, the order of expressions is reversed in the output.\n   * @returns {string|null}\n   */\n  diff (other, swap = false) {\n    if (this === other)\n      return null;\n    if (other instanceof Alias)\n      return other.impl.diff(this, !swap);\n    return swap\n      ? '[' + other + ' != ' + this  + ']'\n      : '[' + this  + ' != ' + other + ']';\n  }\n\n  /**\n   * @desc Assert expression equality. Can be used in tests.\n   * @param {Expr} expected\n   * @param {string} comment\n   */\n  expect (expected, comment = '') {\n    comment = comment ? comment + ': ' : '';\n    if (!(expected instanceof Expr))\n      throw new Error(comment + 'attempt to expect a combinator to equal something else: ' + expected);\n    const diff = this.diff(expected);\n    if (!diff)\n      return; // all good\n\n    // TODO wanna use AssertionError but webpack doesn't recognize it\n    // still the below hack works for mocha-based tests.\n    const poorMans = new Error(comment + diff);\n    poorMans.expected = expected + '';\n    poorMans.actual = this + '';\n    throw poorMans;\n  }\n\n  /**\n   * @desc Returns string representation of the expression.\n   *       Same as format() without options.\n   * @return {string}\n   */\n  toString () {\n    return this.format();\n  }\n\n  /**\n   * @desc Whether the expression needs parentheses when printed.\n   * @param {boolean} [first] - whether this is the first term in a sequence\n   * @return {boolean}\n   */\n  _braced (first) {\n    return false;\n  }\n\n  /**\n   * @desc Whether the expression can be printed without a space when followed by arg.\n   * @param {Expr} arg\n   * @returns {boolean}\n   * @private\n   */\n  _unspaced (arg) {\n    return this._braced(true);\n  }\n\n  /**\n   * @desc    Stringify the expression with fancy formatting options.\n   *          Said options mostly include wrappers around various constructs in form of ['(', ')'],\n   *          as well as terse and html flags that set up the defaults.\n   *          Format without options is equivalent to toString() and can be parsed back.\n   *\n   * @param   {Object} [options]  - formatting options\n   * @param   {boolean} [options.terse]   - whether to use terse formatting (omitting unnecessary spaces and parentheses)\n   * @param   {boolean} [options.html]    - whether to default to HTML tags & entities.\n   *                                If a named term has fancyName property set, it will be used instead of name in this mode.\n   * @param   {[string, string]} [options.brackets]  - wrappers for application arguments, typically ['(', ')']\n   * @param   {[string, string]} [options.var]       - wrappers for variable names\n   *                                (will default to &lt;var&gt; and &lt;/var&gt; in html mode).\n   * @param   {[string, string, string]} [options.lambda]    - wrappers for lambda abstractions, e.g. ['&lambda;', '.', '']\n   *                                where the middle string is placed between argument and body\n   *                                default is ['', '->', ''] or ['', '-&gt;', ''] for html\n   * @param   {[string, string]} [options.around]    - wrappers around (sub-)expressions.\n   *                                individual applications will not be wrapped, i.e. (a b c) but not ((a b) c)\n   * @param   {[string, string]} [options.redex]     - wrappers around the starting term(s) that have enough arguments to be reduced\n   * @param   {Object<string, Expr>} [options.inventory]     - if given, output aliases in the set as their names\n   *                                and any other aliases as the expansion of their definitions.\n   *                                The default is a cryptic and fragile mechanism dependent on a hidden mutable property.\n   * @returns {string}\n   *\n   * @example foo.format() // equivalent to foo.toString()\n   * @example foo.format({terse: false}) // spell out all parentheses\n   * @example foo.format({html: true}) // use HTML tags and entities\n   * @example foo.format({ around: ['(', ')'], brackets: ['', ''], lambda: ['(', '->', ')'] }) // lisp style, still back-parsable\n   * @exapmle foo.format({ lambda: ['&lambda;', '.', ''] }) // pretty-print for the math department\n   * @example foo.format({ lambda: ['', '=>', ''], terse: false }) // make it javascript\n   * @example foo.format({ inventory: { T } }) // use T as a named term, expand all others\n   *\n   */\n  format (options = {}) {\n    const fallback = options.html\n      ? {\n        brackets: ['(', ')'],\n        space:    ' ',\n        var:      ['<var>', '</var>'],\n        lambda:   ['', '-&gt;', ''],\n        around:   ['', ''],\n        redex:    ['', ''],\n      }\n      : {\n        brackets: ['(', ')'],\n        space:    ' ',\n        var:      ['', ''],\n        lambda:   ['', '->', ''],\n        around:   ['', ''],\n        redex:    ['', ''],\n      }\n    return this._format({\n      terse:     options.terse    ?? true,\n      brackets:  options.brackets ?? fallback.brackets,\n      space:     options.space    ?? fallback.space,\n      var:       options.var      ?? fallback.var,\n      lambda:    options.lambda   ?? fallback.lambda,\n      around:    options.around   ?? fallback.around,\n      redex:     options.redex    ?? fallback.redex,\n      inventory: options.inventory, // TODO better name\n      html:      options.html     ?? false,\n    }, 0);\n  }\n\n  /**\n   * @desc Internal method for format(), which performs the actual formatting.\n   * @param {Object} options\n   * @param {number} nargs\n   * @returns {string}\n   * @private\n   */\n  _format (options, nargs) {\n    throw new Error( 'No _format() method defined in class ' + this.constructor.name );\n  }\n\n  /**\n   * @desc Returns a string representation of the expression tree, with indentation to show structure.\n   *\n   *       Applications are flattened to avoid excessive nesting.\n   *       Variables include ids to distinguish different instances of the same variable name.\n   *\n   *       May be useful for debugging.\n   *\n   * @returns {string}\n   *\n   * @example\n   * > console.log(ski.parse('C 5 x (x->x x)').diag())\n   * App:\n   *   Native: C\n   *   Church: 5\n   *   FreeVar: x[53]\n   *   Lambda (x[54]):\n   *     App:\n   *       FreeVar: x[54]\n   *       FreeVar: x[54]\n   */\n  diag () {\n    const rec = (e, indent) => {\n      if (e instanceof App)\n        return [indent + 'App:', ...e.unroll().flatMap(s => rec(s, indent + '  '))];\n      if (e instanceof Lambda)\n        return [`${indent}Lambda (${e.arg}[${e.arg.id}]):`, ...rec(e.impl, indent + '  ')];\n      if (e instanceof Alias)\n        return [`${indent}Alias (${e.name}):`, ...rec(e.impl, indent + '  ')];\n      if (e instanceof FreeVar)\n        return [`${indent}FreeVar: ${e.name}[${e.id}]`];\n      return [`${indent}${e.constructor.name}: ${e}`];\n    }\n\n    const out = rec(this, '');\n    return out.join('\\n');\n  }\n\n  /**\n   * @desc Convert the expression to a JSON-serializable format.\n   * @returns {string}\n   */\n  toJSON () {\n    return this.format();\n  }\n}\n\nclass App extends Expr {\n  /**\n   * @desc Application of fun() to args.\n   * Never ever use new App(fun, arg) directly, use fun.apply(...args) instead.\n   * @param {Expr} fun\n   * @param {Expr} arg\n   */\n  constructor (fun, arg) {\n    super();\n\n    this.arg = arg;\n    this.fun = fun;\n  }\n  /** @property {boolean} [final] */\n\n  weight () {\n    return this.fun.weight() + this.arg.weight();\n  }\n\n  _infer (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs || steps > options.max)\n      return { normal: false, steps };\n\n    /*\n     * inside and App there are 3 main possibilities:\n     * 1) The parent infer() actually is able to do the job. Then we just proxy the result.\n     * 2) Both `fun` and `arg` form good enough lambda terms. Then lump them together & return.\n     * 3) We literally have no idea, so we just pick the shortest defined term from the above.\n     */\n\n    const proxy = super._infer(options, preArgs, steps);\n    if (proxy.normal)\n      return proxy;\n    steps = proxy.steps; // reimport extra iterations\n\n    const [first, ...list] = this.unroll();\n    if (!(first instanceof FreeVar))\n      return { normal: false, steps }\n    // TODO maybe do it later\n\n    let discard = false;\n    let duplicate = false;\n    const out = [];\n    for (const term of list) {\n      const guess = term._infer({\n        ...options,\n        maxArgs: options.maxArgs - preArgs.length,\n        max:     options.max - steps,\n        index:   preArgs.length + options.index,\n      });\n      steps += guess.steps;\n      if (!guess.normal)\n        return { normal: false, steps };\n      out.push(guess.expr);\n      discard = discard || guess.discard;\n      duplicate = duplicate || guess.duplicate;\n    }\n\n    return {\n      normal: true,\n      steps,\n      ...maybeLambda(preArgs, first.apply(...out), {\n        discard,\n        duplicate,\n      }),\n    };\n  }\n\n  _traverse (change) {\n    const [expr, action] = unwrap(change(this));\n    if (action === control.stop)\n      return control.stop(expr);\n    if (expr || action === control.prune)\n      return expr;\n\n    const [fun, fAction] = unwrap(this.fun._traverse_redo(change));\n    if (fAction === control.stop)\n      return control.stop(fun ? fun.apply(this.arg) : null);\n\n    const [arg, aAction] = unwrap(this.arg._traverse_redo(change));\n\n    const final = (fun || arg) ? (fun ?? this.fun).apply(arg ?? this.arg) : null;\n    if (aAction === control.stop)\n      return control.stop(final);\n\n    return final;\n  }\n\n  any (predicate) {\n    return predicate(this) || this.fun.any(predicate) || this.arg.any(predicate);\n  }\n\n  _fold (initial, combine) {\n    const [value = initial, action = 'descend'] = unwrap(combine(initial, this));\n    if (action === control.prune)\n      return value;\n    if (action === control.stop)\n      return control.stop(value);\n    const [fValue = value, fAction = 'descend'] = unwrap(this.fun._fold(value, combine));\n    if (fAction === control.stop)\n      return control.stop(fValue);\n    const [aValue = fValue, aAction = 'descend'] = unwrap(this.arg._fold(fValue, combine));\n    if (aAction === control.stop)\n      return control.stop(aValue);\n    return aValue;\n  }\n\n  subst (search, replace) {\n    const fun = this.fun.subst(search, replace);\n    const arg = this.arg.subst(search, replace);\n\n    return (fun || arg) ? (fun ?? this.fun).apply(arg ?? this.arg) : null;\n  }\n\n  /**\n   * @return {{expr: Expr, steps: number}}\n   */\n\n  step () {\n    // normal reduction order: first try root, then at most 1 step\n    if (!this.final) {\n      // try to apply rewriting rules, if applicable, at first\n      const partial = this.fun.invoke(this.arg);\n      if (partial instanceof Expr)\n        return { expr: partial, steps: 1, changed: true };\n      else if (typeof partial === 'function')\n        this.invoke = partial; // cache for next time\n\n      // descend into the leftmost term\n      const fun = this.fun.step();\n      if (fun.changed)\n        return { expr: fun.expr.apply(this.arg), steps: fun.steps, changed: true };\n\n      // descend into arg\n      const arg = this.arg.step();\n      if (arg.changed)\n        return { expr: this.fun.apply(arg.expr), steps: arg.steps, changed: true };\n\n      // mark as irreducible\n      this.final = true; // mark as irreducible at root\n    }\n\n    return { expr: this, steps: 0, changed: false };\n  }\n\n  invoke (arg) {\n    // propagate invocation towards the root term,\n    // caching partial applications as we go\n    const partial = this.fun.invoke(this.arg);\n    if (partial instanceof Expr)\n      return partial.apply(arg);\n    else if (typeof partial === 'function') {\n      this.invoke = partial;\n      return partial(arg);\n    } else {\n      // invoke = null => we're uncomputable, cache for next time\n      this.invoke = _ => null;\n      return null;\n    }\n  }\n\n  unroll () {\n    return [...this.fun.unroll(), this.arg];\n  }\n\n  _rski (options) {\n    if (options.steps >= options.max)\n      return this;\n    return this.fun._rski(options).apply(this.arg._rski(options));\n  }\n\n  diff (other, swap = false) {\n    if (!(other instanceof App))\n      return super.diff(other, swap);\n\n    const fun = this.fun.diff(other.fun, swap);\n    if (fun)\n      return fun + '(...)';\n    const arg = this.arg.diff(other.arg, swap);\n    if (arg)\n      return this.fun + '(' + arg + ')';\n    return null;\n  }\n\n  _braced (first) {\n    return !first;\n  }\n\n  _format (options, nargs) {\n    const fun = this.fun._format(options, nargs + 1);\n    const arg = this.arg._format(options, 0);\n    const wrap = nargs ? ['', ''] : options.around;\n    // TODO ignore terse for now\n    if (options.terse && !this.arg._braced(false))\n      return wrap[0] + fun + (this.fun._unspaced(this.arg) ? '' : options.space) + arg + wrap[1];\n    else\n      return wrap[0] + fun + options.brackets[0] + arg + options.brackets[1] + wrap[1];\n  }\n\n  _unspaced (arg) {\n    return this.arg._braced(false) ? true : this.arg._unspaced(arg);\n  }\n}\n\nclass Named extends Expr {\n  /**\n   * @desc An abstract class representing a term named 'name'.\n   *\n   * @param {String} name\n   */\n  constructor (name) {\n    super();\n    if (typeof name !== 'string' || name.length === 0)\n      throw new Error('Attempt to create a named term with improper name');\n    this.name = name;\n  }\n\n  _unspaced (arg) {\n    return !!(\n      (arg instanceof Named) && (\n        (this.name.match(/^[A-Z+]$/) && arg.name.match(/^[a-z+]/i))\n          || (this.name.match(/^[a-z+]/i) && arg.name.match(/^[A-Z+]$/))\n      )\n    );\n  }\n\n  _format (options, nargs) {\n    // NOTE fancyName is not yet official and may change name or meaning\n    const name = options.html ? this.fancyName ?? this.name : this.name;\n    return this.arity > 0 && this.arity <= nargs\n      ? options.redex[0] + name + options.redex[1]\n      : name;\n  }\n}\n\nlet freeId = 0;\n\nclass FreeVar extends Named {\n  /**\n   * @desc A named variable.\n   *\n   * Given the functional nature of combinatory logic, variables are treated\n   * as functions that we don't know how to evaluate just yet.\n   *\n   * By default, two different variables even with the same name are considered different.\n   * They display it via a hidden id property.\n   *\n   * If a scope object is given, however, two variables with the same name and scope\n   * are considered identical.\n   *\n   * @param {string} name - name of the variable\n   * @param {any} scope - an object representing where the variable belongs to.\n   */\n  constructor (name, scope) {\n    super(name);\n    this.id = ++freeId;\n    // TODO temp compatibility mode\n    this.scope = scope === undefined ? this : scope;\n  }\n\n  weight () {\n    return 0;\n  }\n\n  diff (other, swap = false) {\n    if (!(other instanceof FreeVar))\n      return super.diff(other, swap);\n    if (this.name === other.name && this.scope === other.scope)\n      return null;\n    const lhs = this.name + '[' + this.id + ']';\n    const rhs = other.name + '[' + other.id + ']';\n    return swap\n      ? '[' + rhs + ' != ' + lhs + ']'\n      : '[' + lhs + ' != ' + rhs + ']';\n  }\n\n  subst (search, replace) {\n    if (search instanceof FreeVar && search.name === this.name && search.scope === this.scope)\n      return replace;\n    return null;\n  }\n\n  _format (options, nargs) {\n    const name = options.html ? this.fancyName ?? this.name : this.name;\n    return options.var[0] + name + options.var[1];\n  }\n}\n\nclass Native extends Named {\n  /**\n   * @desc A named term with a known rewriting rule.\n   *       'impl' is a function with signature Expr => Expr => ... => Expr\n   *       (see typedef Partial).\n   *       This is how S, K, I, and company are implemented.\n   *\n   *       Note that as of current something like a=>b=>b(a) is not possible,\n   *       use full form instead: a=>b=>b.apply(a).\n   *\n   * @example new Native('K', x => y => x); // constant\n   * @example new Native('Y', function(f) { return f.apply(this.apply(f)); }); // self-application\n   *\n   * @param {String} name\n   * @param {Partial} impl\n   * @param {{note?: string, arity?: number, canonize?: boolean, apply?: function(Expr):(Expr|null) }} [opt]\n   */\n  constructor (name, impl, opt = {}) {\n    super(name);\n    // setup essentials\n    this.invoke  = impl;\n\n    // TODO infer lazily (on demand, only once); app capabilities such as discard and duplicate\n    // try to bootstrap and infer some of our properties\n    const guess = (opt.canonize ?? true) ? this.infer() : { normal: false };\n\n    /** @type {number} */\n    this.arity = opt.arity || guess.arity || 1;\n    /** @type {string} */\n    this.note = opt.note ?? guess.expr?.format({ terse: true, html: true, lambda: ['', ' &mapsto; ', ''] });\n  }\n\n  _rski (options) {\n    if (this === native.I || this === native.K || this === native.S || (options.steps >= options.max))\n      return this;\n    const canon = this.infer().expr;\n    if (!canon)\n      return this;\n    options.steps++;\n    return canon._rski(options);\n  }\n}\n\n// predefined global combinator list\n// it is required by toSKI method, otherwise it could've as well be in parse.js\n/**\n * @type {{[key: string]: Native}}\n */\nconst native = {};\nfunction addNative (name, impl, opt) {\n  native[name] = new Native(name, impl, opt);\n}\n\nclass Lambda extends Expr {\n  /**\n   * @desc Lambda abstraction of arg over impl.\n   *     Upon evaluation, all occurrences of 'arg' within 'impl' will be replaced\n   *     with the provided argument.\n   *\n   * Note that 'arg' will be replaced by a localized placeholder, so the original\n   * variable can be used elsewhere without interference.\n   * Listing symbols contained in the lambda will omit such placeholder.\n   *\n   * Legacy ([FreeVar], impl) constructor is supported but deprecated.\n   * It will create a nested lambda expression.\n   *\n   * @param {FreeVar} arg\n   * @param {Expr} impl\n   */\n  constructor (arg, impl) {\n    if (Array.isArray(arg)) {\n      // check args before everything\n      if (arg.length === 0)\n        throw new Error('empty argument list in lambda constructor');\n\n      const [my, ...tail] = arg;\n      const known = new Set([my.name]);\n\n      while (tail.length > 0) {\n        const last = tail.pop();\n        if (known.has(last.name))\n          throw new Error('Duplicate free var name ' + last + ' in lambda expression');\n        known.add(last.name);\n\n        // TODO keep track of arity to speed up execution\n        impl = new Lambda(last, impl);\n      }\n      arg = my;\n    }\n\n    super();\n\n    // localize argument variable and bind it to oneself\n    const local = new FreeVar(arg.name, this);\n    this.arg = local;\n    this.impl = impl.subst(arg, local) ?? impl;\n    this.arity = 1;\n  }\n\n  weight () {\n    return this.impl.weight() + 1;\n  }\n\n  _infer (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs)\n      return { normal: false, steps };\n\n    const push = nthvar(preArgs.length + options.index);\n    return this.invoke(push)._infer(options, [...preArgs, push], steps + 1);\n  }\n\n  invoke (arg) {\n    return this.impl.subst(this.arg, arg) ?? this.impl;\n  }\n\n  _traverse (change) {\n    const [expr, action] = unwrap(change(this));\n    if (action === control.stop)\n      return control.stop(expr);\n    if (expr || action === control.prune)\n      return expr;\n\n    // alas no proper shielding of self.arg is possible\n    const [impl, iAction] = unwrap(this.impl._traverse_redo(change));\n\n    const final = impl ? new Lambda(this.arg, impl) : null;\n\n    return iAction === control.stop ? control.stop(final) : final;\n  }\n\n  any (predicate) {\n    return predicate(this) || this.impl.any(predicate);\n  }\n\n  _fold (initial, combine) {\n    const [value = initial, action = 'descend'] = unwrap(combine(initial, this));\n    if (action === control.prune)\n      return value;\n    if (action === control.stop)\n      return control.stop(value);\n    const [iValue, iAction] = unwrap(this.impl._fold(value, combine));\n    if (iAction === control.stop)\n      return control.stop(iValue);\n    return iValue ?? value;\n  }\n\n  subst (search, replace) {\n    if (search === this.arg)\n      return null;\n    const change = this.impl.subst(search, replace);\n    return change ? new Lambda(this.arg, change) : null;\n  }\n\n  _rski (options) {\n    const impl = this.impl._rski(options);\n    if (options.steps >= options.max)\n      return new Lambda(this.arg, impl);\n    options.steps++;\n    if (impl === this.arg)\n      return native.I;\n    if (!impl.any(e => e === this.arg))\n      return native.K.apply(impl);\n    if (impl instanceof App) {\n      const { fun, arg } = impl;\n      // try eta reduction\n      if (arg === this.arg && !fun.any(e => e === this.arg))\n        return fun._rski(options);\n      // fall back to S\n      return native.S.apply(\n        (new Lambda(this.arg, fun))._rski(options),\n        (new Lambda(this.arg, arg))._rski(options)\n      );\n    }\n    throw new Error('Don\\'t know how to convert to SKI' + this);\n  }\n\n  diff (other, swap = false) {\n    if (!(other instanceof Lambda))\n      return super.diff(other, swap);\n\n    const t = new FreeVar('t'); // TODO better placeholder name\n\n    const diff = this.invoke(t).diff(other.invoke(t), swap);\n    if (diff)\n      return '(t->' + diff + ')'; // parentheses required to avoid ambiguity\n    return null;\n  }\n\n  _format (options, nargs) {\n    return (nargs > 0 ? options.brackets[0] : '')\n      + options.lambda[0]\n      + this.arg._format(options, 0) // TODO highlight redex if nargs > 0\n      + options.lambda[1]\n      + this.impl._format(options, 0) + options.lambda[2]\n      + (nargs > 0 ? options.brackets[1] : '');\n  }\n\n  _braced (first) {\n    return true;\n  }\n}\n\nclass Church extends Expr {\n  /**\n   * @desc Church numeral representing non-negative integer n:\n   *      n f x = f(f(...(f x)...)) with f applied n times.\n   * @param {number} n\n   */\n  constructor (n) {\n    n = Number.parseInt(n);\n    if (!(n >= 0))\n      throw new Error('Church number must be a non-negative integer');\n    super();\n    this.invoke = x => y => {\n      let expr = y;\n      for (let i = n; i-- > 0; )\n        expr = x.apply(expr);\n      return expr;\n    };\n\n    /** @type {number} */\n    this.n = n;\n    this.arity = 2;\n  }\n\n  diff (other, swap = false) {\n    if (!(other instanceof Church))\n      return super.diff(other, swap);\n    if (this.n === other.n)\n      return null;\n    return swap\n      ? '[' + other.n + ' != ' + this.n + ']'\n      : '[' + this.n + ' != ' + other.n + ']';\n  }\n\n  _rski (options) {\n    return this.infer().expr._rski(options);\n  }\n\n  _unspaced (arg) {\n    return false;\n  }\n\n  _format (options, nargs) {\n    return nargs >= 2\n      ? options.redex[0] + this.n + options.redex[1]\n      : this.n + '';\n  }\n}\n\nfunction waitn (expr, n) {\n  return arg => n <= 1 ? expr.apply(arg) : waitn(expr.apply(arg), n - 1);\n}\n\nclass Alias extends Named {\n  /**\n   * @desc A named alias for an existing expression.\n   *\n   *     Upon evaluation, the alias expands into the original expression,\n   *     unless it has a known arity > 0 and is marked terminal,\n   *     in which case it waits for enough arguments before expanding.\n   *\n   *     A hidden mutable property 'outdated' is used to silently\n   *     replace the alias with its definition in all contexts.\n   *     This is used when declaring named terms in an interpreter,\n   *     to avoid confusion between old and new terms with the same name.\n   *\n   * @param {String} name\n   * @param {Expr} impl\n   * @param {{canonize?: boolean, max?: number, maxArgs?: number, note?: string, terminal?: boolean}} [options]\n   */\n  constructor (name, impl, options = {}) {\n    super(name);\n    if (!(impl instanceof Expr))\n      throw new Error('Attempt to create an alias for a non-expression: ' + impl);\n    this.impl = impl;\n\n    if (options.note)\n      this.note = options.note;\n\n    const guess = options.canonize\n      ? impl.infer({ max: options.max, maxArgs: options.maxArgs })\n      : { normal: false };\n    this.arity = (guess.proper && guess.arity) || 0;\n    this.proper = guess.proper ?? false;\n    this.terminal = options.terminal ?? this.proper;\n    this.canonical = guess.expr;\n    this.invoke = waitn(impl, this.arity);\n  }\n\n  /**\n   * @property {boolean} [outdated] - whether the alias is outdated\n   *     and should be replaced with its definition when encountered.\n   * @property {boolean} [terminal] - whether the alias should behave like a standalone term\n   *     // TODO better name?\n   * @property {boolean} [proper] - whether the alias is a proper combinator (i.e. contains no free variables or constants)\n   * @property {number} [arity] - the number of arguments the alias waits for before expanding\n   * @property {Expr} [canonical] - equivalent lambda term.\n   */\n\n  weight () {\n    return this.terminal ? 1 : this.impl.weight();\n  }\n\n  _traverse (change) {\n    const [expr, action] = unwrap(change(this));\n    if (action === control.stop)\n      return control.stop(expr);\n    if (expr || action === control.prune)\n      return action ? action(expr) : expr;\n\n    return this.impl._traverse_redo(change);\n  }\n\n  any (predicate) {\n    return predicate(this) || this.impl.any(predicate);\n  }\n\n  _fold (initial, combine) {\n    const [value = initial, action] = unwrap(combine(initial, this));\n    if (action === control.prune)\n      return value;\n    if (action === control.stop)\n      return control.stop(value);\n    const [iValue, iAction] = unwrap(this.impl._fold(value, combine));\n    if (iAction === control.stop)\n      return control.stop(iValue);\n    return iValue ?? value;\n  }\n\n  subst (search, replace) {\n    if (this === search)\n      return replace;\n    return this.impl.subst(search, replace);\n  }\n\n  _infer (options, preArgs = [], steps = 0) {\n    return this.impl._infer(options, preArgs, steps);\n  }\n\n  // DO NOT REMOVE TYPE or tsc chokes with\n  //       TS2527: The inferred type of 'Alias' references an inaccessible 'this' type.\n  /**\n   * @return {{expr: Expr, steps: number, changed: boolean}}\n   */\n  step () {\n    // arity known = waiting for args to expand\n    if (this.arity > 0)\n      return { expr: this, steps: 0, changed: false };\n    // expanding is a change but it takes 0 steps\n    return { expr: this.impl, steps: 0, changed: true };\n  }\n\n  diff (other, swap = false) {\n    if (this === other)\n      return null;\n    return other.diff(this.impl, !swap);\n  }\n\n  _rski (options) {\n    return this.impl._rski(options);\n  }\n\n  _braced (first) {\n    return this.outdated ? this.impl._braced(first) : false;\n  }\n\n  _format (options, nargs) {\n    const outdated = options.inventory\n      ? options.inventory[this.name] !== this\n      : this.outdated;\n    return outdated ? this.impl._format(options, nargs) : super._format(options, nargs);\n  }\n}\n\n// ----- Expr* classes end here -----\n\n// declare native combinators\naddNative('I', x => x);\naddNative('K', x => _ => x);\naddNative('S', x => y => z => x.apply(z, y.apply(z)));\naddNative('B', x => y => z => x.apply(y.apply(z)));\naddNative('C', x => y => z => x.apply(z).apply(y));\naddNative('W', x => y => x.apply(y).apply(y));\n\naddNative(\n  '+',\n  n => n instanceof Church\n    ? new Church(n.n + 1)\n    : f => x => f.apply(n.apply(f, x)),\n  {\n    note: 'Increase a Church numeral argument by 1, otherwise n => f => x => f(n f x)',\n  }\n);\n\n// utility functions dependent on Expr* classes, in alphabetical order\n\n/**\n * @private\n * @given a list of free variables, an expression, and some capabilities of the context,\n *        return either a lambda term, or the original expression if no lambda abstraction is needed,\n *        plus some metadata about the term and the context.\n *\n *        Used by infer() internally.\n * @param {FreeVar[]} args\n * @param {Expr} expr\n * @param {object} caps\n * @returns {{expr: Expr, arity?: number, skip?: Set<number>, dup?: Set<number>, duplicate?, discard?, proper: boolean}}\n */\nfunction maybeLambda (args, expr, caps = {}) {\n  const count = new Array(args.length).fill(0);\n  let proper = true;\n  expr.traverse(e => {\n    if (e instanceof FreeVar) {\n      const index = args.findIndex(a => a.name === e.name);\n      if (index >= 0) {\n        count[index]++;\n        return;\n      }\n    }\n    if (!(e instanceof App))\n      proper = false;\n  });\n\n  const skip = new Set();\n  const dup = new Set();\n  for (let i = 0; i < args.length; i++) {\n    if (count[i] === 0)\n      skip.add(i);\n    else if (count[i] > 1)\n      dup.add(i);\n  }\n\n  return {\n    expr:      args.length ? new Lambda(args, expr) : expr,\n    ...(caps.synth ? {} : { arity: args.length }),\n    ...(skip.size ? { skip } : {}),\n    ...(dup.size ? { dup } : {}),\n    duplicate: !!dup.size  || caps.duplicate || false,\n    discard:   !!skip.size || caps.discard   || false,\n    proper,\n  };\n}\n\nfunction nthvar (n) {\n  return new FreeVar('abcdefgh'[n] ?? 'x' + n);\n}\n\n/**\n * @private\n * @param {Expr} expr\n * @param {{max?: number, maxArgs?: number}} options\n * @param {number} maxWeight\n * @yields {{expr: Expr, steps?: number, comment?: string}}\n */\nfunction * simplifyLambda (expr, options = {}, state = { steps: 0 }) {\n  // expr is a lambda, free variable, or an application thereof\n  // we want to find an equivalent lambda term with less weight\n  // which we do sequentially from leaves to the root of the AST\n\n  yield { expr, steps: state.steps, comment: '(self)' };\n\n  // short-circuit\n  if (expr.freeOnly())\n    return;\n\n  let maxWeight = expr.weight();\n\n  if (expr instanceof Lambda) {\n    for (const term of simplifyLambda(expr.impl, options, state)) {\n      const candidate = new Lambda(expr.arg, term.expr);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        yield { expr: candidate, steps: state.steps, comment: '(lambda)' + term.comment };\n      }\n    }\n  }\n\n  // fun * arg Descartes product\n  if (expr instanceof App) {\n    // try to split into fun+arg, then try canonization but exposing each step\n    let { fun, arg } = expr;\n\n    for (const term of simplifyLambda(fun, options, state)) {\n      const candidate = term.expr.apply(arg);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        fun = term.expr;\n        yield { expr: candidate, steps: state.steps, comment: '(fun)' + term.comment };\n      }\n    }\n\n    for (const term of simplifyLambda(arg, options, state)) {\n      const candidate = fun.apply(term.expr);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        yield { expr: candidate, steps: state.steps, comment: '(arg)' + term.comment };\n      }\n    }\n  }\n\n  const canon = expr.infer({ max: options.max, maxArgs: options.maxArgs });\n  state.steps += canon.steps;\n  if (canon.expr && canon.expr.weight() < maxWeight)\n    yield { expr: canon.expr, steps: state.steps, comment: '(canonical)' };\n}\n\n/**\n * @desc  Sort a list in such a way that dependent terms come after the (named) terms they depend on.\n *        If env is given, only terms listed there are taken into account.\n *        If env is omitted, it will be implied from the list.\n *        If list is omitted, it will default to values of env.\n *        If just one term is given instead of a list, it will be coerced into a list.\n *\n *        No terms outside env + list may ever appear in the result.\n *\n *        The terms in env must be named and their names must match their keys.\n *\n * @param {Expr|Expr[]} list\n * @param {{[s:string]: Named}} env\n * @returns {{list: Expr[], env: {[s:string]: Named}}}\n *\n * @example\n *    const expr = ski.parse(src);\n *    toposort([expr], ski.getTerms()); // returns all terms appearing in Expr in correct order\n */\nfunction toposort (list, env) {\n  if (list instanceof Expr)\n    list = [list];\n  if (env) {\n    // TODO check in[name].name === name\n    if (!list)\n      list = Object.keys(env).sort().map(k => env[k]); // ensure deterministic order\n  } else {\n    if (!list)\n      return [];\n    if (!env) {\n      env = {};\n      for (const item of list) {\n        if (!(item instanceof Named))\n          continue;\n        if (env[item.name])\n          throw new Error('duplicate name ' + item);\n        env[item.name] = item;\n      }\n    }\n  }\n\n  const out = [];\n  const seen = new Set();\n  const rec = term => {\n    if (seen.has(term))\n      return;\n    term.fold(null, (acc, e) => {\n      if (e !== term && e instanceof Named && env[e.name] === e) {\n        rec(e);\n        return Expr.control.prune(null);\n      }\n    });\n    out.push(term);\n    seen.add(term);\n  };\n\n  for (const term of list)\n    rec(term);\n\n  return {\n    list: out,\n    env,\n  };\n}\n\nExpr.native = native;\nExpr.control = control;\nExpr.extras = { toposort };\n\nmodule.exports = { Expr, App, Named, FreeVar, Lambda, Native, Alias, Church };\n", "/**\n * Combinatory logic simulator\n */\n'use strict';\n\nconst { Tokenizer, restrict } = require('./internal');\nconst classes = require('./expr');\n\nconst { Expr, Named, Native, Alias, FreeVar, Lambda, Church } = classes;\nconst { native } = Expr;\n\nclass Empty extends Expr {\n  apply (...args) {\n    return args.length ? args.shift().apply(...args) : this;\n  }\n\n  postParse () {\n    throw new Error('Attempt to use empty expression () as a term');\n  }\n}\n\nclass PartialLambda extends Empty {\n  // TODO mutable! rewrite ro when have time\n  constructor (term, known = {}) {\n    super();\n    this.impl = new Empty();\n    if (term instanceof FreeVar)\n      this.terms = [term];\n    else if (term instanceof PartialLambda) {\n      if (!(term.impl instanceof FreeVar))\n        throw new Error('Expected FreeVar->...->FreeVar->Expr');\n      this.terms = [...term.terms, term.impl];\n    } else\n      throw new Error('Expected FreeVar or PartialLambda');\n  }\n\n  apply (term, ...tail) {\n    if (term === null || tail.length !== 0 )\n      throw new Error('bad syntax in partial lambda expr');\n    this.impl = this.impl.apply(term);\n    return this;\n  }\n\n  postParse () {\n    return new Lambda(this.terms, this.impl);\n  }\n\n  // uncomment if debugging with prints\n  /* toString () {\n    return this.terms.join('->') + '->' + (this.impl ?? '???');\n  } */\n}\n\nfunction postParse (expr) {\n  return expr.postParse ? expr.postParse() : expr;\n}\n\nconst combChars = new Tokenizer(\n  '[()]', '[A-Z]', '[a-z_][a-z_0-9]*', '\\\\b[0-9]+\\\\b', '->', '\\\\+'\n);\n\nclass SKI {\n  /**\n   *\n   * @param {{\n   *    allow?: string,\n   *    numbers?: boolean,\n   *    lambdas?: boolean,\n   *    terms?: { [key: string]: Expr|string} | string[],\n   *    annotate?: boolean,\n   * }} [options]\n   */\n  constructor (options = {}) {\n    this.annotate = options.annotate ?? false;\n    this.known = { ...native };\n    this.hasNumbers = true;\n    this.hasLambdas = true;\n    /** @type {Set<string>} */\n    this.allow = new Set(Object.keys(this.known));\n\n    // Import terms, if any. Omit native ones\n    if (Array.isArray(options.terms))\n      this.bulkAdd(options.terms);\n    else if (options.terms) {\n      for (const name in options.terms) {\n        // Native terms already handled by allow\n        if (!options.terms[name].match(/^Native:/))\n          this.add(name, options.terms[name]);\n      }\n    }\n\n    // Finally, impose restrictions\n    // We must do it after recreating terms, or else terms reliant on forbidden terms will fail\n    this.hasNumbers = options.numbers ?? true;\n    this.hasLambdas = options.lambdas ?? true;\n    if (options.allow)\n      this.restrict(options.allow);\n  }\n\n  /**\n   * @desc Declare a new term\n   * If the first argument is an Alias, it is added as is.\n   * Otherwise, a new Alias or Native term (depending on impl type) is created.\n   * If note is not provided and this.annotate is true, an automatic note is generated.\n   *\n   * If impl is a function, it should have signature (Expr) => ... => Expr\n   * (see typedef Partial at top of expr.js)\n   *\n   * @example ski.add('T', 'S(K(SI))K', 'swap combinator')\n   * @example ski.add( ski.parse('T = S(K(SI))K') ) // ditto but one-arg form\n   * @example ski.add('T', x => y => y.apply(x), 'swap combinator') // heavy artillery\n   * @example ski.add('Y', function (f) { return f.apply(this.apply(f)); }, 'Y combinator')\n   *\n   * @param {Alias|String} term\n   * @param {String|Expr|function(Expr):Partial} [impl]\n   * @param {String} [note]\n   * @return {SKI} chainable\n   */\n  add (term, impl, note ) {\n    term = this._named(term, impl);\n\n    if (this.annotate && note === undefined) {\n      const guess = term.infer();\n      if (guess.expr)\n        note = guess.expr.format({ terse: true, html: true, lambda: ['', ' &mapsto; ', ''] });\n    }\n    if (note !== undefined)\n      term.note = note;\n\n    if (this.known[term.name])\n      this.known[term.name].outdated = true;\n    this.known[term.name] = term;\n    this.allow.add(term.name);\n\n    return this;\n  }\n\n  /**\n   * @desc Internal helper for add() that creates an Alias or Native term from the given arguments.\n   * @param {Alias|string} term\n   * @param {string|Expr|function(Expr):Partial} impl\n   * @returns {Native|Alias}\n   * @private\n   */\n  _named (term, impl) {\n    if (term instanceof Alias)\n      return new Alias(term.name, term.impl, { canonize: true });\n    if (typeof term !== 'string')\n      throw new Error('add(): term must be an Alias or a string');\n    if (impl === undefined)\n      throw new Error('add(): impl must be provided when term is a string');\n    if (typeof impl === 'string')\n      return new Alias(term, this.parse(impl), { canonize: true });\n    if (impl instanceof Expr)\n      return new Alias(term, impl, { canonize: true });\n    if (typeof impl === 'function')\n      return new Native(term, impl);\n    // idk what this is\n    throw new Error('add(): impl must be an Expr, a string, or a function with a signature Expr => ... => Expr');\n  }\n\n  /**\n   * @desc Declare a new term if it is not known, otherwise just allow it.\n   *       Currently only used by quests.\n   *       Use with caution, this function may change its signature, behavior, or even be removed in the future.\n   *\n   * @experimental\n   * @param {string|Alias} name\n   * @param {string|Expr|function(Expr):Partial} impl\n   * @returns {SKI}\n   */\n  maybeAdd (name, impl) {\n    if (this.known[name])\n      this.allow.add(name);\n    else\n      this.add(name, impl);\n    return this;\n  }\n\n  /**\n   * @desc Declare and remove multiple terms at once\n   *       term=impl adds term\n   *       term= removes term\n   * @param {string[]} list\n   * @return {SKI} chainable\n   */\n  bulkAdd (list) {\n    for (const item of list) {\n      const m = item.match(/^([A-Z]|[a-z][a-z_0-9]*)\\s*=\\s*(.*)$/s);\n      // TODO check all declarations before applying any (but we might need earlier terms for parsing later ones)\n      if (!m)\n        throw new Error('bulkAdd: invalid declaration: ' + item);\n      if (m[2] === '')\n        this.remove(m[1]);\n      else\n        this.add(m[1], this.parse(m[2]));\n    }\n\n    return this;\n  }\n\n  /**\n   * Restrict the interpreter to given terms. Terms prepended with '+' will be added\n   * and terms preceeded with '-' will be removed.\n   * @example ski.restrict('SK') // use the basis\n   * @example ski.restrict('+I') // allow I now\n   * @example ski.restrict('-SKI +BCKW' ); // switch basis\n   * @example ski.restrict('-foo -bar'); // forbid some user functions\n   * @param {string} spec\n   * @return {SKI} chainable\n   */\n  restrict (spec) {\n    this.allow = restrict(this.allow, spec);\n    return this;\n  }\n\n  /**\n   *\n   * @param {string} spec\n   * @return {string}\n   */\n  showRestrict (spec = '+') {\n    const out = [];\n    let prevShort = true;\n    for (const term of [...restrict(this.allow, spec)].sort()) {\n      const nextShort = term.match(/^[A-Z]$/);\n      if (out.length && !(prevShort && nextShort))\n        out.push(' ');\n      out.push(term);\n      prevShort = nextShort;\n    }\n    return out.join('');\n  }\n\n  /**\n   *\n   * @param {String} name\n   * @return {SKI}\n   */\n  remove (name) {\n    this.known[name].outdated = true;\n    delete this.known[name];\n    this.allow.delete(name);\n    return this;\n  }\n\n  /**\n   *\n   * @return {{[key:string]: Native|Alias}}\n   */\n  getTerms () {\n    const out = {};\n    for (const name of Object.keys(this.known)) {\n      if (this.allow.has(name))\n        out[name] = this.known[name];\n    }\n    return out;\n  }\n\n  /**\n   * @desc Export term declarations for use in bulkAdd().\n   * Currently only Alias terms are serialized.\n   * @returns {string[]}\n   */\n  declare () {\n    // TODO accept argument to declare specific terms only\n    const env = this.getTerms();\n\n    // not serializing native terms, and we don't care about free vars\n    for (const name in env) {\n      if (!(env[name] instanceof Alias))\n        delete env[name];\n    }\n\n    // avert conflicts if native terms were redefined:\n    // create a temporary alias for each native term that was redefined;\n    // replace usage of redefined term in subexpressions;\n    // finally, remove the temporary aliases from the output\n    const needDetour = {};\n    let i = 1;\n    for (const name in native) {\n      if (!(env[name] instanceof Alias))\n        continue;\n      while ('tmp' + i in env)\n        i++;\n      const temp = new Alias('tmp' + i, env[name]);\n      needDetour[temp] = env[name];\n      env[temp] = temp;\n      delete env[name];\n    }\n\n    // console.log(env);\n\n    const list = Expr.extras.toposort(undefined, env).list;\n\n    const detour = new Map();\n    if (Object.keys(needDetour).length) {\n      // replace aliases with their detoured counterparts.\n      // we have to go recursive, otherwise an unrelated alias may be expanded to its impl\n      // and name infos will be erased\n      const rework = expr => {\n        return expr.traverse(e => {\n          if (!(e instanceof Alias))\n            return null; // continue\n          const newAlias = detour.get(e);\n          if (newAlias)\n            return newAlias;\n          return new Alias(e.name, rework(e.impl));\n        }) ?? expr;\n      };\n\n      for (let i = 0; i < list.length; i++) {\n        // upon processing list[i], only terms declared before it may be detoured\n        list[i] = rework(list[i], detour);\n        detour.set(needDetour[list[i].name], list[i]);\n        env[list[i].name] = list[i];\n        console.log(`list[${i}] = ${list[i].name}=${list[i].impl};`);\n      }\n      console.log('detour:', detour);\n    }\n\n    // console.log(res);\n    const out = list.map(e => needDetour[e]\n      ? e.name + '=' + needDetour[e].name + '=' + e.impl.format({ inventory: env })\n      : e.name + '=' + e.impl.format({ inventory: env })\n    );\n\n    for (const [name, temp] of detour)\n      out.push(name + '=' + temp, temp + '=');\n\n    return out;\n  }\n\n  /**\n   * @template T\n   * @param {string} source\n   * @param {Object} [options]\n   * @param {{[keys: string]: Expr}} [options.env]\n   * @param {T} [options.scope]\n   * @param {boolean} [options.numbers]\n   * @param {boolean} [options.lambdas]\n   * @param {string} [options.allow]\n   * @return {Expr}\n   */\n  parse (source, options = {}) {\n    if (typeof source !== 'string')\n      throw new Error('parse: source must be a string, got ' + typeof source);\n\n    const lines = source.replace(/\\/\\/[^\\n]*$/gm, ' ')\n      .replace(/\\/\\*.*?\\*\\//gs, ' ')\n      .trim()\n      .split(/\\s*;[\\s;]*/).filter( s => s.match(/\\S/));\n\n    const jar = { ...options.env };\n\n    let expr = new Empty();\n    for (const item of lines) {\n      if (expr instanceof Alias)\n        expr.outdated = true;\n\n      const def = item.match(/^([A-Z]|[a-z][a-z_0-9]*)\\s*=(.*)$/s);\n      if (def && def[2] === '')\n        expr = new FreeVar(def[1], options.scope ?? SKI);\n      else\n        expr = this.parseLine(item, jar, options);\n\n      if (def) {\n        if (jar[def[1]] !== undefined)\n          throw new Error('Attempt to redefine a known term: ' + def[1]);\n        jar[def[1]] = expr;\n      }\n\n      // console.log('parsed line:', item, '; got:', expr,'; jar now: ', jar);\n    }\n\n    expr.context = {\n      env:    { ...this.getTerms(), ...jar }, // also contains pre-parsed terms\n      scope:  options.scope,\n      src:    source,\n      parser: this,\n    };\n    return expr;\n  }\n\n  /**\n   * @desc Parse a single line of source code, without splitting it into declarations.\n   *       Internal, always use parse() instead.\n   * @template T\n   * @param {String} source S(KI)I\n   * @param {{[keys: string]: Expr}} env\n   * @param {Object} [options]\n   * @param {{[keys: string]: Expr}} [options.env] - unused, see 'env' argument\n   * @param {T} [options.scope]\n   * @param {boolean} [options.numbers]\n   * @param {boolean} [options.lambdas]\n   * @param {string} [options.allow]\n   * @return {Expr} parsed expression\n   */\n  parseLine (source, env = {}, options = {}) {\n    const aliased = source.match(/^\\s*([A-Z]|[a-z][a-z_0-9]*)\\s*=\\s*(.*)$/s);\n    if (aliased)\n      return new Alias(aliased[1], this.parseLine(aliased[2], env, options));\n\n    const opt = {\n      numbers: options.numbers ?? this.hasNumbers,\n      lambdas: options.lambdas ?? this.hasLambdas,\n      allow:   restrict(this.allow, options.allow),\n    };\n    // make sure '+' usage is in sync with numerals\n    opt.numbers ? opt.allow.add('+') : opt.allow.delete('+');\n\n    const tokens = combChars.split(source);\n\n    const empty = new Empty();\n    /** @type {Expr[]} */\n    const stack = [empty];\n    const context = options.scope || SKI; // default is global unbound vars\n\n    // TODO each token should carry along its position in source\n    for (const c of tokens) {\n      // console.log(\"parseLine: found \"+c+\"; stack =\", stack.join(\", \"));\n      if (c === '(')\n        stack.push(empty);\n      else if (c === ')') {\n        if (stack.length < 2)\n          throw new Error('unbalanced input: extra closing parenthesis' + source);\n        const x = postParse(stack.pop());\n        const f = stack.pop();\n        stack.push(f.apply(x));\n      } else if (c === '->') {\n        if (!opt.lambdas)\n          throw new Error('Lambdas not supported, allow them explicitly');\n        stack.push(new PartialLambda(stack.pop(), env));\n      } else if (c.match(/^[0-9]+$/)) {\n        if (!opt.numbers)\n          throw new Error('Church numbers not supported, allow them explicitly');\n        const f = stack.pop();\n        stack.push(f.apply(new Church(c)));\n      } else {\n        const f = stack.pop();\n        if (!env[c] && this.known[c] && !opt.allow.has(c)) {\n          throw new Error('Term \\'' + c + '\\' is not in the restricted set '\n            + [...opt.allow].sort().join(' '));\n        }\n        // look in temp vars first, then in known terms, then fallback to creating free var\n        const x = env[c] ?? this.known[c] ?? (env[c] = new FreeVar(c, context));\n        stack.push(f.apply(x));\n      }\n    }\n\n    if (stack.length !== 1) {\n      throw new Error('unbalanced input: missing '\n          + (stack.length - 1) + ' closing parenthesis:' + source);\n    }\n\n    return postParse(stack.pop());\n  }\n\n  toJSON () {\n    return {\n      version:  '1.1.1', // set to incremented package.json version whenever SKI serialization changes\n      allow:    this.showRestrict('+'),\n      numbers:  this.hasNumbers,\n      lambdas:  this.hasLambdas,\n      annotate: this.annotate,\n      terms:    this.declare(),\n    }\n  }\n}\n\n/**\n *  Public static shortcuts to common functions (see also ./extras.js)\n */\n\n/**\n * @desc Create a proxy object that generates variables on demand,\n *       with names corresponding to the property accessed.\n *       Different invocations will return distinct variables,\n *       even if with the same name.\n *\n *\n * @example const {x, y, z} = SKI.vars();\n *          x.name; // 'x'\n *          x instanceof FreeVar; // true\n *          x.apply(y).apply(z); // x(y)(z)\n *\n * @template T\n * @param {T} [scope] - optional context to bind the generated variables to\n * @return {{[key: string]: FreeVar}}\n */\nSKI.vars = function (scope = {}) {\n  const cache = {};\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (!(name in cache))\n        cache[name] = new FreeVar(name, scope);\n      return cache[name];\n    }\n  });\n};\n\n/**\n * Convert a number to Church encoding\n * @param {number} n\n * @return {Church}\n */\nSKI.church = n => new Church(n);\n\n/**\n *\n * @type {{[key: string]: Native}}\n */\n\nfor (const name in native)\n  SKI[name] = native[name];\n\nSKI.classes = classes;\nSKI.native = native;\n/**\n * @desc Traverse control functions, used by Expr.traverse() and Expr.fold()\n * @template T\n * @type {{\n *    descend: function(T): TraverseControl<T>,\n *    prune: function(T): TraverseControl<T>,\n *    redo: function(T): TraverseControl<T>,\n *    stop: function(T): TraverseControl<T>\n * }}\n */\nSKI.control = Expr.control;\n\nmodule.exports = { SKI };\n", "const { SKI } = require('./parser');\nconst { Expr, FreeVar, Alias, Lambda } = SKI.classes;\n\n/**\n * @typedef {{\n *   pass: boolean,\n *   reason?: string,\n *   steps: number,\n *   start: Expr,\n *   found: Expr,\n *   expected: Expr,\n *   note?: string,\n *   args: Expr[],\n *   case: Case\n * }} CaseResult\n */\n\n/**\n * @typedef {{\n *   linear?: boolean,\n *   affine?: boolean,\n *   normal?: boolean,\n *   proper?: boolean,\n *   discard?: boolean,\n *   duplicate?: boolean,\n *   arity?: number,\n * }} Capability\n */\n\n/**\n * @typedef {\n *   [string, string]\n *   | [{max?: number}, string, string]\n *   | [{caps: Capability, max?: number}, string]\n * } TestCase\n */\n\n/**\n * @typedef {string | {name: string, fancy?: string, allow?: string, numbers?: boolean, lambdas?: boolean}} InputSpec\n */\n\n/**\n * @typedef {{\n *   pass: boolean,\n *   details: CaseResult[],\n *   expr?: Expr,\n *   input: Expr[]|string[],\n *   exception?: Error,\n *   steps: number,\n *   weight?: number\n * }} QuestResult\n */\n\n/**\n * @typedef {{\n *    input: InputSpec | InputSpec[],\n *    cases: TestCase[],\n *\n *    // the rest is optional\n *\n *    allow?: string,\n *    numbers?: boolean,\n *    env?: string[],\n *    engine?: SKI,\n *    engineFull?: SKI,\n *\n *    // metadata, also any fields not listed here will go to quest.meta.???\n *    id?: string|number,\n *    name?: string,\n *    intro?: string|string[], // multiple strings will be concatenated with spaces\n * }} QuestSpec\n */\n\n/**\n * @typedef {{ accepted?: string[][], rejected?: string[][] }} SelfCheck\n */\n\nclass Quest {\n  /**\n   * @description A combinator problem with a set of test cases for the proposed solution.\n   * @param {QuestSpec} options\n   * @example const quest = new Quest({\n   *    input: 'identity',\n   *    cases: [\n   *      ['identity x', 'x'],\n   *    ],\n   *    allow: 'SK',\n   *    intro: 'Find a combinator that behaves like the identity function.',\n   * });\n   * quest.check('S K K'); // { pass: true, details: [...], ... }\n   * quest.check('K S');   // { pass: false, details: [...], ... }\n   * quest.check('K x');   // fail! internal variable x is not equal to free variable x,\n   *                       //     despite having the same name.\n   * quest.check('I');     // fail! I not in the allowed list.\n   */\n  constructor (options) {\n    const { input, cases, allow, numbers, lambdas, engine, engineFull, ...meta } = options;\n    const env = options.env ?? options.vars; // backwards compatibility\n\n    //\n    this.engine = engine ?? new SKI();\n    this.engineFull = engineFull ?? new SKI();\n    this.restrict = { allow, numbers: numbers ?? false, lambdas: lambdas ?? false };\n    this.env = {};\n\n    const jar = {};\n\n    // option.env is a list of expressions.\n    // we suck all free variables + all term declarations from there into this.env\n    // to feed it later to every case's parser.\n    for (const term of env ?? []) {\n      const expr = this.engineFull.parse(term, { env: jar, scope: this });\n      if (expr instanceof SKI.classes.Alias)\n        this.env[expr.name] = new Alias(expr.name, expr.impl, { terminal: true, canonize: false });\n        // Canonized aliases won't expand with insufficient arguments,\n        // causing correct solutions to fail, so alas...\n      else if (expr instanceof SKI.classes.FreeVar)\n        this.env[expr.name] = expr;\n      else\n        throw new Error('Unsupported given variable type: ' + term);\n    }\n\n    this.input = [];\n    for (const term of Array.isArray(input) ? input : [input])\n      this.addInput(term);\n    if (!this.input.length)\n      throw new Error('Quest needs at least one input placeholder');\n\n    this.envFull = { ...this.env, ...jar };\n    for (const term of this.input) {\n      if (term.name in this.envFull)\n        throw new Error('input placeholder name is duplicated or clashes with env: ' + term.name);\n      this.envFull[term.name] = term.placeholder;\n    }\n\n    // NOTE meta is a local variable, can mutate\n    // NOTE title/descr are old name/intro respectively, kept for backwards compatibility\n    this.cases = [];\n    this.name = meta.name ?? meta.title;\n    meta.intro = list2str(meta.intro ?? meta.descr);\n    this.intro = meta.intro;\n    this.id = meta.id;\n    this.meta = meta;\n\n    for (const c of cases ?? [])\n      this.add(...c);\n  }\n\n  /**\n   *   Display allowed terms based on what engine thinks of this.env + this.restrict.allow\n   *   @return {string}\n   */\n  allowed () {\n    const allow = this.restrict.allow ?? '';\n    const env  = Object.keys(this.env).sort();\n    // In case vars are present and restrictions aren't, don't clutter the output with all the known terms\n    return allow\n      ? this.engine.showRestrict(allow + '+' + env.join(' '))\n      : env.map( s => '+' + s).join(' ');\n  }\n\n  addInput (term) {\n    if (typeof term !== 'object')\n      term = { name: term };\n    if (typeof term.name !== 'string')\n      throw new Error(\"quest 'input' field must be a string or a {name: string, ...} object\");\n\n    term.placeholder = new SKI.classes.FreeVar(term.name);\n    // TODO more checks\n    this.input.push(term);\n  }\n\n  /**\n   *\n   * @param {{} | string} opt\n   * @param {string} terms\n   * @return {Quest}\n   */\n  add (opt, ...terms) {\n    if (typeof opt === 'string') {\n      terms.unshift(opt);\n      opt = {};\n    } else\n      opt = { ...opt };\n\n    opt.engine = opt.engine  ?? this.engineFull;\n    opt.env = opt.env ?? this.envFull;\n\n    const input = this.input.map( t => t.placeholder );\n    this.cases.push(\n      opt.caps\n        ? new PropertyCase(input, opt, terms)\n        : new ExprCase(input, opt, terms)\n    );\n    return this;\n  }\n\n  /**\n   * @description Statefully parse a list of strings into expressions or fancy aliases thereof.\n   * @param {string[]} input\n   * @return {{terms: Expr[], weight: number}}\n   */\n  prepare (...input) {\n    if (input.length !== this.input.length)\n      throw new Error('Solutions provided ' + input.length + ' terms where ' + this.input.length + ' are expected');\n\n    let weight = 0;\n    const prepared = [];\n    const jar = { ...this.env };\n    for (let i = 0; i < input.length; i++) {\n      const spec = this.input[i];\n      const impl = this.engine.parse(input[i], {\n        env:     jar,\n        allow:   spec.allow ?? this.restrict.allow,\n        numbers: spec.numbers ?? this.restrict.numbers,\n        lambdas: spec.lambdas ?? this.restrict.lambdas,\n      });\n      const arsenal = { ...this.engine.getTerms(), ...jar };\n      weight += impl.fold(0, (a, e) => {\n        if (e instanceof SKI.classes.Named && arsenal[e.name] === e)\n          return SKI.control.prune( a + 1);\n      });\n      const expr = impl instanceof FreeVar\n        ? impl\n        : new Alias(spec.fancy ?? spec.name, impl, { terminal: true, canonize: false });\n      jar[spec.name] = expr;\n      prepared.push(expr);\n    }\n    return {\n      prepared,\n      weight,\n    };\n  }\n\n  /**\n   *\n   * @param {string} input\n   * @return {QuestResult}\n   */\n  check (...input) {\n    try {\n      const { prepared, weight } = this.prepare(...input);\n      const details = this.cases.map( c => c.check(...prepared) );\n      const pass = details.reduce((acc, val) => acc && val.pass, true);\n      const steps = details.reduce((acc, val) => acc + val.steps, 0);\n      return {\n        expr:  prepared[0],\n        input: prepared,\n        pass,\n        steps,\n        details,\n        weight,\n      };\n    } catch (e) {\n      return { pass: false, details: [], exception: e, steps: 0, input };\n    }\n  }\n\n  verify (options) {\n    const findings = this.verifyMeta(options);\n    if (options.solutions) {\n      const solCheck = this.verifySolutions(options.solutions);\n      if (solCheck)\n        findings.solutions = solCheck;\n    }\n    if (options.seen) {\n      if (!this.id)\n        findings.seen = 'No id in quest ' + (this.name ?? '(unnamed)');\n      if (options.seen.has(this.id))\n        findings.seen = 'Duplicate quest id ' + this.id;\n      options.seen.add(this.id); // mutating but who cares\n    }\n    return Object.keys(findings).length ? findings : null;\n  }\n\n  /**\n   * @desc Verify that solutions that are expected to pass/fail do so.\n   * @param {SelfCheck|{[key: string]: SelfCheck}} dataset\n   * @return {{shouldPass: {input: string[], result: QuestResult}[], shouldFail: {input: string[], result: QuestResult}[]} | null}\n   */\n  verifySolutions (dataset) {\n    // dataset is either a SelfCheck object or a hash of { quest_id: SelfCheck }\n    if (typeof dataset === 'object' && !Array.isArray(dataset?.accepted) && !Array.isArray(dataset?.rejected)) {\n      // dataset is a hash of { quest_id: SelfCheck } so extract data\n      if (!this.id || !dataset[this.id])\n        return null; // no self-check data for this quest, skip\n    }\n\n    const { accepted = [], rejected = [] } = dataset[this.id] ?? dataset;\n\n    const ret = { shouldPass: [], shouldFail: [] };\n    for (const input of accepted) {\n      const result = this.check(...input);\n      if (!result.pass)\n        ret.shouldPass.push({ input, result });\n    }\n    for (const input of rejected) {\n      const result = this.check(...input);\n      if (result.pass)\n        ret.shouldFail.push({ input, result });\n    }\n    return (ret.shouldFail.length + ret.shouldPass.length) ? ret : null; // return null if all good\n  }\n\n  verifyMeta (options = {}) {\n    const findings = {};\n\n    for (const field of ['name', 'intro']) {\n      const found = checkHtml(this[field]);\n      if (found)\n        findings[field] = found;\n    }\n    if (options.date) {\n      const date = new Date(this.meta.created_at);\n      if (isNaN(date))\n        findings.date = 'invalid date format: ' + this.meta.created_at;\n      else if (date < new Date('2024-07-15') || date > new Date())\n        findings.date = 'date out of range: ' + this.meta.created_at;\n    }\n\n    return findings;\n  }\n\n  /**\n     *\n     * @return {TestCase[]}\n     */\n  show () {\n    return [...this.cases];\n  }\n}\n\nclass Case {\n  /**\n   * @param {FreeVar[]} input\n   * @param {{\n   *   max?: number,\n   *   note?: string,\n   *   env?: {[key:string]: Expr},\n   *   engine: SKI\n   * }} options\n   */\n  constructor (input, options) {\n    this.max = options.max ?? 1000;\n    this.note = options.note;\n    this.env = { ...(options.env ?? {}) }; // note: env already contains input placeholders\n    this.input = input;\n    this.engine = options.engine;\n  }\n\n  parse (src) {\n    return new Subst(this.engine.parse(src, { env: this.env, scope: this }), this.input);\n  }\n\n  /**\n   * @param {Expr} expr\n   * @return {CaseResult}\n   */\n  check ( ...expr ) {\n    throw new Error('not implemented');\n  }\n}\n\nclass ExprCase extends Case {\n  /**\n   * @param {FreeVar[]} input\n   * @param {{\n   *    max?: number,\n   *    note?: string,\n   *    env?: {string: Expr},\n   *    engine?: SKI\n   * }} options\n   * @param {[e1: string, e2: string]} terms\n   */\n  constructor (input, options, terms) {\n    if (terms.length !== 2)\n      throw new Error('Case accepts exactly 2 strings');\n\n    super(input, options);\n\n    [this.e1, this.e2] = terms.map( s => this.parse(s) );\n  }\n\n  check (...args) {\n    const e1 = this.e1.apply(args);\n    const r1 = e1.run({ max: this.max });\n    const e2 = this.e2.apply(args);\n    const r2 = e2.run({ max: this.max });\n\n    let reason = null;\n    if (!r1.final || !r2.final)\n      reason = 'failed to reach normal form in ' + this.max + ' steps';\n    else\n      reason = r1.expr.diff(r2.expr);\n\n    return {\n      pass:     !reason,\n      reason,\n      steps:    r1.steps,\n      start:    e1,\n      found:    r1.expr,\n      expected: r2.expr,\n      note:     this.note,\n      args,\n      case:     this,\n    };\n  }\n}\n\nconst knownCaps = {\n  normal:    true,\n  proper:    true,\n  discard:   true,\n  duplicate: true,\n  linear:    true,\n  affine:    true,\n  arity:     true,\n}\n\nclass PropertyCase extends Case {\n  // test that an expression uses all of its inputs exactly once\n  constructor (input, options, terms) {\n    super(input, options);\n    if (terms.length > 1)\n      throw new Error('PropertyCase accepts exactly 1 string');\n    if (!options.caps || typeof options.caps !== 'object' || !Object.keys(options.caps).length)\n      throw new Error('PropertyCase requires a caps object with at least one capability');\n    const unknown = Object.keys(options.caps).filter( c => !knownCaps[c] );\n    if (unknown.length)\n      throw new Error('PropertyCase: don\\'t know how to test these capabilities: ' + unknown.join(', '));\n\n    this.expr = this.parse(terms[0]);\n    this.caps = options.caps;\n\n    if (this.caps.linear) {\n      delete this.caps.linear;\n      this.caps.duplicate = false;\n      this.caps.discard = false;\n      this.caps.normal = true;\n    }\n\n    if (this.caps.affine) {\n      delete this.caps.affine;\n      this.caps.normal = true;\n      this.caps.duplicate = false;\n    }\n  }\n\n  check (...expr) {\n    const start = this.expr.apply(expr);\n    const r = start.run({ max: this.max });\n    const guess = r.expr.infer({ max: this.max });\n\n    const reason = [];\n    for (const cap in this.caps) {\n      if (guess[cap] !== this.caps[cap])\n        reason.push('expected property ' + cap + ' to be ' + this.caps[cap] + ', found ' + guess[cap]);\n    }\n\n    return {\n      pass:   !reason.length,\n      reason: reason ? reason.join('\\n') : null,\n      steps:  r.steps,\n      start,\n      found:  r.expr,\n      case:   this,\n      note:   this.note,\n      args:   expr,\n    };\n  }\n}\n\nclass Subst {\n  /**\n   * @descr A placeholder object with exactly n free variables to be substituted later.\n   * @param {Expr} expr\n   * @param {FreeVar[]} env\n   */\n  constructor (expr, env) {\n    this.expr = expr;\n    this.env = env;\n  }\n\n  apply (list) {\n    if (list.length !== this.env.length)\n      throw new Error('Subst: expected ' + this.env.length + ' terms, got ' + list.length);\n\n    let expr = this.expr;\n    for (let i = 0; i < this.env.length; i++)\n      expr = expr.subst(this.env[i], list[i]) ?? expr;\n\n    return expr;\n  }\n}\n\n// corresponds to \"chapter\" in the quest page\nclass Group {\n  constructor (options) {\n    this.name = options.name;\n    this.intro = list2str(options.intro);\n    this.id = options.id;\n\n    // TODO don't die on failed quests\n    if (options.content)\n      this.content = options.content.map( c => c instanceof Quest ? c : new Quest(c) );\n  }\n\n  verify (options) {\n    const findings = {};\n    const id = checkId(this.id, options.seen);\n    if (id)\n      findings[this.id] = id;\n    for (const field of ['name', 'intro']) {\n      const found = checkHtml(this[field]);\n      if (found)\n        findings[field] = found;\n    }\n\n    findings.content = this.content.map(q => q.verify(options));\n    return findings;\n  }\n}\n\n/**\n * @desc Concatenate long strings represented as arrays, or just pass along if already string or undefined.\n * @param {string|Array<string>|undefined} str\n * @returns {string|undefined}\n */\nfunction list2str (str) {\n  if (str === undefined || typeof str === 'string')\n    return str;\n  return Array.isArray(str) ? str.join(' ') : '' + str;\n}\n\nfunction checkId (id, seen) {\n  if (id === undefined)\n    return 'missing';\n  if (typeof id !== 'string' && typeof id !== 'number' )\n    return 'is a ' + typeof id;\n  if (seen) {\n    if (seen.has(id))\n      return 'duplicate id ' + id;\n    seen.add(id);\n  }\n  // return nothing = success\n}\n\nfunction checkHtml (str) {\n  if (str === undefined)\n    return 'missing';\n  if (typeof str !== 'string')\n    return 'not a string but ' + typeof str;\n\n  // very basic check for unclosed tags, just to catch common mistakes in the quest text\n  const tagStack = [];\n  const tagRegex = /<\\/?([a-z]+)(?:\\s[^>]*)?>/gi;\n  let match;\n  while ((match = tagRegex.exec(str)) !== null) {\n    const [fullTag, tagName] = match;\n    if (fullTag.startsWith('</')) {\n      // Closing tag\n      if (tagStack.length === 0 || tagStack.pop() !== tagName)\n        return (`Unmatched closing tag: </${tagName}>`);\n    } else {\n      // Opening tag\n      tagStack.push(tagName);\n    }\n  }\n  if (tagStack.length > 0)\n    return (`Unclosed tags: ${tagStack.join(', ')}`);\n\n  return null; // No issues found\n}\n\nQuest.Group = Group;\n\nmodule.exports = { Quest };\n", "'use strict';\n\nconst { Expr, Alias, FreeVar } = require('./expr');\n\n/**\n * @desc  Extra utilities that do not belong in the core.\n */\n\n/**\n * @experimental\n * @desc  Look for an expression that matches the predicate,\n *        starting with the seed and applying the terms to one another.\n *\n *        A predicate returning 0 (or nothing) means \"keep looking\",\n *        a positive number stands for \"found\",\n *        and a negative means \"discard this term from further applications\".\n *\n *        The order of search is from shortest to longest expressions.\n *\n * @param {Expr[]} seed\n * @param {object} options\n * @param {number} [options.depth] - maximum generation to search for\n * @param {number} [options.tries] - maximum number of tries before giving up\n * @param {boolean} [options.infer] - whether to call infer(), default true.\n * @param {number} [options.maxArgs] - arguments in infer()\n * @param {number} [options.max] - step limit in infer()\n * @param {boolean} [options.noskip] - prevents skipping equivalent terms. Always true if infer is false.\n * @param {boolean} [retain] - if true. also add the whole cache to returned value\n * @param {({gen: number, total: number, probed: number, step: boolean}) => void} [options.progress]\n * @param {number} [options.progressInterval] - minimum number of tries between calls to options.progress, default 1000.\n * @param {(e: Expr, props: {}) => number?} predicate\n * @return {{expr?: Expr, total: number, probed: number, gen: number, cache?: Expr[][]}}\n */\nfunction search (seed, options, predicate) {\n  const {\n    depth = 16,\n    infer = true,\n    progressInterval = 1000,\n  } = options;\n  const hasSeen = infer && !options.noskip;\n\n  // cache[i] = ith generation, 0 is empty\n  const cache = [[]];\n  let total = 0;\n  let probed = 0;\n  const seen = {};\n\n  const maybeProbe = term => {\n    total++;\n    const props = infer ? term.infer({ max: options.max, maxArgs: options.maxArgs }) : null;\n    if (hasSeen && props.expr) {\n      if (seen[props.expr])\n        return { res: -1 };\n      seen[props.expr] = true;\n    }\n    probed++;\n    const res = predicate(term, props);\n    return { res, props };\n  };\n\n  // sieve through the seed\n  for (const term of seed) {\n    const { res } = maybeProbe(term);\n    if (res > 0)\n      return { expr: term, total, probed, gen: 1 };\n    else if (res < 0)\n      continue;\n\n    cache[0].push(term);\n  }\n\n  let lastProgress;\n\n  for (let gen = 1; gen < depth; gen++) {\n    if (options.progress) {\n      options.progress({ gen, total, probed, step: true });\n      lastProgress = total;\n    }\n    for (let i = 0; i < gen; i++) {\n      for (const a of cache[gen - i - 1] || []) {\n        for (const b of cache[i] || []) {\n          if (total >= options.tries)\n            return { total, probed, gen, ...(options.retain ? { cache } : {}) };\n          if (options.progress && total - lastProgress >= progressInterval) {\n            options.progress({ gen, total, probed, step: false });\n            lastProgress = total;\n          }\n          const term = a.apply(b);\n          const { res, props } = maybeProbe(term);\n\n          if (res > 0)\n            return { expr: term, total, probed, gen, ...(options.retain ? { cache } : {}) };\n          else if (res < 0)\n            continue;\n\n          // if the term is not reducible, it is more likely to be a dead end, so we push it further away\n          const offset = infer\n            ? ((props.expr ? 0 : 3) + (props.dup ? 1 : 0) + (props.proper ? 0 : 1))\n            : 0;\n          if (!cache[gen + offset])\n            cache[gen + offset] = [];\n          cache[gen + offset].push(term);\n        }\n      }\n    }\n  }\n\n  return { total, probed, gen: depth, ...(options.retain ? { cache } : {}) };\n}\n\n/**\n * @desc Recursively replace all instances of Expr in a data structure with\n *       respective string representation using the format() options.\n *       Objects of other types and primitive values are eft as is.\n *\n *       May be useful for debugging or diagnostic output.\n *\n * @experimental\n *\n * @param {any} obj\n * @param {object} [options] - see Expr.format()\n * @returns {any}\n */\nfunction deepFormat (obj, options = {}) {\n  if (obj instanceof Expr)\n    return obj.format(options);\n  if (Array.isArray(obj))\n    return obj.map(deepFormat);\n  if (typeof obj !== 'object' || obj === null || obj.constructor !== Object)\n    return obj;\n\n  // default = plain object\n  const out = {};\n  for (const key in obj)\n    out[key] = deepFormat(obj[key]);\n\n  return out;\n}\n\n/**\n * @desc  Given an expression and a hash of named terms,\n *        return a semicolon-separated string that declares said expression\n *        unambiguously.\n *\n * @example\n * var expr = ski.parse(\"T=CI; V=BCT; V x y\");\n * SKI.extras.declare(expr, expr.context.env);\n * // 'B; C; I; T=CI; V=BC(T); x=; y=; Vx y'\n *\n * @param {Expr} expr\n * @param {{[s: string]: Named}} [env]\n * @returns {string}\n */\nfunction declare (expr, env) {\n  const res = Expr.extras.toposort([expr], env);\n\n  return res.list.map(s => {\n    if (s instanceof Alias)\n      return s.name + '=' + s.impl.format({ inventory: res.env });\n    if (s instanceof FreeVar)\n      return s.name + '=';\n    return s.format({ inventory: res.env });\n  }).join('; ');\n}\n\nmodule.exports = { search, deepFormat, declare };\n", "const { SKI } = require('./src/parser');\nconst { Quest } = require('./src/quest');\nconst extras = require('./src/extras');\n\nSKI.Quest = Quest;\nSKI.extras = { ...extras, ...SKI.classes.Expr.extras };\n\n// SKI_REPL=1 node -r ./index.js\nif (typeof process === 'object' && process.env.SKI_REPL && typeof global !== 'undefined') {\n  global.SKI = SKI;\n  console.log('SKI_REPL activated, try `new SKI();`');\n}\n\n// we're in a browser\nif (typeof window !== 'undefined')\n  window.SKI = SKI;\n\nmodule.exports = { SKI, Quest }; // TODO remove Quest on next breaking release, it's in SKI already!\n", "class Store {\n  constructor (namespace) {\n    this.ns = namespace + ':';\n  }\n\n  save (key, value) {\n    window.localStorage.setItem(this.ns + key, JSON.stringify(value));\n  }\n\n  load (key) {\n    return JSON.parse(window.localStorage.getItem(this.ns + key));\n  }\n\n  scan () {\n    const st = window.localStorage;\n    const out = [];\n    for (let i = 0; i < st.length; i++) {\n      const key = st.key(i);\n      if (key.startsWith(this.ns))\n        out.push(key.substring(this.ns.length));\n    }\n    return out;\n  }\n\n  delete (key) {\n    window.localStorage.removeItem(this.ns + key);\n  }\n}\n\nmodule.exports = { Store };\n", "/**\n *   HTML-related utility functions. Poor man's jquery & react.\n */\n\n'use strict';\n\n/**\n * @desc Locate static elements with specific ids and them as hash.\n * camelCase ids are converted to hyphen-case for aesthetic reason.\n *\n * @param {string} ids\n * @return {{[id: string]: HTMLElement}}\n *\n * @example\n * // given <div id=\"foo-bar\"></div>, grabView('fooBar') will return { fooBar: HTMLDivElement }\n */\nfunction grabView (...ids) {\n  const view = {};\n  for (const name of ids) {\n    const hyphen = name.replace(/[A-Z]/g, char => '-' + char.toLowerCase())\n    view[name] = document.getElementById(hyphen);\n    if (!view[name])\n      throw new Error(`View element not found: ${hyphen}`);\n  }\n  return view;\n}\n\n/**\n * Create a new HTMLElement and append it to parent, if given.\n * @param parent - parent element to append to, or null to create an unattached element\n * @param tagname - tag name of the element to create\n * @param {object} options\n * @param {string[]} [options.class] - array of class names to add\n * @param {string} [options.content] - innerHTML content to set (not escaped whatsoever)\n * @param {boolean} [options.hidden] - whether to set hidden attribute\n * @param {string} [options.color] - color to set for the element\n * @param {(elem: HTMLElement) => void} decorate - do more stuff on element before returning it\n * @return {HTMLElement}\n *\n * @example\n * // create <div class=\"foo bar\" style=\"color: red\">Hello</div> and append to body\n * append(document.body, 'div', { class: ['foo', 'bar'], content: 'Hello', color: 'red' });\n */\nfunction append (parent, tagname, options = {}, decorate = null) {\n  const child = document.createElement(tagname);\n  if (options.class)\n    child.classList.add(...options.class);\n  if (options.content !== undefined)\n    child.innerHTML = '' + options.content;\n  if (options.hidden)\n    child.hidden = true;\n  if (options.color)\n    child.style.color = options.color;\n  if (parent)\n    parent.appendChild(child);\n  if (decorate)\n    decorate(child);\n  return child;\n}\n\n/**\n * Traverse a node tree and call func on each node.\n * @param node\n * @param func\n */\nfunction traverse (node, func) {\n  func(node);\n  for (const child of node.childNodes)\n    traverse(child, func);\n}\n\n/**\n * Escape HTML special characters in a string.\n * @param text\n * @returns {string}\n */\nfunction sanitize (text) {\n  if (typeof text !== 'string')\n    text = '' + text;\n  const escape = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n  };\n  return text.replace(/[<>&]/g, c => escape[c]);\n}\n\n/**\n * URL encode a string.\n * Forces encoding of parentheses because facebook (and possibly others)\n * and some markdown processors don't like raw parentheses in URLs.\n * Also replaces spaces with '+' for beauty.\n * @param s\n * @returns {string}\n */\nfunction encode (s) {\n  // md parser ambiguity compat\n  const parens = {\n    '(': '%28',\n    ')': '%29',\n  }\n  return encodeURIComponent(s)\n    .replace(/[()]/g, c => parens[c])\n    .replace(/%20/g, '+');\n}\nfunction decode (s) {\n  return decodeURIComponent(('' + s).replace(/\\+/g, ' '));\n}\n\nmodule.exports = { append, decode, encode, grabView, sanitize, traverse };\n", "'use strict';\n\nconst { append } = require('./html-util');\n\nclass EvalBox {\n  /**\n   * @desc  Create a visual container that can run SKI code step by step and display the results.\n   *\n   * @param {{\n   *      expr: string | Expr | [string, Expr],\n   *      engine: SKI,\n   *      generator?: function(e:Expr): IterableIterator<{final: boolean, expr: Expr, steps: number}>,\n   *      max?: number,\n   *      height?: number,\n   *      onStop?: function,\n   *      onStart?: function,\n   *      onStep?: function,\n   *      delay?: number,\n   *      id?: number,\n   *      parent?: Element,\n   * }} options\n   */\n  constructor (options = {}) {\n    // logic setup\n    // TODO if expr is given, store it (= was parsed eslewhere)\n    this.options    = options;\n    this.height     = options.height ?? 5;\n    this.running    = false;\n    this.delay      = options.delay ?? 0;\n    this.maxSteps   = options.max ?? Infinity;\n    this.onStart    = options.onStart ?? (() => {});\n    this.onStop     = options.onStop ?? (() => {});\n    this.onStep     = options.onStep ?? (() => {});\n    this.engine     = options.engine;\n    this.format     = options.format ?? { html: true };\n    this.generator  = options.generator ?? (e => e.walk());\n\n    // if given an expr, normalize it\n    this.set(options.expr);\n\n    // view setup\n    this.view = {};\n    this.view.parent  = options.parent;\n    this.view.scroll  = options.scroll ?? options.parent; // containing scrollable element, may != parent\n    this.view.main    = append(options.parent, 'ol', { class: ['ski-eval-box'] });\n  }\n\n  /**\n   * @descr   set this.src and this.expr according to arg, which may be:\n   *          - string: set this.src to arg, this.expr to this.engine.parse(arg)\n   *          - Expr: set this.expr to arg, this.src to arg.format()\n   *          - [src: string, expr: Expr]: set both directly\n   * @param {string|Expr|[src: string, expr: Expr]} arg\n   * @return this\n   */\n  set (arg) {\n    if (typeof arg === 'string') {\n      this.src = arg;\n      this.expr = this.engine.parse(arg);\n    } else if (Array.isArray(arg) && arg.length === 2) {\n      this.src = arg[0];\n      this.expr = arg[1];\n    } else if (!arg) {\n      this.expr = null;\n      this.src = null;\n    } else if (typeof arg === 'object' && typeof arg.format === 'function') {\n      // assume it's an Expr\n      this.expr = arg;\n      this.src = arg.format();\n    } else\n      throw new Error('EvalBox.set() expects a string, Expr, or [string, Expr]');\n\n    return this;\n  }\n\n  /**\n   *\n   * @param {string} [src] Set new source code to run\n   * @return EvalBox this\n   */\n  start (src) {\n    if (this.running)\n      this.stop();\n\n    try {\n      if (src !== undefined)\n        this.set(src);\n      this.seq = this.generator(this.expr);\n    } catch (e) {\n      console.error(e);\n      return this.stop(e.message);\n    }\n    this.view.main.innerHTML = '';\n    this.onStart();\n    this.running = true;\n    this.tick();\n    return this;\n  }\n\n  stop (reason) {\n    this.running = false;\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n    if (reason)\n      this.print(reason, { class: ['ski-eval-error'], line: '' });\n    this.onStop();\n  }\n\n  /**\n   * @desc resume execution after stopping, if the sequence is not finished yet\n   */\n  resume () {\n    if (this.running || !this.seq)\n      return;\n    this.running = true;\n    this.onStart();\n    this.tick();\n  }\n\n  tick () {\n    if (!this.running) return;\n    const { value, done } = this.seq.next();\n    // we're checking both done and value.final because some SKI operations know when they end and some don't\n\n    if (value)\n      this.print(value.expr.format(this.format), { line: value.steps });\n\n    this.onStep(value, done || value.final);\n\n    if (done || value.final) {\n      // could've just used next().done but that creates one extra iteration\n      // finished execution, congratulations\n      if (this.view.last)\n        this.view.last.classList.add('ski-eval-success');\n      this.seq = null; // allow GC + prevent resuming\n      return this.stop();\n    }\n\n    if (value.steps >= this.maxSteps)\n      return this.stop('Max steps reached: ' + this.maxSteps);\n    this.timer = setTimeout(() => this.tick(), this.delay);\n  }\n\n  remove () {\n    if (this.view.parent) {\n      this.view.parent.removeChild(this.view.main);\n      this.view.parent = null;\n    }\n  }\n\n  clear () {\n    this.stop();\n    this.view.main.innerHTML = '';\n  }\n\n  setHeight (height) {\n    this.height = height;\n  }\n\n  print (text, options = {}) {\n    const line = append(this.view.main, 'li', options);\n    if (options.line !== 0 && !options.line)\n      line.style['list-style'] = 'none';\n    else {\n      this.view.main.style['padding-left'] = ('' + options.line).length + 2.5 + 'ch';\n      line.value = options.line;\n    }\n    this.view.last = line;\n\n    if (options.raw)\n      line.innerHTML = text;\n    else {\n      append(line, 'span', {\n        class:   options.class ?? ['ski-eval-line'],\n        color:   options.color,\n        content: (text),\n      });\n\n      while (this.view.main.children.length > this.height)\n        this.view.main.removeChild(this.view.main.firstChild);\n    }\n\n    if (this.view.scroll)\n      this.view.scroll.scrollTop = line.offsetTop;\n\n    return line;\n  }\n}\n\nmodule.exports = { EvalBox };\n", "'use strict';\n\nconst { SKI } = require('../index');\nconst { Store } = require('./store');\nconst { EvalBox } = require('./eval-box');\nconst { append } = require('./html-util')\n\n/**\n * @cssClass ski-quest-box - container for an individual quest, with title, description, input, and result display\n * @cssSelector .ski-quest-box h3 - quest title\n * @cssClass ski-quest-chapter - container for a chapter, with title and intro\n * @cssSelector .ski-quest-chapter h2 - chapter title, click to show/hide content\n * @cssSelector .ski-quest-chapter code - how to display code snippets in quest and chapter intros\n * @cssClass ski-quest-chapter-content - container for quests in a chapter, can be hidden by clicking chapter title\n * @cssClass ski-quest-chapter-intro - chapter introduction text\n * @cssClass ski-quest-comment - comments, make them fainter or something\n * @cssClass ski-quest-progressbar - a progress bar in the chapter list, showing how much of the chapter is solved\n *           Set background [color], and don't touch margin/padding which are adjusted by quest code\n * @cssClass ski-quest-control - for controls in the result display, like \"show steps\"\n * @cssClass ski-quest-display - results of a quest solution attempt\n * @cssClass ski-quest-error\n * @cssClass ski-quest-float-right\n * @cssClass ski-quest-hint - a self-revealing spoiler\n * @cssClass ski-quest-nav - container for chapter navigation.\n * @cssClass ski-quest-nav-item - individual chapter links inside ski-quest-nav.\n * @cssClass ski-quest-intro - introduction text in individual quests\n * @cssClass ski-quest-inventory - element containing all unlocked terms\n * @cssClass ski-quest-label - label for an input field\n * @cssClass ski-quest-input - container for input elements\n * @cssSelector .ski-quest-input input[type=\"text\"] - input fields for quest solutions\n * @cssSelector .ski-quest-input button - button to submit quest solution\n * @cssClass ski-quest-term-def\n * @cssClass ski-quest-term-name\n */\n\nclass QuestPage {\n  /**\n   * @desc  A collection of combinatory logic quests organized into chapters\n   *        and attached to specific elements for display.\n   *\n   *        Quest progress is saved in the localStorage under a given prefix.\n   *\n   *        The engine is also saved and loaded from the store,\n   *        so that unlocked terms persist across sessions and can be used in later quests.\n   *\n   * @param {{\n   *   index: string, // URL to fetch quest list from\n   *   baseUrl?: string, // root URL to fetch quest data from, default 'data/quests/'\n   *   storePrefix?: string, // prefix for localStorage keys, required unless 'store' object itself is provided\n   *   // page elements to attach to:\n   *   indexBox: HTMLElement, // element to attach chapter list to\n   *   contentBox: HTMLElement, // element to attach chapter content to\n   *   inventoryBox: HTMLElement, // element to attach inventory to\n   *   // extra stuff\n   *   linkedTo?: string, // id of element to scroll into view after loading\n   *   store: Store, // TODO move out into callbacks, also make async\n   *   engine?: SKI, // defautl = new SKI()\n   *   onLoad?: function, // callback for when quests are loaded, gets list of QuestChapter objects as argument\n   *   onSolved?: function, // callback for when a quest is solved\n   *   onFailed?: function, // callback for when a quest is attempted but not solved\n   *   onUnlock?: function, // callback for when a quest is solved and unlocks something in the engine\n   *   chapterList?: QuestChapter[], // optional write-only list for observability only\n   * }} options\n   */\n  constructor (options) {\n    this.view = {};\n    this.root = options.baseUrl ?? '.';\n\n    if (!options.store && !options.storePrefix)\n      throw new Error('No storePrefix provided');\n    this.store = options.store ?? new Store(options.storePrefix);\n    this.engine = options.engine ?? new SKI(this.store.load('engine') ?? { annotate: true, allow: 'SKI' });\n\n    if (options.inventoryBox) {\n      this.view.inventory = options.inventoryBox;\n      this.showKnown();\n    }\n    this.view.content = options.contentBox;\n    if (options.indexBox)\n      this.view.index = append(options.indexBox, 'div', { class: ['ski-quest-nav'] });\n\n    this._onSolved = options.onSolved;\n    this._onFailed = options.onFailed;\n    this._onUnlock = options.onUnlock;\n\n    this.chapters = [];\n  }\n\n  /**\n   * @desc Load quest list from given index URL, then load and draw chapters.\n   * @param {string} index URL to fetch the quest list from\n   * @param {string} [linkedTo] id of quest to scroll into view after loading, if matches\n   * @param {function} onLoad callback for when quests are loaded, gets self as argument\n   */\n  loadFromIndex (index, linkedTo, onLoad) {\n    // TODO update this.root based on index URL\n    fetch(this.mkLink(index))\n      .then(resp => resp.json())\n      .then(list => this.loadChapters(list))\n      .then(self => {\n        if (onLoad)\n          onLoad(self);\n        if (linkedTo) {\n          const target = document.getElementById(linkedTo);\n          if (target)\n            target.scrollIntoView();\n        }\n      });\n  }\n\n  /**\n   * @desc Load and draw chapters from a given list of chapter specs.\n   * @param list\n   * @returns {Promise<QuestPage>}\n   */\n  async loadChapters (list) {\n    let chapterId = 0;\n    this.chapters = [];\n    const joint = [];\n    for (const item of list) {\n      // TODO if item is an object, skip fetch and use it directly, returning `resolve`\n      const chapter = new QuestChapter({\n        number:   ++chapterId,\n        link:     this.mkLink(item),\n        engine:   this.engine,\n        store:    this.store,\n        onUnlock: x => this.onUnlock(x),\n        onSolved: x => this._onSolved(x),\n        onFailed: x => this._onFailed(x),\n      });\n      this.chapters.push(chapter);\n      chapter.attach(this.view.content, { placeholder: 'loading chapter' + chapter.number + '...' });\n      if (this.view.index)\n        chapter.addLink(this.view.index);\n      joint.push(chapter.fetch().then(chapter => {\n        chapter.draw();\n      }));\n    }\n    return Promise.all(joint).then(() => this);\n  }\n\n  mkLink (str) {\n    return (str.match(/^\\w+:\\/\\//) || str.match(/^[/.]/)) ? str : this.root + '/' + str;\n  }\n\n  onUnlock (term) {\n    this.engine.maybeAdd(term.name, term.impl);\n    if (this.store)\n      this.store.save('engine', this.engine);\n    this.showKnown();\n    if (this._onUnlock)\n      this._onUnlock(term);\n  }\n\n  showKnown () {\n    if (!this.view.inventory)\n      return;\n    this.view.inventory.innerHTML = '';\n    const ul = append(this.view.inventory, 'ul', {class: ['ski-quest-inventory'] });\n    const terms = this.engine.getTerms();\n    for (const entry of Object.keys(terms).sort().map(x => [x, terms[x]])) {\n      const li = append(ul, 'li', {}, e => {\n        e.dataset.skiTerm = entry[0];\n      });\n      append(li, 'span', { content: entry[0], class: ['ski-quest-term-name'] });\n      append(li, 'span', { content: ': ' });\n      append(li, 'span', { content: showTerm(entry[1]), class: ['ski-quest-term-def'] });\n    }\n  }\n\n  demolish () {\n    for (const key of this.store.scan())\n      this.store.delete(key);\n\n    // TODO reset engine, chapters, and quest boxes\n  }\n}\n\nclass QuestBox {\n  /**\n   * @desc Create a quest box with given spec and options\n   * @param {QuestSpec} spec\n   * @param {{\n   *   engine?: SKI,\n   *   chapter?: QuestChapter,\n   *   number?: number,\n   *   store?: Store,\n   * }}options\n   */\n  constructor (spec, options) {\n    const engine = options.engine ?? (options.chapter?.engine);\n    if (!engine)\n      throw new Error('QuestBox requires an engine: SKI in either options or chapter');\n    const store = options.store ?? options.chapter?.store;\n    if (!store)\n      throw new Error('QuestBox requires a store: Store in either options or chapter');\n    this.impl = new SKI.Quest({ ...spec, engine });\n    this.name = this.impl.id ? 'quest-' + this.impl.id : '';\n    this.chapter = options.chapter;\n    if (this.chapter && options.number)\n      this.number = this.chapter.number + '.' + options.number;\n    this.store = store;\n    this.engine = engine;\n    this.view = {};\n    this.input = [];\n  }\n\n  load () {\n    const data = this.store.load(this.name) ?? {};\n    this.status = {\n      solved:   data.solved ?? false,\n      steps:    data.steps ?? 0,\n      attempts: data.attempts ?? 0,\n      weight:   data.weight ?? 0,\n      total:    data.total ?? 0,\n    };\n    if (this.status.solved)\n      this.onSolved();\n    return this;\n  }\n\n  save () {\n    this.store.save(this.name, this.status);\n    return this;\n  }\n\n  update (result) {\n    if (this.status.solved)\n      return;\n    this.status.attempts++;\n    this.status.total += result.steps;\n    this.status.steps = result.steps;\n    this.status.weight = result.weight;\n    if (result.pass) {\n      this.status.solved = true;\n      this.onSolved(result);\n    }\n    this.save();\n    this.showStatus();\n  }\n\n  onSolved (result) {\n    if (this.impl.meta.unlock && result) {\n      const term = new SKI.classes.Alias(this.impl.meta.unlock, result.expr.expand());\n      this.chapter?.onUnlock(term);\n    }\n    if (this.chapter)\n      this.chapter.addSolved(this.impl.id);\n  }\n\n  check () {\n    if (this.view.display)\n      this.view.display.innerHTML = 'running...';\n    const got = this.input.map(x => x.value);\n    const result = this.impl.check(...got);\n    this.showResult(result);\n    this.update(result);\n  }\n\n  draw (element) {\n    this.view.frame = append(element, 'div', { class: ['ski-quest-box'] });\n    this.view.frame.id = this.name;\n\n    const title = append(this.view.frame, 'h3');\n    const body = append(this.view.frame, 'div');\n    const expand = append(title, 'a', { content: this.number ? '#' + this.number + '' : 'Quest' });\n    expand.href = '#' + this.name;\n    expand.onclick = () => showhide(body, true);\n\n    append(title, 'span', { content: ' ' + this.impl.name });\n    const allowed = this.impl.allowed();\n    if (allowed)\n      append(title, 'span', { content: ' [' + allowed + ']' });\n    this.view.stat = append(title, 'span', { class: ['ski-quest-float-right'] });\n\n    const descr = append(body, 'div');\n    append(descr, 'div', { content: cat(this.impl.intro), class: ['ski-quest-intro'] });\n    if (this.impl.meta.hint)\n      hint(descr, ' Hint:...', ' Hint: ' + this.impl.meta.hint);\n\n    this.view.display = append(body, 'div', { class: ['ski-quest-display'], content: '.....' });\n\n    this.view.solution = append(body, 'div', { class: ['ski-quest-input'] });\n\n    this.drawInput(this.view.solution);\n\n    this.showStatus();\n  }\n\n  drawInput (element) {\n    const spec = this.impl.input;\n    const multi = spec.length !== 1;\n\n    for (const item of spec) {\n      if (multi) {\n        const label = append(element, 'div', { class: ['ski-quest-label'] });\n        append(label, 'b', { content: item.name });\n        if (item.note)\n          append(label, 'span', { content: ' // ' + item.note, class: ['ski-quest-comment'] });\n      }\n      const input = append(element, 'input');\n      input.type = 'text';\n      input.onkeydown = e => {\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          this.check();\n        }\n      };\n      this.input.push(input);\n      append(element, 'br');\n    }\n\n    const btn = append(element, 'button', { content: 'solve!' });\n    btn.onclick = () => this.check();\n  }\n\n  showStatus () {\n    if (!this.view.stat)\n      return;\n    if (this.status.attempts) {\n      const tries = 'in ' + this.status.attempts + (this.status.attempts === 1 ? ' try' : ' tries');\n      const steps = this.status.solved\n        ? '&check; ' + this.status.steps + ' steps/' + this.status.weight + ' terms '\n        : this.status.total + ' total steps ';\n      this.view.stat.innerHTML = steps + ' ' + tries;\n    }\n  }\n\n  /**\n   *\n   * @param {QuestResult} result\n   */\n  showResult (result) {\n    if (!this.view.display)\n      return;\n    this.view.display.innerHTML = '';\n    const echo = append(this.view.display, 'div');\n    append(echo, 'span', { content: 'Your solution: ' + expand(result.expr) + ' ' });\n\n    if (result.exception)\n      append(this.view.display, 'div', { class: ['ski-quest-error'], content: 'Execution failed: ' + result.exception });\n\n    for (const item of result.details) {\n      const line = append(this.view.display, 'div', { class: item.pass ? ['ski-quest-success'] : ['ski-quest-error'] });\n      append(line, 'span', { content: item.pass ? '&check; ' : '&cross; ' });\n      append(line, 'span', { content: `${item.start} &rarr; ${item.found} ` });\n      const showSteps = append(line, 'a', { content: `in ${item.steps} steps`, class: ['ski-quest-control'] });\n      append(line, 'span', { content: ' ' });\n      const hideSteps = append(line, 'a', { content: ' (hide)', class: ['ski-quest-control'], hidden: true });\n\n      if (!item.pass) {\n        append(line, 'br');\n        if (item.expected !== undefined) {\n          append(line, 'span', { content: '&nbsp;&nbsp;' + 'expected: ' + item.expected });\n          append(line, 'br');\n        }\n        if (item.reason) {\n          append(line, 'span', { content: '&nbsp;&nbsp;' + item.reason });\n          append(line, 'br');\n        }\n      }\n      // replay specific test case via EvalBox\n      const termDiv = append(line, 'div', {});\n      showSteps.onclick = () => {\n        termDiv.innerHTML = '';\n        hideSteps.hidden = false;\n        const box = new EvalBox({ parent: termDiv, engine: this.engine, height: Infinity, max: item.steps + 2, headless: true });\n        box.start(item.start);\n      };\n      hideSteps.onclick = () => {\n        termDiv.innerHTML = '';\n        hideSteps.hidden = true;\n      };\n    }\n  }\n}\n\nclass QuestChapter {\n  /**\n   * @desc A collection of quests, typically related,\n   *       with a title and intro text. Optionally numbered, too.\n   * @param {{\n   *   name?: string,\n   *   intro?: string|string[],\n   *   link: string, // URL to fetch quest list from\n   *   number?: number,\n   *   engine: SKI,\n   *   store: Store,\n   *   onUnlock?: function, // callback for when a quest is solved and unlocks something in the engine\n   * }}options\n   */\n  constructor (options) {\n    this.options = options;\n    this.quests = [];\n    this.solved = new Set();\n    this.view = {};\n    this.number = options.number ?? 0;\n    this.engine = options.engine;\n    this.store = options.store;\n    this.onUnlock = options.onUnlock ?? (() => {});\n    this.updateMeta();\n  }\n\n  updateMeta (meta = {}) {\n    this.options = { ...this.options, ...meta };\n    this.id = 'chapter-' + (meta.id ?? this.number);\n    if (this.view.frame)\n      this.view.frame.id = this.id;\n    if (this.view.link)\n      this.view.link.href = '#' + this.id;\n    if (this.options.name && this.view.linkText)\n      this.view.linkText.innerHTML = 'Chapter ' + this.number + ': ' + this.options.name;\n  }\n\n  fetch () {\n    return fetch(this.options.link)\n      .then( resp => resp.json() )\n      .then(data => {\n        if (Array.isArray(data))\n          data = { content: data };\n        if (!Array.isArray(data.content))\n          throw new Error('Invalid quest list in ' + this.options.link);\n\n        this.updateMeta(data);\n\n        let k = 0;\n        for (const item of data.content)\n          this.quests.push(new QuestBox(item, { chapter: this, number: ++k }));\n\n        return this;\n      });\n  }\n\n  addSolved (questId) {\n    if (this.solved.has(questId))\n      return;\n    this.solved.add(questId);\n    this.showStatus();\n  }\n\n  getProgress () {\n    return {\n      total:      this.quests.length,\n      solved:     this.solved.size,\n      complete:   this.solved.size === this.quests.length,\n      percentage: Math.round(this.solved.size / this.quests.length * 100),\n    }\n  }\n\n  attach (element, options) {\n    this.view.frame = append(element, 'div', { class: ['ski-quest-chapter'] });\n    this.view.frame.id = this.id;\n\n    if (options.placeholder)\n      this.view.placeholder = append(this.view.frame, 'div', { content: options.placeholder });\n    return this;\n  }\n\n  draw () {\n    this.visible = true;\n    this.view.placeholder?.remove();\n    const title = append(this.view.frame, 'h2');\n    const body = append(this.view.frame, 'div');\n    append(title, 'span', { content: 'Chapter ' + this.number + ': ' + this.options.name });\n    this.view.stat = append(title, 'span', { class: ['ski-quest-float-right'] });\n    title.onclick = () => { showhide(body, this.visible = !this.visible) };\n\n    this.view.intro = append(body, 'div', { content: cat(this.options.intro), class: ['ski-quest-note', 'ski-quest-chapter-intro'] });\n    this.view.content = append(body, 'div', { class: ['ski-quest-chapter-content'] });\n\n    for (const quest of this.quests) {\n      quest.load();\n      quest.draw(this.view.content);\n    }\n\n    this.showStatus();\n  }\n\n  showStatus () {\n    if (!this.view.stat)\n      return;\n    const progress = this.getProgress();\n    this.view.stat.innerHTML = 'Progress: ' + progress.solved + '/' + progress.total + ' (' + progress.percentage + '%)';\n    if (progress.complete)\n      this.view.stat.classList.add('success');\n    if (this.view.progressbar) {\n      this.view.progressbar.style.paddingRight = progress.percentage + '%';\n      this.view.progressbar.style.marginRight = -progress.percentage + '%';\n    }\n  }\n\n  addLink (element) {\n    // create an extra wrapper to allow messing with link's layout w/o interfering with the progress bar inside it\n    const wrapper = append(element, 'div', { class: ['ski-quest-nav-item'] });\n    const link = append(wrapper, 'a', {}, e => {\n      e.style.display = 'flex'; // force flex for progress bar to work, don't rely on css\n    });\n    link.href = '#' + this.id;\n    this.view.link = link;\n    this.view.progressbar = append(link, 'span', { class: ['ski-quest-progressbar'] });\n    this.view.linkText = append(link, 'span', { content: 'Chapter ' + this.number + '...' });\n  }\n\n  // TODO hide solved chapters\n}\n\n/**\n * @desc Create a self-revealing spoiler\n * @param element\n * @param shown\n * @param hidden\n */\n\nfunction hint (element, shown, hidden) {\n  const container = append(element, 'span', {});\n  const clickme = append(container, 'span', { content: shown, class: ['ski-quest-hint'] });\n  clickme.onclick = () => {\n    clickme.remove();\n    append(container, 'span', { content: hidden });\n  };\n}\n\n/**\n * @desc Coerce array of strings to string\n * @param {string[]|string|number} input\n * @return {string}\n */\nfunction cat (input) {\n  if (Array.isArray(input))\n    return input.join(' ');\n  else\n    return '' + input;\n}\n\nfunction expand (expr) {\n  return expr instanceof SKI.classes.Expr\n    ? (\n      expr instanceof SKI.classes.Alias\n        ? expr.name + ' = ' + expr.expand()\n        : '' + expr.expand()\n    )\n    : '' + expr;\n}\n\nfunction showhide (element, show) {\n  if (show === undefined)\n    show = element.hidden;\n  element.hidden = !show;\n}\n\nfunction showTerm (term) {\n  return term.note ?? (term.impl ?? term).format({ html: true, lambda: ['', ' &mapsto; ', ''] });\n}\n\nmodule.exports = { QuestPage, QuestChapter, QuestBox };\n", "'use strict';\n\nconst { QuestBox, QuestChapter, QuestPage } = require('./quest');\n\nif (typeof window !== 'undefined') {\n  window.QuestBox = QuestBox;\n  window.QuestChapter = QuestChapter;\n  window.QuestPage = QuestPage;\n}"],
  "mappings": "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",
  "names": ["require_internal", "__commonJSMin", "exports", "module", "Tokenizer", "terms", "src", "a", "b", "str", "list", "last", "x", "tokRestrict", "restrict", "set", "spec", "out", "act", "sym", "mode", "TraverseControl", "value", "decoration", "unwrap", "prepareWrapper", "label", "fun", "require_expr", "__commonJSMin", "exports", "module", "unwrap", "prepareWrapper", "DEFAULTS", "control", "Expr", "_Expr", "args", "expr", "arg", "App", "e", "Alias", "FreeVar", "change", "_", "action", "prev", "predicate", "initial", "combine", "value", "options", "max", "maxArgs", "preArgs", "steps", "maybeLambda", "next", "push", "nthvar", "Lambda", "guess", "simplifyLambda", "opt", "final", "search", "replace", "other", "swap", "expected", "comment", "diff", "poorMans", "first", "fallback", "nargs", "rec", "indent", "s", "_App", "fun", "proxy", "list", "discard", "duplicate", "out", "term", "fAction", "aAction", "fValue", "aValue", "partial", "wrap", "Named", "_Named", "name", "freeId", "_FreeVar", "scope", "lhs", "rhs", "Native", "impl", "native", "canon", "addNative", "_Lambda", "my", "tail", "known", "last", "local", "iAction", "iValue", "t", "Church", "_Church", "n", "x", "y", "waitn", "z", "f", "caps", "count", "proper", "index", "a", "skip", "dup", "i", "state", "maxWeight", "candidate", "toposort", "env", "k", "item", "seen", "acc", "require_parser", "__commonJSMin", "exports", "module", "Tokenizer", "restrict", "classes", "Expr", "Named", "Native", "Alias", "FreeVar", "Lambda", "Church", "native", "Empty", "args", "PartialLambda", "_PartialLambda", "term", "known", "tail", "postParse", "expr", "combChars", "SKI", "_SKI", "options", "name", "impl", "note", "guess", "list", "item", "m", "spec", "out", "prevShort", "nextShort", "env", "needDetour", "i", "temp", "detour", "rework", "e", "newAlias", "source", "lines", "s", "jar", "def", "aliased", "opt", "tokens", "empty", "stack", "context", "c", "x", "f", "scope", "cache", "target", "n", "require_quest", "__commonJSMin", "exports", "module", "SKI", "Expr", "FreeVar", "Alias", "Lambda", "Quest", "options", "input", "cases", "allow", "numbers", "lambdas", "engine", "engineFull", "meta", "env", "jar", "term", "expr", "list2str", "c", "opt", "terms", "t", "PropertyCase", "ExprCase", "weight", "prepared", "spec", "impl", "arsenal", "a", "e", "details", "pass", "acc", "val", "steps", "findings", "solCheck", "dataset", "accepted", "rejected", "ret", "result", "field", "found", "checkHtml", "date", "Case", "src", "Subst", "s", "args", "e1", "r1", "r2", "reason", "knownCaps", "unknown", "start", "r", "guess", "cap", "list", "i", "Group", "id", "checkId", "q", "str", "seen", "tagStack", "tagRegex", "match", "fullTag", "tagName", "require_extras", "__commonJSMin", "exports", "module", "Expr", "Alias", "FreeVar", "search", "seed", "options", "predicate", "depth", "infer", "progressInterval", "hasSeen", "cache", "total", "probed", "seen", "maybeProbe", "term", "props", "res", "lastProgress", "gen", "i", "a", "b", "offset", "deepFormat", "obj", "out", "key", "declare", "expr", "env", "require_index", "__commonJSMin", "exports", "module", "SKI", "Quest", "extras", "require_store", "__commonJSMin", "exports", "module", "Store", "namespace", "key", "value", "st", "out", "i", "require_html_util", "__commonJSMin", "exports", "module", "grabView", "ids", "view", "name", "hyphen", "char", "append", "parent", "tagname", "options", "decorate", "child", "traverse", "node", "func", "sanitize", "text", "escape", "c", "encode", "s", "parens", "decode", "require_eval_box", "__commonJSMin", "exports", "module", "append", "EvalBox", "options", "arg", "src", "reason", "value", "done", "height", "text", "line", "require_quest", "__commonJSMin", "exports", "module", "SKI", "Store", "EvalBox", "append", "QuestPage", "options", "index", "linkedTo", "onLoad", "resp", "list", "self", "target", "chapterId", "joint", "item", "chapter", "QuestChapter", "x", "str", "term", "ul", "terms", "entry", "li", "e", "showTerm", "key", "QuestBox", "spec", "engine", "store", "data", "result", "got", "element", "title", "body", "expand", "showhide", "allowed", "descr", "cat", "hint", "multi", "label", "input", "btn", "tries", "steps", "echo", "line", "showSteps", "hideSteps", "termDiv", "meta", "k", "questId", "quest", "progress", "wrapper", "link", "shown", "hidden", "container", "clickme", "expr", "show", "require_index_quest", "__commonJSMin", "QuestBox", "QuestChapter", "QuestPage"]
}
