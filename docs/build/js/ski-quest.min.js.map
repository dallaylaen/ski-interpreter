{
  "version": 3,
  "sources": ["../../../src/internal.js", "../../../src/expr.js", "../../../src/parser.js", "../../../src/quest.js", "../../../src/extras.js", "../../../index.js", "../../../site-src/store.js", "../../../site-src/html-util.js", "../../../site-src/eval-box.js", "../../../site-src/quest.js", "../../../site-src/index-quest.js"],
  "sourcesContent": ["class Tokenizer {\n  /**\n   * @desc Create a tokenizer that splits strings into tokens according to the given terms.\n   * The terms are interpreted as regular expressions, and are sorted by length\n   * to ensure that longer matches are preferred over shorter ones.\n   * @param {...string|RegExp} terms\n   */\n  constructor (...terms) {\n    const src = '$|(\\\\s+)|' + terms\n      .map(s => '(?:' + s + ')')\n      .sort((a, b) => b.length - a.length)\n      .join('|');\n    this.rex = new RegExp(src, 'gys');\n  }\n\n  /**\n   * @desc Split the given string into tokens according to the terms specified in the constructor.\n   * @param {string} str\n   * @return {string[]}\n   */\n  split (str) {\n    this.rex.lastIndex = 0;\n    const list = [...str.matchAll(this.rex)];\n\n    // did we parse everything?\n    const eol = list.pop();\n    const last = eol?.index ?? 0;\n\n    if (last !== str.length) {\n      throw new Error('Unknown tokens at pos ' + last + '/' + str.length\n                + ' starting with ' + str.substring(last));\n    }\n\n    // skip whitespace\n    return list.filter(x => x[1] === undefined).map(x => x[0]);\n  }\n}\n\nconst tokRestrict = new Tokenizer('[-=+]', '[A-Z]', '\\\\b[a-z_][a-z_0-9]*\\\\b');\n\n/**\n * @desc Add ot remove tokens from a set according to a spec string.\n * The spec string is a sequence of tokens, with each group optionally prefixed\n * by one of the operators '=', '+', or '-'.\n * The '=' operator resets the set to contain only the following token(s).\n * @param {Set<string>} set\n * @param {string} [spec]\n * @returns {Set<string>}\n */\nfunction restrict (set, spec) {\n  if (!spec)\n    return set;\n  let out = new Set([...set]);\n  const act = {\n    '=': sym => { out = new Set([sym]); mode = '+'; },\n    '+': sym => { out.add(sym); },\n    '-': sym => { out.delete(sym); },\n  };\n\n  let mode = '=';\n  for (const sym of tokRestrict.split(spec)) {\n    if (act[sym])\n      mode = sym;\n    else\n      act[mode](sym);\n  }\n  return out;\n}\n\nclass TraverseControl {\n  /**\n   * @desc A wrapper for values returned by fold/traverse callbacks\n   *       which instructs the traversal to alter its behavior while\n   *       retaining the value in question.\n   *\n   *       This class is instantiated internally be `SKI.control.*` functions,\n   *       and is not intended to be used directly by client code.\n   *\n   * @template T\n   * @param {T} value\n   * @param {function(T): TraverseControl<T>} decoration\n   */\n  constructor (value, decoration) {\n    this.value = value;\n    this.decoration = decoration;\n  }\n}\n\n/**\n * @private\n * @template T\n * @param {T|TraverseControl<T>|null} value\n * @returns {[T?, function|undefined]}\n */\nfunction unwrap (value) {\n  // `?? undefined` so that null is not 'an object'\n  if (value instanceof TraverseControl)\n    return [value.value ?? undefined, value.decoration];\n  return [value ?? undefined, undefined];\n}\n\n/**\n * @desc Prepare a self-referencing wrapper function for use as a fold/traverse control decorator.\n *\n *       If `fun` is created by `prepareWrapper`, then\n *       unwrap(fun(x)) will always return exactly [x, fun], and the second value can be checked with ===.\n *\n *       An optional label can be provided for debugging purposes.\n *\n * @private\n * @template T\n * @param {string} [label]\n * @returns {function(T): TraverseControl<T>}\n */\nfunction prepareWrapper (label) {\n  const fun = value => new TraverseControl(value, fun);\n  fun.label = label;\n  fun.toString = () => 'TraverseControl::' + label;\n  return fun;\n}\n\nmodule.exports = { Tokenizer, restrict, unwrap, prepareWrapper };\n", "'use strict';\n\nconst { unwrap, prepareWrapper } = require('./internal');\n\nconst DEFAULTS = {\n  max:     1000,\n  maxArgs: 32,\n};\n\n/**\n * @template T\n * @typedef {T | TraverseControl<T> | null} TraverseValue\n */\n/**\n * @desc Control primitives for fold() and traverse() methods.\n * @template T\n * @type {{[name: string]: function(T): TraverseControl<T>}}\n */\nconst control = {\n  descend: prepareWrapper('descend'),\n  prune:   prepareWrapper('prune'),\n  redo:    prepareWrapper('redo'),\n  stop:    prepareWrapper('stop'),\n};\n\n/**\n * @typedef {Expr | function(Expr): Partial} Partial\n */\n\nclass Expr {\n  /**\n   *  @descr A combinatory logic expression.\n   *\n   *  Applications, variables, and other terms like combinators per se\n   *  are subclasses of this class.\n   *\n   *  @abstract\n   *  @property {{\n   *    scope?: any,\n   *    env?: { [key: string]: Expr },\n   *    src?: string,\n   *    parser: object,\n   *  }} [context]\n   */\n  constructor () {\n    if (new.target === Expr)\n      throw new Error('Attempt to instantiate abstract class Expr');\n  }\n\n  /**\n   * @desc apply self to zero or more terms and return the resulting term,\n   * without performing any calculations whatsoever\n   * @param {Expr} args\n   * @return {Expr}\n   */\n  apply (...args) {\n    let expr = this;\n    for (const arg of args)\n      expr = new App(expr, arg);\n    return expr;\n  }\n\n  /**\n   * @desc Replace all aliases in the expression with their definitions, recursively.\n   * @return {Expr}\n   */\n  expand () {\n    return this.traverse(e => {\n      if (e instanceof Alias)\n        return e.impl.expand();\n    }) ?? this;\n  }\n\n  /**\n   * @desc Returns true if the expression contains only free variables and applications, false otherwise.\n   * @returns {boolean}\n   */\n  freeOnly () {\n    return !this.any(e => !(e instanceof FreeVar || e instanceof App));\n  }\n\n  /**\n   * @desc Traverse the expression tree, applying change() to each node.\n   *       If change() returns an Expr, the node is replaced with that value.\n   *       Otherwise, the node is descended further (if applicable)\n   *       or left unchanged.\n   *\n   *       The traversal order is leftmost-outermost (LO), i.e. the same order as reduction steps are taken.\n   *\n   *       Returns null if no changes were made, or the new expression otherwise.\n   *\n   * @param {(e:Expr) => (Expr|null)} change\n   * @returns {Expr|null}\n   */\n  traverse (change) {\n    return change(this);\n  }\n\n  /**\n   * @desc Returns true if predicate() is true for any subterm of the expression, false otherwise.\n   *\n   * @param {(e: Expr) => boolean} predicate\n   * @returns {boolean}\n   */\n  any (predicate) {\n    return predicate(this);\n  }\n\n  /**\n   * @desc Fold the expression into a single value by recursively applying combine() to its subterms.\n   *       Nodes are traversed in leftmost-outermost order, i.e. the same order as reduction steps are taken.\n   *\n   * null or undefined return value from combine() means \"keep current value and descend further\".\n   *\n   * SKI.control provides primitives to control the folding flow:\n   *  - SKI.control.prune(value) means \"use value and don't descend further into this branch\";\n   *  - SKI.control.stop(value) means \"stop folding immediately and return value\".\n   *  - SKI.control.descend(value) is the default behavior, meaning \"use value and descend further\".\n   *\n   * This method is experimental and may change in the future.\n   *\n   * @experimental\n   * @template T\n   * @param {T} initial\n   * @param {(acc: T, expr: Expr) => TraverseValue<T>} combine\n   * @returns {T}\n   */\n  fold (initial, combine) {\n    const [value, _] = unwrap(this._fold(initial, combine));\n    return value ?? initial;\n  }\n\n  /**\n   * @template T\n   * @param {T} initial\n   * @param {(acc: T, expr: Expr) => TraverseValue<T>} combine\n   * @returns {TraverseValue<T>}\n   * @private\n   */\n  _fold (initial, combine) {\n    return combine(initial, this);\n  }\n\n  /**\n   * @desc rough estimate of the term's complexity\n   * @return {number}\n   */\n  weight () {\n    return 1;\n  }\n\n  /**\n   * @desc Try to empirically find an equivalent lambda term for the expression,\n   *       returning also the term's arity and some other properties.\n   *\n   *       This is used internally when declaring a Native / Alias term,\n   *       unless {canonize: false} is used.\n   *\n   *       As of current it only recognizes terms that have a normal form,\n   *       perhaps after adding some variables. This may change in the future.\n   *\n   *       Use toLambda() if you want to get a lambda term in any case.\n   *\n   * @param {{max?: number, maxArgs?: number}} options\n   * @return {{\n   *    normal: boolean,\n   *    steps: number,\n   *    expr?: Expr,\n   *    arity?: number,\n   *    proper?: boolean,\n   *    discard?: boolean,\n   *    duplicate?: boolean,\n   *    skip?: Set<number>,\n   *    dup?: Set<number>,\n   * }}\n   */\n  infer (options = {}) {\n    const max = options.max ?? DEFAULTS.max;\n    const maxArgs = options.maxArgs ?? DEFAULTS.maxArgs;\n    const out = this._infer({ max, maxArgs, index: 0 });\n    return out;\n  }\n\n  /**\n   *\n   * @param {{max: number, maxArgs: number, index: number}} options\n   * @param {FreeVar[]} preArgs\n   * @param {number} steps\n   * @returns {{\n   *    normal: boolean,\n   *    steps: number,\n   *    expr?: Expr,\n   *    arity?: number,\n   *    skip?: Set<number>,\n   *    dup?: Set<number>,\n   *    duplicate, discard, proper: boolean\n   * }\n   * @private\n   */\n  _infer (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs || steps > options.max)\n      return { normal: false, steps };\n\n    // happy case\n    if (this.freeOnly()) {\n      return {\n        normal: true,\n        steps,\n        ...maybeLambda(preArgs, this),\n      };\n    }\n\n    // try reaching the normal form\n    const next = this.run({ max: (options.max - steps) / 3 });\n    steps += next.steps;\n    if (!next.final)\n      return { normal: false, steps };\n\n    // normal form != this, redo exercise\n    if (next.steps !== 0)\n      return next.expr._infer(options, preArgs, steps);\n\n    // adding more args won't help, bail out\n    // if we're an App, the App's _infer will take care of further args\n    if (this.unroll()[0] instanceof FreeVar)\n      return { normal: false, steps };\n\n    // try adding more arguments, maybe we'll get a normal form then\n    const push = nthvar(preArgs.length + options.index);\n    return this.apply(push)._infer(options, [...preArgs, push], steps);\n  }\n\n  /**\n   * @desc Expand an expression into a list of terms\n   * that give the initial expression when applied from left to right:\n   * ((a, b), (c, d)) => [a, b, (c, d)]\n   *\n   * This can be thought of as an opposite of apply:\n   * fun.apply(...arg).unroll() is exactly [fun, ...args]\n   * (even if ...arg is in fact empty).\n   *\n   * @returns {Expr[]}\n   */\n  unroll () {\n    // currently only used by infer() but may be useful\n    // to convert binary App trees to n-ary or smth\n    return [this];\n  }\n\n  /**\n   * @desc Returns a series of lambda terms equivalent to the given expression,\n   *       up to the provided computation steps limit,\n   *       in decreasing weight order.\n   *\n   *       Unlike infer(), this method will always return something,\n   *       even if the expression has no normal form.\n   *\n   *       See also Expr.walk() and Expr.toSKI().\n   *\n   * @param {{\n   *   max?: number,\n   *   maxArgs?: number,\n   *   varGen?: function(void): FreeVar,\n   *   steps?: number,\n   *   html?: boolean,\n   *   latin?: number,\n   * }} options\n   * @param {number} [maxWeight] - maximum allowed weight of terms in the sequence\n   * @return {IterableIterator<{expr: Expr, steps?: number, comment?: string}>}\n   */\n  * toLambda (options = {}) {\n    const expr = this.traverse(e => {\n      if (e instanceof FreeVar || e instanceof App || e instanceof Lambda || e instanceof Alias)\n        return null; // no change\n      const guess = e.infer({ max: options.max, maxArgs: options.maxArgs });\n      if (!guess.normal)\n        throw new Error('Failed to infer an equivalent  lambda term for ' + e);\n      return guess.expr;\n    }) ?? this;\n    yield * simplifyLambda(expr, options);\n  }\n\n  /**\n   * @desc Rewrite the expression into S, K, and I combinators step by step.\n   *     Returns an iterator yielding the intermediate expressions,\n   *     along with the number of steps taken to reach them.\n   *\n   *     See also Expr.walk() and Expr.toLambda().\n   *\n   * @param {{max?: number}} [options]\n   * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}\n   */\n  * toSKI (options = {}) {\n    // TODO options.max is not actually max, it's the number of steps in one iteration\n    let steps = 0;\n    let expr = this;\n    while (true) {\n      const opt = { max: options.max ?? 1, steps: 0 };\n      const next = expr._rski(opt);\n      const final = opt.steps === 0;\n      yield { expr, steps, final };\n      if (final)\n        break;\n      expr = next;\n      steps += opt.steps;\n    }\n  }\n\n  /**\n   * @desc Internal method for toSKI, which performs one step of the conversion.\n   * @param {{max: number, steps: number}} options\n   * @returns {Expr}\n   * @private\n   */\n  _rski (options) {\n    return this;\n  }\n\n  /**\n   * Replace all instances of plug in the expression with value and return the resulting expression,\n   * or null if no changes could be made.\n   * Lambda terms and applications will never match if used as plug\n   * as they are impossible co compare without extensive computations.\n   * Typically used on variables but can also be applied to other terms, e.g. aliases.\n   * See also Expr.traverse().\n   * @param {Expr} search\n   * @param {Expr} replace\n   * @return {Expr|null}\n   */\n  subst (search, replace) {\n    return this === search ? replace : null;\n  }\n\n  /**\n   * @desc Apply term reduction rules, if any, to the given argument.\n   * A returned value of null means no reduction is possible.\n   * A returned value of Expr means the reduction is complete and the application\n   *     of this and arg can be replaced with the result.\n   * A returned value of a function means that further arguments are needed,\n   *     and can be cached for when they arrive.\n   *\n   * This method is between apply() which merely glues terms together,\n   *     and step() which reduces the whole expression.\n   *\n   * foo.invoke(bar) is what happens inside foo.apply(bar).step() before\n   *     reduction of either foo or bar is attempted.\n   *\n   * The name 'invoke' was chosen to avoid confusion with either 'apply' or 'reduce'.\n   *\n   * @param {Expr} arg\n   * @returns {Partial | null}\n   */\n  invoke (arg) {\n    return null;\n  }\n\n  /**\n   * @desc iterate one step of a calculation.\n   * @return {{expr: Expr, steps: number, changed: boolean}}\n   */\n  step () { return { expr: this, steps: 0, changed: false } }\n\n  /**\n   * @desc Run uninterrupted sequence of step() applications\n   *       until the expression is irreducible, or max number of steps is reached.\n   *       Default number of steps = 1000.\n   * @param {{max?: number, steps?: number, throw?: boolean}|Expr} [opt]\n   * @param {Expr} args\n   * @return {{expr: Expr, steps: number, final: boolean}}\n   */\n  run (opt = {}, ...args) {\n    if (opt instanceof Expr) {\n      args.unshift(opt);\n      opt = {};\n    }\n    let expr = args ? this.apply(...args) : this;\n    let steps = opt.steps ?? 0;\n    // make sure we make at least 1 step, to tell whether we've reached the normal form\n    const max = Math.max(opt.max ?? DEFAULTS.max, 1) + steps;\n    let final = false;\n    for (; steps < max; ) {\n      const next = expr.step();\n      if (!next.changed) {\n        final = true;\n        break;\n      }\n      steps += next.steps;\n      expr = next.expr;\n    }\n    if (opt.throw && !final)\n      throw new Error('Failed to compute expression in ' + max + ' steps');\n    return { final, steps, expr };\n  }\n\n  /**\n   * Execute step() while possible, yielding a brief description of events after each step.\n   * Mnemonics: like run() but slower.\n   * @param {{max?: number}} options\n   * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}\n   */\n  * walk (options = {}) {\n    const max = options.max ?? Infinity;\n    let steps = 0;\n    let expr = this;\n    let final = false;\n\n    while (steps < max) {\n      // 1. calculate\n      // 2. yield _unchanged_ expression\n      // 3. either advance or stop\n      const next = expr.step();\n      if (!next.changed)\n        final = true;\n      yield { expr, steps, final };\n      if (final)\n        break;\n      steps += next.steps;\n      expr = next.expr;\n    }\n  }\n\n  /**\n   * @desc True is the expressions are identical, false otherwise.\n   *       Aliases are expanded.\n   *       Bound variables in lambda terms are renamed consistently.\n   *       However, no reductions are attempted.\n   *\n   *       E.g. a->b->a == x->y->x is true, but a->b->a == K is false.\n   *\n   * @param {Expr} other\n   * @return {boolean}\n   */\n  equals (other) {\n    return !this.diff(other);\n  }\n\n  /**\n   * @desc Recursively compare two expressions and return a string\n   *       describing the first point of difference.\n   *       Returns null if expressions are identical.\n   *\n   *       Aliases are expanded.\n   *       Bound variables in lambda terms are renamed consistently.\n   *       However, no reductions are attempted.\n   *\n   *       Members of the FreeVar class are considered different\n   *       even if they have the same name, unless they are the same object.\n   *       To somewhat alleviate confusion, the output will include\n   *       the internal id of the variable in square brackets.\n   *\n   * @example  \"K(S != I)\" is the result of comparing \"KS\" and \"KI\"\n   * @example  \"S(K([x[13] != x[14]]))K\"\n   *\n   * @param {Expr} other\n   * @param {boolean} [swap]  If true, the order of expressions is reversed in the output.\n   * @returns {string|null}\n   */\n  diff (other, swap = false) {\n    if (this === other)\n      return null;\n    if (other instanceof Alias)\n      return other.impl.diff(this, !swap);\n    return swap\n      ? '[' + other + ' != ' + this  + ']'\n      : '[' + this  + ' != ' + other + ']';\n  }\n\n  /**\n   * @desc Assert expression equality. Can be used in tests.\n   * @param {Expr} expected\n   * @param {string} comment\n   */\n  expect (expected, comment = '') {\n    comment = comment ? comment + ': ' : '';\n    if (!(expected instanceof Expr))\n      throw new Error(comment + 'attempt to expect a combinator to equal something else: ' + expected);\n    const diff = this.diff(expected);\n    if (!diff)\n      return; // all good\n\n    // TODO wanna use AssertionError but webpack doesn't recognize it\n    // still the below hack works for mocha-based tests.\n    const poorMans = new Error(comment + diff);\n    poorMans.expected = expected + '';\n    poorMans.actual = this + '';\n    throw poorMans;\n  }\n\n  /**\n   * @desc Returns string representation of the expression.\n   *       Same as format() without options.\n   * @return {string}\n   */\n  toString () {\n    return this.format();\n  }\n\n  /**\n   * @desc Whether the expression needs parentheses when printed.\n   * @param {boolean} [first] - whether this is the first term in a sequence\n   * @return {boolean}\n   */\n  _braced (first) {\n    return false;\n  }\n\n  /**\n   * @desc Whether the expression can be printed without a space when followed by arg.\n   * @param {Expr} arg\n   * @returns {boolean}\n   * @private\n   */\n  _unspaced (arg) {\n    return this._braced(true);\n  }\n\n  /**\n   * @desc    Stringify the expression with fancy formatting options.\n   *          Said options mostly include wrappers around various constructs in form of ['(', ')'],\n   *          as well as terse and html flags that set up the defaults.\n   *          Format without options is equivalent to toString() and can be parsed back.\n   *\n   * @param   {Object} [options]  - formatting options\n   * @param   {boolean} [options.terse]   - whether to use terse formatting (omitting unnecessary spaces and parentheses)\n   * @param   {boolean} [options.html]    - whether to default to HTML tags & entities.\n   *                                If a named term has fancyName property set, it will be used instead of name in this mode.\n   * @param   {[string, string]} [options.brackets]  - wrappers for application arguments, typically ['(', ')']\n   * @param   {[string, string]} [options.var]       - wrappers for variable names\n   *                                (will default to &lt;var&gt; and &lt;/var&gt; in html mode).\n   * @param   {[string, string, string]} [options.lambda]    - wrappers for lambda abstractions, e.g. ['&lambda;', '.', '']\n   *                                where the middle string is placed between argument and body\n   *                                default is ['', '->', ''] or ['', '-&gt;', ''] for html\n   * @param   {[string, string]} [options.around]    - wrappers around (sub-)expressions.\n   *                                individual applications will not be wrapped, i.e. (a b c) but not ((a b) c)\n   * @param   {[string, string]} [options.redex]     - wrappers around the starting term(s) that have enough arguments to be reduced\n   * @param   {Object<string, Expr>} [options.inventory]     - if given, output aliases in the set as their names\n   *                                and any other aliases as the expansion of their definitions.\n   *                                The default is a cryptic and fragile mechanism dependent on a hidden mutable property.\n   * @returns {string}\n   *\n   * @example foo.format() // equivalent to foo.toString()\n   * @example foo.format({terse: false}) // spell out all parentheses\n   * @example foo.format({html: true}) // use HTML tags and entities\n   * @example foo.format({ around: ['(', ')'], brackets: ['', ''], lambda: ['(', '->', ')'] }) // lisp style, still back-parsable\n   * @exapmle foo.format({ lambda: ['&lambda;', '.', ''] }) // pretty-print for the math department\n   * @example foo.format({ lambda: ['', '=>', ''], terse: false }) // make it javascript\n   * @example foo.format({ inventory: { T } }) // use T as a named term, expand all others\n   *\n   */\n  format (options = {}) {\n    const fallback = options.html\n      ? {\n        brackets: ['(', ')'],\n        space:    ' ',\n        var:      ['<var>', '</var>'],\n        lambda:   ['', '-&gt;', ''],\n        around:   ['', ''],\n        redex:    ['', ''],\n      }\n      : {\n        brackets: ['(', ')'],\n        space:    ' ',\n        var:      ['', ''],\n        lambda:   ['', '->', ''],\n        around:   ['', ''],\n        redex:    ['', ''],\n      }\n    return this._format({\n      terse:     options.terse    ?? true,\n      brackets:  options.brackets ?? fallback.brackets,\n      space:     options.space    ?? fallback.space,\n      var:       options.var      ?? fallback.var,\n      lambda:    options.lambda   ?? fallback.lambda,\n      around:    options.around   ?? fallback.around,\n      redex:     options.redex    ?? fallback.redex,\n      inventory: options.inventory, // TODO better name\n      html:      options.html     ?? false,\n    }, 0);\n  }\n\n  /**\n   * @desc Internal method for format(), which performs the actual formatting.\n   * @param {Object} options\n   * @param {number} nargs\n   * @returns {string}\n   * @private\n   */\n  _format (options, nargs) {\n    throw new Error( 'No _format() method defined in class ' + this.constructor.name );\n  }\n\n  /**\n   * @desc Returns a string representation of the expression tree, with indentation to show structure.\n   *\n   *       Applications are flattened to avoid excessive nesting.\n   *       Variables include ids to distinguish different instances of the same variable name.\n   *\n   *       May be useful for debugging.\n   *\n   * @returns {string}\n   *\n   * @example\n   * > console.log(ski.parse('C 5 x (x->x x)').diag())\n   * App:\n   *   Native: C\n   *   Church: 5\n   *   FreeVar: x[53]\n   *   Lambda (x[54]):\n   *     App:\n   *       FreeVar: x[54]\n   *       FreeVar: x[54]\n   */\n  diag () {\n    const rec = (e, indent) => {\n      if (e instanceof App)\n        return [indent + 'App:', ...e.unroll().flatMap(s => rec(s, indent + '  '))];\n      if (e instanceof Lambda)\n        return [`${indent}Lambda (${e.arg}[${e.arg.id}]):`, ...rec(e.impl, indent + '  ')];\n      if (e instanceof Alias)\n        return [`Alias (${e.name}):`, ...rec(e.impl, indent + '  ')];\n      if (e instanceof FreeVar)\n        return [`${indent}FreeVar: ${e.name}[${e.id}]`];\n      return [`${indent}${e.constructor.name}: ${e}`];\n    }\n\n    const out = rec(this, '');\n    return out.join('\\n');\n  }\n\n  /**\n   * @desc Convert the expression to a JSON-serializable format.\n   * @returns {string}\n   */\n  toJSON () {\n    return this.format();\n  }\n}\n\nclass App extends Expr {\n  /**\n   * @desc Application of fun() to args.\n   * Never ever use new App(fun, arg) directly, use fun.apply(...args) instead.\n   * @param {Expr} fun\n   * @param {Expr} arg\n   */\n  constructor (fun, arg) {\n    super();\n\n    this.arg = arg;\n    this.fun = fun;\n    this.final = false;\n    this.arity = this.fun.arity > 0 ? this.fun.arity - 1 : 0;\n  }\n\n  weight () {\n    return this.fun.weight() + this.arg.weight();\n  }\n\n  _infer (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs || steps > options.max)\n      return { normal: false, steps };\n\n    /*\n     * inside and App there are 3 main possibilities:\n     * 1) The parent infer() actually is able to do the job. Then we just proxy the result.\n     * 2) Both `fun` and `arg` form good enough lambda terms. Then lump them together & return.\n     * 3) We literally have no idea, so we just pick the shortest defined term from the above.\n     */\n\n    const proxy = super._infer(options, preArgs, steps);\n    if (proxy.normal)\n      return proxy;\n    steps = proxy.steps; // reimport extra iterations\n\n    const [first, ...list] = this.unroll();\n    if (!(first instanceof FreeVar))\n      return { normal: false, steps }\n    // TODO maybe do it later\n\n    let discard = false;\n    let duplicate = false;\n    const out = [];\n    for (const term of list) {\n      const guess = term._infer({\n        ...options,\n        maxArgs: options.maxArgs - preArgs.length,\n        max:     options.max - steps,\n        index:   preArgs.length + options.index,\n      });\n      steps += guess.steps;\n      if (!guess.normal)\n        return { normal: false, steps };\n      out.push(guess.expr);\n      discard = discard || guess.discard;\n      duplicate = duplicate || guess.duplicate;\n    }\n\n    return {\n      normal: true,\n      steps,\n      ...maybeLambda(preArgs, first.apply(...out), {\n        discard,\n        duplicate,\n      }),\n    };\n  }\n\n  traverse (change) {\n    const replaced = change(this);\n    if (replaced instanceof Expr)\n      return replaced;\n\n    const fun = this.fun.traverse(change);\n    const arg = this.arg.traverse(change);\n\n    if (!fun && !arg)\n      return null; // no changes\n\n    return (fun ?? this.fun).apply(arg ?? this.arg);\n  }\n\n  any (predicate) {\n    return predicate(this) || this.fun.any(predicate) || this.arg.any(predicate);\n  }\n\n  _fold (initial, combine) {\n    const [value = initial, action = 'descend'] = unwrap(combine(initial, this));\n    if (action === control.prune)\n      return value;\n    if (action === control.stop)\n      return control.stop(value);\n    const [fValue = value, fAction = 'descend'] = unwrap(this.fun._fold(value, combine));\n    if (fAction === control.stop)\n      return control.stop(fValue);\n    const [aValue = fValue, aAction = 'descend'] = unwrap(this.arg._fold(fValue, combine));\n    if (aAction === control.stop)\n      return control.stop(aValue);\n    return aValue;\n  }\n\n  subst (search, replace) {\n    const fun = this.fun.subst(search, replace);\n    const arg = this.arg.subst(search, replace);\n\n    return (fun || arg) ? (fun ?? this.fun).apply(arg ?? this.arg) : null;\n  }\n\n  /**\n   * @return {{expr: Expr, steps: number}}\n   */\n\n  step () {\n    // normal reduction order: first try root, then at most 1 step\n    if (!this.final) {\n      // try to apply rewriting rules, if applicable, at first\n      const partial = this.fun.invoke(this.arg);\n      if (partial instanceof Expr)\n        return { expr: partial, steps: 1, changed: true };\n      else if (typeof partial === 'function')\n        this.invoke = partial; // cache for next time\n\n      // descend into the leftmost term\n      const fun = this.fun.step();\n      if (fun.changed)\n        return { expr: fun.expr.apply(this.arg), steps: fun.steps, changed: true };\n\n      // descend into arg\n      const arg = this.arg.step();\n      if (arg.changed)\n        return { expr: this.fun.apply(arg.expr), steps: arg.steps, changed: true };\n\n      // mark as irreducible\n      this.final = true; // mark as irreducible at root\n    }\n\n    return { expr: this, steps: 0, changed: false };\n  }\n\n  invoke (arg) {\n    // propagate invocation towards the root term,\n    // caching partial applications as we go\n    const partial = this.fun.invoke(this.arg);\n    if (partial instanceof Expr)\n      return partial.apply(arg);\n    else if (typeof partial === 'function') {\n      this.invoke = partial;\n      return partial(arg);\n    } else {\n      // invoke = null => we're uncomputable, cache for next time\n      this.invoke = _ => null;\n      return null;\n    }\n  }\n\n  unroll () {\n    return [...this.fun.unroll(), this.arg];\n  }\n\n  _rski (options) {\n    if (options.steps >= options.max)\n      return this;\n    return this.fun._rski(options).apply(this.arg._rski(options));\n  }\n\n  diff (other, swap = false) {\n    if (!(other instanceof App))\n      return super.diff(other, swap);\n\n    const fun = this.fun.diff(other.fun, swap);\n    if (fun)\n      return fun + '(...)';\n    const arg = this.arg.diff(other.arg, swap);\n    if (arg)\n      return this.fun + '(' + arg + ')';\n    return null;\n  }\n\n  _braced (first) {\n    return !first;\n  }\n\n  _format (options, nargs) {\n    const fun = this.fun._format(options, nargs + 1);\n    const arg = this.arg._format(options, 0);\n    const wrap = nargs ? ['', ''] : options.around;\n    // TODO ignore terse for now\n    if (options.terse && !this.arg._braced(false))\n      return wrap[0] + fun + (this.fun._unspaced(this.arg) ? '' : options.space) + arg + wrap[1];\n    else\n      return wrap[0] + fun + options.brackets[0] + arg + options.brackets[1] + wrap[1];\n  }\n\n  _unspaced (arg) {\n    return this.arg._braced(false) ? true : this.arg._unspaced(arg);\n  }\n}\n\nclass Named extends Expr {\n  /**\n   * @desc An abstract class representing a term named 'name'.\n   *\n   * @param {String} name\n   */\n  constructor (name) {\n    super();\n    if (typeof name !== 'string' || name.length === 0)\n      throw new Error('Attempt to create a named term with improper name');\n    this.name = name;\n  }\n\n  _unspaced (arg) {\n    return !!(\n      (arg instanceof Named) && (\n        (this.name.match(/^[A-Z+]$/) && arg.name.match(/^[a-z+]/i))\n          || (this.name.match(/^[a-z+]/i) && arg.name.match(/^[A-Z+]$/))\n      )\n    );\n  }\n\n  _format (options, nargs) {\n    // NOTE fancyName is not yet official and may change name or meaning\n    const name = options.html ? this.fancyName ?? this.name : this.name;\n    return this.arity > 0 && this.arity <= nargs\n      ? options.redex[0] + name + options.redex[1]\n      : name;\n  }\n}\n\nlet freeId = 0;\n\nclass FreeVar extends Named {\n  /**\n   * @desc A named variable.\n   *\n   * Given the functional nature of combinatory logic, variables are treated\n   * as functions that we don't know how to evaluate just yet.\n   *\n   * By default, two different variables even with the same name are considered different.\n   * They display it via a hidden id property.\n   *\n   * If a scope object is given, however, two variables with the same name and scope\n   * are considered identical.\n   *\n   * @param {string} name - name of the variable\n   * @param {any} scope - an object representing where the variable belongs to.\n   */\n  constructor (name, scope) {\n    super(name);\n    this.id = ++freeId;\n    // TODO temp compatibility mode\n    this.scope = scope === undefined ? this : scope;\n  }\n\n  weight () {\n    return 0;\n  }\n\n  diff (other, swap = false) {\n    if (!(other instanceof FreeVar))\n      return super.diff(other, swap);\n    if (this.name === other.name && this.scope === other.scope)\n      return null;\n    const lhs = this.name + '[' + this.id + ']';\n    const rhs = other.name + '[' + other.id + ']';\n    return swap\n      ? '[' + rhs + ' != ' + lhs + ']'\n      : '[' + lhs + ' != ' + rhs + ']';\n  }\n\n  subst (search, replace) {\n    if (search instanceof FreeVar && search.name === this.name && search.scope === this.scope)\n      return replace;\n    return null;\n  }\n\n  _format (options, nargs) {\n    const name = options.html ? this.fancyName ?? this.name : this.name;\n    return options.var[0] + name + options.var[1];\n  }\n}\n\nclass Native extends Named {\n  /**\n   * @desc A named term with a known rewriting rule.\n   *       'impl' is a function with signature Expr => Expr => ... => Expr\n   *       (see typedef Partial).\n   *       This is how S, K, I, and company are implemented.\n   *\n   *       Note that as of current something like a=>b=>b(a) is not possible,\n   *       use full form instead: a=>b=>b.apply(a).\n   *\n   * @example new Native('K', x => y => x); // constant\n   * @example new Native('Y', function(f) { return f.apply(this.apply(f)); }); // self-application\n   *\n   * @param {String} name\n   * @param {Partial} impl\n   * @param {{note?: string, arity?: number, canonize?: boolean, apply?: function(Expr):(Expr|null) }} [opt]\n   */\n  constructor (name, impl, opt = {}) {\n    super(name);\n    // setup essentials\n    this.invoke  = impl;\n\n    // TODO infer lazily (on demand, only once); app capabilities such as discard and duplicate\n    // try to bootstrap and infer some of our properties\n    const guess = (opt.canonize ?? true) ? this.infer() : { normal: false };\n\n    /** @type {number} */\n    this.arity = opt.arity || guess.arity || 1;\n    /** @type {string} */\n    this.note = opt.note ?? guess.expr?.format({ terse: true, html: true, lambda: ['', ' &mapsto; ', ''] });\n  }\n\n  _rski (options) {\n    if (this === native.I || this === native.K || this === native.S || (options.steps >= options.max))\n      return this;\n    const canon = this.infer().expr;\n    if (!canon)\n      return this;\n    options.steps++;\n    return canon._rski(options);\n  }\n}\n\n// predefined global combinator list\n// it is required by toSKI method, otherwise it could've as well be in parse.js\n/**\n * @type {{[key: string]: Native}}\n */\nconst native = {};\nfunction addNative (name, impl, opt) {\n  native[name] = new Native(name, impl, opt);\n}\n\nclass Lambda extends Expr {\n  /**\n   * @desc Lambda abstraction of arg over impl.\n   *     Upon evaluation, all occurrences of 'arg' within 'impl' will be replaced\n   *     with the provided argument.\n   *\n   * Note that 'arg' will be replaced by a localized placeholder, so the original\n   * variable can be used elsewhere without interference.\n   * Listing symbols contained in the lambda will omit such placeholder.\n   *\n   * Legacy ([FreeVar], impl) constructor is supported but deprecated.\n   * It will create a nested lambda expression.\n   *\n   * @param {FreeVar} arg\n   * @param {Expr} impl\n   */\n  constructor (arg, impl) {\n    if (Array.isArray(arg)) {\n      // check args before everything\n      if (arg.length === 0)\n        throw new Error('empty argument list in lambda constructor');\n\n      const [my, ...tail] = arg;\n      const known = new Set([my.name]);\n\n      while (tail.length > 0) {\n        const last = tail.pop();\n        if (known.has(last.name))\n          throw new Error('Duplicate free var name ' + last + ' in lambda expression');\n        known.add(last.name);\n\n        // TODO keep track of arity to speed up execution\n        impl = new Lambda(last, impl);\n      }\n      arg = my;\n    }\n\n    super();\n\n    // localize argument variable and bind it to oneself\n    const local = new FreeVar(arg.name, this);\n    this.arg = local;\n    this.impl = impl.subst(arg, local) ?? impl;\n    this.arity = 1;\n  }\n\n  weight () {\n    return this.impl.weight() + 1;\n  }\n\n  _infer (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs)\n      return { normal: false, steps };\n\n    const push = nthvar(preArgs.length + options.index);\n    return this.invoke(push)._infer(options, [...preArgs, push], steps + 1);\n  }\n\n  invoke (arg) {\n    return this.impl.subst(this.arg, arg) ?? this.impl;\n  }\n\n  traverse (change) {\n    const replaced = change(this);\n    if (replaced instanceof Expr)\n      return replaced;\n\n    // alas no proper shielding of self.arg is possible\n    const impl = this.impl.traverse(change);\n\n    if (!impl)\n      return null; // no changes\n\n    return new Lambda(this.arg, impl);\n  }\n\n  any (predicate) {\n    return predicate(this) || this.impl.any(predicate);\n  }\n\n  _fold (initial, combine) {\n    const [value = initial, action = 'descend'] = unwrap(combine(initial, this));\n    if (action === control.prune)\n      return value;\n    if (action === control.stop)\n      return control.stop(value);\n    const [iValue, iAction] = unwrap(this.impl._fold(value, combine));\n    if (iAction === control.stop)\n      return control.stop(iValue);\n    return iValue ?? value;\n  }\n\n  subst (search, replace) {\n    if (search === this.arg)\n      return null;\n    const change = this.impl.subst(search, replace);\n    return change ? new Lambda(this.arg, change) : null;\n  }\n\n  _rski (options) {\n    const impl = this.impl._rski(options);\n    if (options.steps >= options.max)\n      return new Lambda(this.arg, impl);\n    options.steps++;\n    if (impl === this.arg)\n      return native.I;\n    if (!impl.any(e => e === this.arg))\n      return native.K.apply(impl);\n    if (impl instanceof App) {\n      const { fun, arg } = impl;\n      // try eta reduction\n      if (arg === this.arg && !fun.any(e => e === this.arg))\n        return fun._rski(options);\n      // fall back to S\n      return native.S.apply(\n        (new Lambda(this.arg, fun))._rski(options),\n        (new Lambda(this.arg, arg))._rski(options)\n      );\n    }\n    throw new Error('Don\\'t know how to convert to SKI' + this);\n  }\n\n  diff (other, swap = false) {\n    if (!(other instanceof Lambda))\n      return super.diff(other, swap);\n\n    const t = new FreeVar('t'); // TODO better placeholder name\n\n    const diff = this.invoke(t).diff(other.invoke(t), swap);\n    if (diff)\n      return '(t->' + diff + ')'; // parentheses required to avoid ambiguity\n    return null;\n  }\n\n  _format (options, nargs) {\n    return (nargs > 0 ? options.brackets[0] : '')\n      + options.lambda[0]\n      + this.arg._format(options, 0) // TODO highlight redex if nargs > 0\n      + options.lambda[1]\n      + this.impl._format(options, 0) + options.lambda[2]\n      + (nargs > 0 ? options.brackets[1] : '');\n  }\n\n  _braced (first) {\n    return true;\n  }\n}\n\nclass Church extends Native {\n  /**\n   * @desc Church numeral representing non-negative integer n:\n   *      n f x = f(f(...(f x)...)) with f applied n times.\n   * @param {number} n\n   */\n  constructor (n) {\n    const p = Number.parseInt(n);\n    if (!(p >= 0))\n      throw new Error('Church number must be a non-negative integer');\n    const name = '' + p;\n    const impl = x => y => {\n      let expr = y;\n      for (let i = p; i-- > 0; )\n        expr = x.apply(expr);\n      return expr;\n    };\n\n    super(name, impl, { arity: 2, canonize: false, note: name });\n\n    /** @type {number} */\n    this.n = p;\n    this.arity = 2;\n  }\n\n  diff (other, swap = false) {\n    if (!(other instanceof Church))\n      return super.diff(other, swap);\n    if (this.n === other.n)\n      return null;\n    return swap\n      ? '[' + other.n + ' != ' + this.n + ']'\n      : '[' + this.n + ' != ' + other.n + ']';\n  }\n\n  _unspaced (arg) {\n    return false;\n  }\n}\n\nfunction waitn (expr, n) {\n  return arg => n <= 1 ? expr.apply(arg) : waitn(expr.apply(arg), n - 1);\n}\n\nclass Alias extends Named {\n  /**\n   * @desc A named alias for an existing expression.\n   *\n   *     Upon evaluation, the alias expands into the original expression,\n   *     unless it has a known arity > 0 and is marked terminal,\n   *     in which case it waits for enough arguments before expanding.\n   *\n   *     A hidden mutable property 'outdated' is used to silently\n   *     replace the alias with its definition in all contexts.\n   *     This is used when declaring named terms in an interpreter,\n   *     to avoid confusion between old and new terms with the same name.\n   *\n   * @param {String} name\n   * @param {Expr} impl\n   * @param {{canonize?: boolean, max?: number, maxArgs?: number, note?: string, terminal?: boolean}} [options]\n   */\n  constructor (name, impl, options = {}) {\n    super(name);\n    if (!(impl instanceof Expr))\n      throw new Error('Attempt to create an alias for a non-expression: ' + impl);\n    this.impl = impl;\n\n    if (options.note)\n      this.note = options.note;\n\n    const guess = options.canonize\n      ? impl.infer({ max: options.max, maxArgs: options.maxArgs })\n      : { normal: false };\n    this.arity = (guess.proper && guess.arity) || 0;\n    this.proper = guess.proper ?? false;\n    this.terminal = options.terminal ?? this.proper;\n    this.canonical = guess.expr;\n    this.invoke = waitn(impl, this.arity);\n  }\n\n  /**\n   * @property {boolean} [outdated] - whether the alias is outdated\n   *     and should be replaced with its definition when encountered.\n   * @property {boolean} [terminal] - whether the alias should behave like a standalone term\n   *     // TODO better name?\n   * @property {boolean} [proper] - whether the alias is a proper combinator (i.e. contains no free variables or constants)\n   * @property {number} [arity] - the number of arguments the alias waits for before expanding\n   * @property {Expr} [canonical] - equivalent lambda term.\n   */\n\n  weight () {\n    return this.terminal ? 1 : this.impl.weight();\n  }\n\n  traverse (change) {\n    return change(this) ?? this.impl.traverse(change);\n  }\n\n  any (predicate) {\n    return predicate(this) || this.impl.any(predicate);\n  }\n\n  _fold (initial, combine) {\n    const [value = initial, action] = unwrap(combine(initial, this));\n    if (action === control.prune)\n      return value;\n    if (action === control.stop)\n      return control.stop(value);\n    const [iValue, iAction] = unwrap(this.impl._fold(value, combine));\n    if (iAction === control.stop)\n      return control.stop(iValue);\n    return iValue ?? value;\n  }\n\n  subst (search, replace) {\n    if (this === search)\n      return replace;\n    return this.impl.subst(search, replace);\n  }\n\n  _infer (options, preArgs = [], steps = 0) {\n    return this.impl._infer(options, preArgs, steps);\n  }\n\n  // DO NOT REMOVE TYPE or tsc chokes with\n  //       TS2527: The inferred type of 'Alias' references an inaccessible 'this' type.\n  /**\n   * @return {{expr: Expr, steps: number, changed: boolean}}\n   */\n  step () {\n    // arity known = waiting for args to expand\n    if (this.arity > 0)\n      return { expr: this, steps: 0, changed: false };\n    // expanding is a change but it takes 0 steps\n    return { expr: this.impl, steps: 0, changed: true };\n  }\n\n  diff (other, swap = false) {\n    if (this === other)\n      return null;\n    return other.diff(this.impl, !swap);\n  }\n\n  _rski (options) {\n    return this.impl._rski(options);\n  }\n\n  _braced (first) {\n    return this.outdated ? this.impl._braced(first) : false;\n  }\n\n  _format (options, nargs) {\n    const outdated = options.inventory\n      ? options.inventory[this.name] !== this\n      : this.outdated;\n    return outdated ? this.impl._format(options, nargs) : super._format(options, nargs);\n  }\n}\n\n// ----- Expr* classes end here -----\n\n// declare native combinators\naddNative('I', x => x);\naddNative('K', x => _ => x);\naddNative('S', x => y => z => x.apply(z, y.apply(z)));\naddNative('B', x => y => z => x.apply(y.apply(z)));\naddNative('C', x => y => z => x.apply(z).apply(y));\naddNative('W', x => y => x.apply(y).apply(y));\n\naddNative(\n  '+',\n  n => n instanceof Church\n    ? new Church(n.n + 1)\n    : f => x => f.apply(n.apply(f, x)),\n  {\n    note: 'Increase a Church numeral argument by 1, otherwise n => f => x => f(n f x)',\n  }\n);\n\n// utility functions dependent on Expr* classes, in alphabetical order\n\n/**\n * @private\n * @given a list of free variables, an expression, and some capabilities of the context,\n *        return either a lambda term, or the original expression if no lambda abstraction is needed,\n *        plus some metadata about the term and the context.\n *\n *        Used by infer() internally.\n * @param {FreeVar[]} args\n * @param {Expr} expr\n * @param {object} caps\n * @returns {{expr: Expr, arity?: number, skip?: Set<number>, dup?: Set<number>, duplicate?, discard?, proper: boolean}}\n */\nfunction maybeLambda (args, expr, caps = {}) {\n  const count = new Array(args.length).fill(0);\n  let proper = true;\n  expr.traverse(e => {\n    if (e instanceof FreeVar) {\n      const index = args.findIndex(a => a.name === e.name);\n      if (index >= 0) {\n        count[index]++;\n        return;\n      }\n    }\n    if (!(e instanceof App))\n      proper = false;\n  });\n\n  const skip = new Set();\n  const dup = new Set();\n  for (let i = 0; i < args.length; i++) {\n    if (count[i] === 0)\n      skip.add(i);\n    else if (count[i] > 1)\n      dup.add(i);\n  }\n\n  return {\n    expr:      args.length ? new Lambda(args, expr) : expr,\n    ...(caps.synth ? {} : { arity: args.length }),\n    ...(skip.size ? { skip } : {}),\n    ...(dup.size ? { dup } : {}),\n    duplicate: !!dup.size  || caps.duplicate || false,\n    discard:   !!skip.size || caps.discard   || false,\n    proper,\n  };\n}\n\nfunction nthvar (n) {\n  return new FreeVar('abcdefgh'[n] ?? 'x' + n);\n}\n\n/**\n * @private\n * @param {Expr} expr\n * @param {{max?: number, maxArgs?: number}} options\n * @param {number} maxWeight\n * @yields {{expr: Expr, steps?: number, comment?: string}}\n */\nfunction * simplifyLambda (expr, options = {}, state = { steps: 0 }) {\n  // expr is a lambda, free variable, or an application thereof\n  // we want to find an equivalent lambda term with less weight\n  // which we do sequentially from leaves to the root of the AST\n\n  yield { expr, steps: state.steps, comment: '(self)' };\n\n  // short-circuit\n  if (expr.freeOnly())\n    return;\n\n  let maxWeight = expr.weight();\n\n  if (expr instanceof Lambda) {\n    for (const term of simplifyLambda(expr.impl, options, state)) {\n      const candidate = new Lambda(expr.arg, term.expr);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        yield { expr: candidate, steps: state.steps, comment: '(lambda)' + term.comment };\n      }\n    }\n  }\n\n  // fun * arg Descartes product\n  if (expr instanceof App) {\n    // try to split into fun+arg, then try canonization but exposing each step\n    let { fun, arg } = expr;\n\n    for (const term of simplifyLambda(fun, options, state)) {\n      const candidate = term.expr.apply(arg);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        fun = term.expr;\n        yield { expr: candidate, steps: state.steps, comment: '(fun)' + term.comment };\n      }\n    }\n\n    for (const term of simplifyLambda(arg, options, state)) {\n      const candidate = fun.apply(term.expr);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        yield { expr: candidate, steps: state.steps, comment: '(arg)' + term.comment };\n      }\n    }\n  }\n\n  const canon = expr.infer({ max: options.max, maxArgs: options.maxArgs });\n  state.steps += canon.steps;\n  if (canon.expr && canon.expr.weight() < maxWeight)\n    yield { expr: canon.expr, steps: state.steps, comment: '(canonical)' };\n}\n\n/**\n * @desc  Sort a list in such a way that dependent terms come after the (named) terms they depend on.\n *        If env is given, only terms listed there are taken into account.\n *        If env is omitted, it will be implied from the list.\n *        If list is omitted, it will default to values of env.\n *        If just one term is given instead of a list, it will be coerced into a list.\n *\n *        No terms outside env + list may ever appear in the result.\n *\n *        The terms in env must be named and their names must match their keys.\n *\n * @param {Expr|Expr[]} list\n * @param {{[s:string]: Named}} env\n * @returns {{list: Expr[], env: {[s:string]: Named}}}\n *\n * @example\n *    const expr = ski.parse(src);\n *    toposort([expr], ski.getTerms()); // returns all terms appearing in Expr in correct order\n */\nfunction toposort (list, env) {\n  if (list instanceof Expr)\n    list = [list];\n  if (env) {\n    // TODO check in[name].name === name\n    if (!list)\n      list = Object.keys(env).sort().map(k => env[k]); // ensure deterministic order\n  } else {\n    if (!list)\n      return [];\n    if (!env) {\n      env = {};\n      for (const item of list) {\n        if (!(item instanceof Named))\n          continue;\n        if (env[item.name])\n          throw new Error('duplicate name ' + item);\n        env[item.name] = item;\n      }\n    }\n  }\n\n  const out = [];\n  const seen = new Set();\n  const rec = term => {\n    if (seen.has(term))\n      return;\n    term.fold(null, (acc, e) => {\n      if (e !== term && e instanceof Named && env[e.name] === e) {\n        rec(e);\n        return Expr.control.prune(null);\n      }\n    });\n    out.push(term);\n    seen.add(term);\n  };\n\n  for (const term of list)\n    rec(term);\n\n  return {\n    list: out,\n    env,\n  };\n}\n\nExpr.native = native;\nExpr.control = control;\nExpr.extras = { toposort };\n\nmodule.exports = { Expr, App, Named, FreeVar, Lambda, Native, Alias, Church };\n", "/**\n * Combinatory logic simulator\n */\n'use strict';\n\nconst { Tokenizer, restrict } = require('./internal');\nconst classes = require('./expr');\n\nconst { Expr, Named, Native, Alias, FreeVar, Lambda, Church } = classes;\nconst { native } = Expr;\n\nclass Empty extends Expr {\n  apply (...args) {\n    return args.length ? args.shift().apply(...args) : this;\n  }\n\n  postParse () {\n    throw new Error('Attempt to use empty expression () as a term');\n  }\n}\n\nclass PartialLambda extends Empty {\n  // TODO mutable! rewrite ro when have time\n  constructor (term, known = {}) {\n    super();\n    this.impl = new Empty();\n    if (term instanceof FreeVar)\n      this.terms = [term];\n    else if (term instanceof PartialLambda) {\n      if (!(term.impl instanceof FreeVar))\n        throw new Error('Expected FreeVar->...->FreeVar->Expr');\n      this.terms = [...term.terms, term.impl];\n    } else\n      throw new Error('Expected FreeVar or PartialLambda');\n  }\n\n  apply (term, ...tail) {\n    if (term === null || tail.length !== 0 )\n      throw new Error('bad syntax in partial lambda expr');\n    this.impl = this.impl.apply(term);\n    return this;\n  }\n\n  postParse () {\n    return new Lambda(this.terms, this.impl);\n  }\n\n  // uncomment if debugging with prints\n  /* toString () {\n    return this.terms.join('->') + '->' + (this.impl ?? '???');\n  } */\n}\n\nfunction postParse (expr) {\n  return expr.postParse ? expr.postParse() : expr;\n}\n\nconst combChars = new Tokenizer(\n  '[()]', '[A-Z]', '[a-z_][a-z_0-9]*', '\\\\b[0-9]+\\\\b', '->', '\\\\+'\n);\n\nclass SKI {\n  /**\n   *\n   * @param {{\n   *    allow?: string,\n   *    numbers?: boolean,\n   *    lambdas?: boolean,\n   *    terms?: { [key: string]: Expr|string} | string[],\n   *    annotate?: boolean,\n   * }} [options]\n   */\n  constructor (options = {}) {\n    this.annotate = options.annotate ?? false;\n    this.known = { ...native };\n    this.hasNumbers = true;\n    this.hasLambdas = true;\n    /** @type {Set<string>} */\n    this.allow = new Set(Object.keys(this.known));\n\n    // Import terms, if any. Omit native ones\n    if (Array.isArray(options.terms))\n      this.bulkAdd(options.terms);\n    else if (options.terms) {\n      for (const name in options.terms) {\n        // Native terms already handled by allow\n        if (!options.terms[name].match(/^Native:/))\n          this.add(name, options.terms[name]);\n      }\n    }\n\n    // Finally, impose restrictions\n    // We must do it after recreating terms, or else terms reliant on forbidden terms will fail\n    this.hasNumbers = options.numbers ?? true;\n    this.hasLambdas = options.lambdas ?? true;\n    if (options.allow)\n      this.restrict(options.allow);\n  }\n\n  /**\n   * @desc Declare a new term\n   * If the first argument is an Alias, it is added as is.\n   * Otherwise, a new Alias or Native term (depending on impl type) is created.\n   * If note is not provided and this.annotate is true, an automatic note is generated.\n   *\n   * If impl is a function, it should have signature (Expr) => ... => Expr\n   * (see typedef Partial at top of expr.js)\n   *\n   * @example ski.add('T', 'S(K(SI))K', 'swap combinator')\n   * @example ski.add( ski.parse('T = S(K(SI))K') ) // ditto but one-arg form\n   * @example ski.add('T', x => y => y.apply(x), 'swap combinator') // heavy artillery\n   * @example ski.add('Y', function (f) { return f.apply(this.apply(f)); }, 'Y combinator')\n   *\n   * @param {Alias|String} term\n   * @param {String|Expr|function(Expr):Partial} [impl]\n   * @param {String} [note]\n   * @return {SKI} chainable\n   */\n  add (term, impl, note ) {\n    term = this._named(term, impl);\n\n    if (this.annotate && note === undefined) {\n      const guess = term.infer();\n      if (guess.expr)\n        note = guess.expr.format({ terse: true, html: true, lambda: ['', ' &mapsto; ', ''] });\n    }\n    if (note !== undefined)\n      term.note = note;\n\n    if (this.known[term.name])\n      this.known[term.name].outdated = true;\n    this.known[term.name] = term;\n    this.allow.add(term.name);\n\n    return this;\n  }\n\n  /**\n   * @desc Internal helper for add() that creates an Alias or Native term from the given arguments.\n   * @param {Alias|string} term\n   * @param {string|Expr|function(Expr):Partial} impl\n   * @returns {Native|Alias}\n   * @private\n   */\n  _named (term, impl) {\n    if (term instanceof Alias)\n      return new Alias(term.name, term.impl, { canonize: true });\n    if (typeof term !== 'string')\n      throw new Error('add(): term must be an Alias or a string');\n    if (impl === undefined)\n      throw new Error('add(): impl must be provided when term is a string');\n    if (typeof impl === 'string')\n      return new Alias(term, this.parse(impl), { canonize: true });\n    if (impl instanceof Expr)\n      return new Alias(term, impl, { canonize: true });\n    if (typeof impl === 'function')\n      return new Native(term, impl);\n    // idk what this is\n    throw new Error('add(): impl must be an Expr, a string, or a function with a signature Expr => ... => Expr');\n  }\n\n  /**\n   * @desc Declare a new term if it is not known, otherwise just allow it.\n   *       Currently only used by quests.\n   *       Use with caution, this function may change its signature, behavior, or even be removed in the future.\n   *\n   * @experimental\n   * @param {string|Alias} name\n   * @param {string|Expr|function(Expr):Partial} impl\n   * @returns {SKI}\n   */\n  maybeAdd (name, impl) {\n    if (this.known[name])\n      this.allow.add(name);\n    else\n      this.add(name, impl);\n    return this;\n  }\n\n  /**\n   * @desc Declare and remove multiple terms at once\n   *       term=impl adds term\n   *       term= removes term\n   * @param {string[]} list\n   * @return {SKI} chainable\n   */\n  bulkAdd (list) {\n    for (const item of list) {\n      const m = item.match(/^([A-Z]|[a-z][a-z_0-9]*)\\s*=\\s*(.*)$/s);\n      // TODO check all declarations before applying any (but we might need earlier terms for parsing later ones)\n      if (!m)\n        throw new Error('bulkAdd: invalid declaration: ' + item);\n      if (m[2] === '')\n        this.remove(m[1]);\n      else\n        this.add(m[1], this.parse(m[2]));\n    }\n\n    return this;\n  }\n\n  /**\n   * Restrict the interpreter to given terms. Terms prepended with '+' will be added\n   * and terms preceeded with '-' will be removed.\n   * @example ski.restrict('SK') // use the basis\n   * @example ski.restrict('+I') // allow I now\n   * @example ski.restrict('-SKI +BCKW' ); // switch basis\n   * @example ski.restrict('-foo -bar'); // forbid some user functions\n   * @param {string} spec\n   * @return {SKI} chainable\n   */\n  restrict (spec) {\n    this.allow = restrict(this.allow, spec);\n    return this;\n  }\n\n  /**\n   *\n   * @param {string} spec\n   * @return {string}\n   */\n  showRestrict (spec = '+') {\n    const out = [];\n    let prevShort = true;\n    for (const term of [...restrict(this.allow, spec)].sort()) {\n      const nextShort = term.match(/^[A-Z]$/);\n      if (out.length && !(prevShort && nextShort))\n        out.push(' ');\n      out.push(term);\n      prevShort = nextShort;\n    }\n    return out.join('');\n  }\n\n  /**\n   *\n   * @param {String} name\n   * @return {SKI}\n   */\n  remove (name) {\n    this.known[name].outdated = true;\n    delete this.known[name];\n    this.allow.delete(name);\n    return this;\n  }\n\n  /**\n   *\n   * @return {{[key:string]: Native|Alias}}\n   */\n  getTerms () {\n    const out = {};\n    for (const name of Object.keys(this.known)) {\n      if (this.allow.has(name))\n        out[name] = this.known[name];\n    }\n    return out;\n  }\n\n  /**\n   * @desc Export term declarations for use in bulkAdd().\n   * Currently only Alias terms are serialized.\n   * @returns {string[]}\n   */\n  declare () {\n    // TODO accept argument to declare specific terms only\n    const env = this.getTerms();\n\n    // not serializing native terms, and we don't care about free vars\n    for (const name in env) {\n      if (!(env[name] instanceof Alias))\n        delete env[name];\n    }\n\n    // avert conflicts if native terms were redefined:\n    // create a temporary alias for each native term that was redefined;\n    // replace usage of redefined term in subexpressions;\n    // finally, remove the temporary aliases from the output\n    const needDetour = {};\n    let i = 1;\n    for (const name in native) {\n      if (!(env[name] instanceof Alias))\n        continue;\n      while ('tmp' + i in env)\n        i++;\n      const temp = new Alias('tmp' + i, env[name]);\n      needDetour[temp] = env[name];\n      env[temp] = temp;\n      delete env[name];\n    }\n\n    // console.log(env);\n\n    const list = Expr.extras.toposort(undefined, env).list;\n\n    const detour = new Map();\n    if (Object.keys(needDetour).length) {\n      // replace aliases with their detoured counterparts.\n      // we have to go recursive, otherwise an unrelated alias may be expanded to its impl\n      // and name infos will be erased\n      const rework = expr => {\n        return expr.traverse(e => {\n          if (!(e instanceof Alias))\n            return null; // continue\n          const newAlias = detour.get(e);\n          if (newAlias)\n            return newAlias;\n          return new Alias(e.name, rework(e.impl));\n        }) ?? expr;\n      };\n\n      for (let i = 0; i < list.length; i++) {\n        // upon processing list[i], only terms declared before it may be detoured\n        list[i] = rework(list[i], detour);\n        detour.set(needDetour[list[i].name], list[i]);\n        env[list[i].name] = list[i];\n        console.log(`list[${i}] = ${list[i].name}=${list[i].impl};`);\n      }\n      console.log('detour:', detour);\n    }\n\n    // console.log(res);\n    const out = list.map(e => needDetour[e]\n      ? e.name + '=' + needDetour[e].name + '=' + e.impl.format({ inventory: env })\n      : e.name + '=' + e.impl.format({ inventory: env })\n    );\n\n    for (const [name, temp] of detour)\n      out.push(name + '=' + temp, temp + '=');\n\n    return out;\n  }\n\n  /**\n   * @template T\n   * @param {string} source\n   * @param {Object} [options]\n   * @param {{[keys: string]: Expr}} [options.env]\n   * @param {T} [options.scope]\n   * @param {boolean} [options.numbers]\n   * @param {boolean} [options.lambdas]\n   * @param {string} [options.allow]\n   * @return {Expr}\n   */\n  parse (source, options = {}) {\n    if (typeof source !== 'string')\n      throw new Error('parse: source must be a string, got ' + typeof source);\n\n    const lines = source.replace(/\\/\\/[^\\n]*$/gm, ' ')\n      .replace(/\\/\\*.*?\\*\\//gs, ' ')\n      .trim()\n      .split(/\\s*;[\\s;]*/).filter( s => s.match(/\\S/));\n\n    const jar = { ...options.env };\n\n    let expr = new Empty();\n    for (const item of lines) {\n      if (expr instanceof Alias)\n        expr.outdated = true;\n\n      const def = item.match(/^([A-Z]|[a-z][a-z_0-9]*)\\s*=(.*)$/s);\n      if (def && def[2] === '')\n        expr = new FreeVar(def[1], options.scope ?? SKI);\n      else\n        expr = this.parseLine(item, jar, options);\n\n      if (def) {\n        if (jar[def[1]] !== undefined)\n          throw new Error('Attempt to redefine a known term: ' + def[1]);\n        jar[def[1]] = expr;\n      }\n\n      // console.log('parsed line:', item, '; got:', expr,'; jar now: ', jar);\n    }\n\n    expr.context = {\n      env:    { ...this.getTerms(), ...jar }, // also contains pre-parsed terms\n      scope:  options.scope,\n      src:    source,\n      parser: this,\n    };\n    return expr;\n  }\n\n  /**\n   * @desc Parse a single line of source code, without splitting it into declarations.\n   *       Internal, always use parse() instead.\n   * @template T\n   * @param {String} source S(KI)I\n   * @param {{[keys: string]: Expr}} env\n   * @param {Object} [options]\n   * @param {{[keys: string]: Expr}} [options.env] - unused, see 'env' argument\n   * @param {T} [options.scope]\n   * @param {boolean} [options.numbers]\n   * @param {boolean} [options.lambdas]\n   * @param {string} [options.allow]\n   * @return {Expr} parsed expression\n   */\n  parseLine (source, env = {}, options = {}) {\n    const aliased = source.match(/^\\s*([A-Z]|[a-z][a-z_0-9]*)\\s*=\\s*(.*)$/s);\n    if (aliased)\n      return new Alias(aliased[1], this.parseLine(aliased[2], env, options));\n\n    const opt = {\n      numbers: options.numbers ?? this.hasNumbers,\n      lambdas: options.lambdas ?? this.hasLambdas,\n      allow:   restrict(this.allow, options.allow),\n    };\n    // make sure '+' usage is in sync with numerals\n    opt.numbers ? opt.allow.add('+') : opt.allow.delete('+');\n\n    const tokens = combChars.split(source);\n\n    const empty = new Empty();\n    /** @type {Expr[]} */\n    const stack = [empty];\n    const context = options.scope || SKI; // default is global unbound vars\n\n    // TODO each token should carry along its position in source\n    for (const c of tokens) {\n      // console.log(\"parseLine: found \"+c+\"; stack =\", stack.join(\", \"));\n      if (c === '(')\n        stack.push(empty);\n      else if (c === ')') {\n        if (stack.length < 2)\n          throw new Error('unbalanced input: extra closing parenthesis' + source);\n        const x = postParse(stack.pop());\n        const f = stack.pop();\n        stack.push(f.apply(x));\n      } else if (c === '->') {\n        if (!opt.lambdas)\n          throw new Error('Lambdas not supported, allow them explicitly');\n        stack.push(new PartialLambda(stack.pop(), env));\n      } else if (c.match(/^[0-9]+$/)) {\n        if (!opt.numbers)\n          throw new Error('Church numbers not supported, allow them explicitly');\n        const f = stack.pop();\n        stack.push(f.apply(new Church(c)));\n      } else {\n        const f = stack.pop();\n        if (!env[c] && this.known[c] && !opt.allow.has(c)) {\n          throw new Error('Term \\'' + c + '\\' is not in the restricted set '\n            + [...opt.allow].sort().join(' '));\n        }\n        // look in temp vars first, then in known terms, then fallback to creating free var\n        const x = env[c] ?? this.known[c] ?? (env[c] = new FreeVar(c, context));\n        stack.push(f.apply(x));\n      }\n    }\n\n    if (stack.length !== 1) {\n      throw new Error('unbalanced input: missing '\n          + (stack.length - 1) + ' closing parenthesis:' + source);\n    }\n\n    return postParse(stack.pop());\n  }\n\n  toJSON () {\n    return {\n      version:  '1.1.1', // set to incremented package.json version whenever SKI serialization changes\n      allow:    this.showRestrict('+'),\n      numbers:  this.hasNumbers,\n      lambdas:  this.hasLambdas,\n      annotate: this.annotate,\n      terms:    this.declare(),\n    }\n  }\n}\n\n/**\n *  Public static shortcuts to common functions (see also ./extras.js)\n */\n\n/**\n * @desc Create a proxy object that generates variables on demand,\n *       with names corresponding to the property accessed.\n *       Different invocations will return distinct variables,\n *       even if with the same name.\n *\n *\n * @example const {x, y, z} = SKI.vars();\n *          x.name; // 'x'\n *          x instanceof FreeVar; // true\n *          x.apply(y).apply(z); // x(y)(z)\n *\n * @template T\n * @param {T} [scope] - optional context to bind the generated variables to\n * @return {{[key: string]: FreeVar}}\n */\nSKI.vars = function (scope = {}) {\n  const cache = {};\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (!(name in cache))\n        cache[name] = new FreeVar(name, scope);\n      return cache[name];\n    }\n  });\n};\n\n/**\n * Convert a number to Church encoding\n * @param {number} n\n * @return {Church}\n */\nSKI.church = n => new Church(n);\n\n/**\n *\n * @type {{[key: string]: Native}}\n */\n\nfor (const name in native)\n  SKI[name] = native[name];\n\nSKI.classes = classes;\nSKI.native = native;\n/**\n * @desc Traverse control functions, used by Expr.traverse() and Expr.fold()\n * @template T\n * @type {{\n *    descend: function(T): TraverseControl<T>,\n *    prune: function(T): TraverseControl<T>,\n *    redo: function(T): TraverseControl<T>,\n *    stop: function(T): TraverseControl<T>\n * }}\n */\nSKI.control = Expr.control;\n\nmodule.exports = { SKI };\n", "const { SKI } = require('./parser');\nconst { Expr, FreeVar, Alias, Lambda } = SKI.classes;\n\n/**\n * @typedef {{\n *   pass: boolean,\n *   reason?: string,\n *   steps: number,\n *   start: Expr,\n *   found: Expr,\n *   expected: Expr,\n *   note?: string,\n *   args: Expr[],\n *   case: Case\n * }} CaseResult\n */\n\n/**\n * @typedef {{\n *   linear?: boolean,\n *   affine?: boolean,\n *   normal?: boolean,\n *   proper?: boolean,\n *   discard?: boolean,\n *   duplicate?: boolean,\n *   arity?: number,\n * }} Capability\n */\n\n/**\n * @typedef {\n *   [string, string]\n *   | [{max?: number}, string, string]\n *   | [{caps: Capability, max?: number}, string]\n * } TestCase\n */\n\n/**\n * @typedef {string | {name: string, fancy?: string, allow?: string, numbers?: boolean, lambdas?: boolean}} InputSpec\n */\n\n/**\n * @typedef {{\n *   pass: boolean,\n *   details: CaseResult[],\n *   expr?: Expr,\n *   input: Expr[]|string[],\n *   exception?: Error,\n *   steps: number,\n *   weight?: number\n * }} QuestResult\n */\n\n/**\n * @typedef {{\n *    input: InputSpec | InputSpec[],\n *    cases: TestCase[],\n *\n *    // the rest is optional\n *\n *    allow?: string,\n *    numbers?: boolean,\n *    env?: string[],\n *    engine?: SKI,\n *    engineFull?: SKI,\n *\n *    // metadata, also any fields not listed here will go to quest.meta.???\n *    id?: string|number,\n *    name?: string,\n *    intro?: string|string[], // multiple strings will be concatenated with spaces\n * }} QuestSpec\n */\n\nclass Quest {\n  /**\n   * @description A combinator problem with a set of test cases for the proposed solution.\n   * @param {QuestSpec} options\n   * @example const quest = new Quest({\n   *    input: 'identity',\n   *    cases: [\n   *      ['identity x', 'x'],\n   *    ],\n   *    allow: 'SK',\n   *    intro: 'Find a combinator that behaves like the identity function.',\n   * });\n   * quest.check('S K K'); // { pass: true, details: [...], ... }\n   * quest.check('K S');   // { pass: false, details: [...], ... }\n   * quest.check('K x');   // fail! internal variable x is not equal to free variable x,\n   *                       //     despite having the same name.\n   * quest.check('I');     // fail! I not in the allowed list.\n   */\n  constructor (options) {\n    const { input, cases, allow, numbers, lambdas, engine, engineFull, ...meta } = options;\n    const env = options.env ?? options.vars; // backwards compatibility\n\n    //\n    this.engine = engine ?? new SKI();\n    this.engineFull = engineFull ?? new SKI();\n    this.restrict = { allow, numbers: numbers ?? false, lambdas: lambdas ?? false };\n    this.env = {};\n\n    const jar = {};\n\n    // option.env is a list of expressions.\n    // we suck all free variables + all term declarations from there into this.env\n    // to feed it later to every case's parser.\n    for (const term of env ?? []) {\n      const expr = this.engineFull.parse(term, { env: jar, scope: this });\n      if (expr instanceof SKI.classes.Alias)\n        this.env[expr.name] = new Alias(expr.name, expr.impl, { terminal: true, canonize: false });\n        // Canonized aliases won't expand with insufficient arguments,\n        // causing correct solutions to fail, so alas...\n      else if (expr instanceof SKI.classes.FreeVar)\n        this.env[expr.name] = expr;\n      else\n        throw new Error('Unsupported given variable type: ' + term);\n    }\n\n    this.input = [];\n    for (const term of Array.isArray(input) ? input : [input])\n      this.addInput(term);\n    if (!this.input.length)\n      throw new Error('Quest needs at least one input placeholder');\n\n    this.envFull = { ...this.env, ...jar };\n    for (const term of this.input) {\n      if (term.name in this.envFull)\n        throw new Error('input placeholder name is duplicated or clashes with env: ' + term.name);\n      this.envFull[term.name] = term.placeholder;\n    }\n\n    // NOTE meta is a local variable, can mutate\n    // NOTE title/descr are old name/intro respectively, kept for backwards compatibility\n    this.cases = [];\n    this.name = meta.name ?? meta.title;\n    meta.intro = list2str(meta.intro ?? meta.descr);\n    this.intro = meta.intro;\n    this.id = meta.id;\n    this.meta = meta;\n\n    for (const c of cases ?? [])\n      this.add(...c);\n  }\n\n  /**\n   *   Display allowed terms based on what engine thinks of this.env + this.restrict.allow\n   *   @return {string}\n   */\n  allowed () {\n    const allow = this.restrict.allow ?? '';\n    const env  = Object.keys(this.env).sort();\n    // In case vars are present and restrictions aren't, don't clutter the output with all the known terms\n    return allow\n      ? this.engine.showRestrict(allow + '+' + env.join(' '))\n      : env.map( s => '+' + s).join(' ');\n  }\n\n  addInput (term) {\n    if (typeof term !== 'object')\n      term = { name: term };\n    if (typeof term.name !== 'string')\n      throw new Error(\"quest 'input' field must be a string or a {name: string, ...} object\");\n\n    term.placeholder = new SKI.classes.FreeVar(term.name);\n    // TODO more checks\n    this.input.push(term);\n  }\n\n  /**\n   *\n   * @param {{} | string} opt\n   * @param {string} terms\n   * @return {Quest}\n   */\n  add (opt, ...terms) {\n    if (typeof opt === 'string') {\n      terms.unshift(opt);\n      opt = {};\n    } else\n      opt = { ...opt };\n\n    opt.engine = opt.engine  ?? this.engineFull;\n    opt.env = opt.env ?? this.envFull;\n\n    const input = this.input.map( t => t.placeholder );\n    this.cases.push(\n      opt.caps\n        ? new PropertyCase(input, opt, terms)\n        : new ExprCase(input, opt, terms)\n    );\n    return this;\n  }\n\n  /**\n   * @description Statefully parse a list of strings into expressions or fancy aliases thereof.\n   * @param {string[]} input\n   * @return {{terms: Expr[], weight: number}}\n   */\n  prepare (...input) {\n    if (input.length !== this.input.length)\n      throw new Error('Solutions provided ' + input.length + ' terms where ' + this.input.length + ' are expected');\n\n    let weight = 0;\n    const prepared = [];\n    const jar = { ...this.env };\n    for (let i = 0; i < input.length; i++) {\n      const spec = this.input[i];\n      const impl = this.engine.parse(input[i], {\n        env:     jar,\n        allow:   spec.allow ?? this.restrict.allow,\n        numbers: spec.numbers ?? this.restrict.numbers,\n        lambdas: spec.lambdas ?? this.restrict.lambdas,\n      });\n      const arsenal = { ...this.engine.getTerms(), ...jar };\n      weight += impl.fold(0, (a, e) => {\n        if (e instanceof SKI.classes.Named && arsenal[e.name] === e)\n          return SKI.control.prune( a + 1);\n      });\n      const expr = impl instanceof FreeVar\n        ? impl\n        : new Alias(spec.fancy ?? spec.name, impl, { terminal: true, canonize: false });\n      jar[spec.name] = expr;\n      prepared.push(expr);\n    }\n    return {\n      prepared,\n      weight,\n    };\n  }\n\n  /**\n   *\n   * @param {string} input\n   * @return {QuestResult}\n   */\n  check (...input) {\n    try {\n      const { prepared, weight } = this.prepare(...input);\n      const details = this.cases.map( c => c.check(...prepared) );\n      const pass = details.reduce((acc, val) => acc && val.pass, true);\n      const steps = details.reduce((acc, val) => acc + val.steps, 0);\n      return {\n        expr:  prepared[0],\n        input: prepared,\n        pass,\n        steps,\n        details,\n        weight,\n      };\n    } catch (e) {\n      return { pass: false, details: [], exception: e, steps: 0, input };\n    }\n  }\n\n  /**\n     *\n     * @return {TestCase[]}\n     */\n  show () {\n    return [...this.cases];\n  }\n}\n\nclass Case {\n  /**\n   * @param {FreeVar[]} input\n   * @param {{\n   *   max?: number,\n   *   note?: string,\n   *   env?: {[key:string]: Expr},\n   *   engine: SKI\n   * }} options\n   */\n  constructor (input, options) {\n    this.max = options.max ?? 1000;\n    this.note = options.note;\n    this.env = { ...(options.env ?? {}) }; // note: env already contains input placeholders\n    this.input = input;\n    this.engine = options.engine;\n  }\n\n  parse (src) {\n    return new Subst(this.engine.parse(src, { env: this.env, scope: this }), this.input);\n  }\n\n  /**\n   * @param {Expr} expr\n   * @return {CaseResult}\n   */\n  check ( ...expr ) {\n    throw new Error('not implemented');\n  }\n}\n\nclass ExprCase extends Case {\n  /**\n   * @param {FreeVar[]} input\n   * @param {{\n   *    max?: number,\n   *    note?: string,\n   *    env?: {string: Expr},\n   *    engine?: SKI\n   * }} options\n   * @param {[e1: string, e2: string]} terms\n   */\n  constructor (input, options, terms) {\n    if (terms.length !== 2)\n      throw new Error('Case accepts exactly 2 strings');\n\n    super(input, options);\n\n    [this.e1, this.e2] = terms.map( s => this.parse(s) );\n  }\n\n  check (...args) {\n    const e1 = this.e1.apply(args);\n    const r1 = e1.run({ max: this.max });\n    const e2 = this.e2.apply(args);\n    const r2 = e2.run({ max: this.max });\n\n    let reason = null;\n    if (!r1.final || !r2.final)\n      reason = 'failed to reach normal form in ' + this.max + ' steps';\n    else\n      reason = r1.expr.diff(r2.expr);\n\n    return {\n      pass:     !reason,\n      reason,\n      steps:    r1.steps,\n      start:    e1,\n      found:    r1.expr,\n      expected: r2.expr,\n      note:     this.note,\n      args,\n      case:     this,\n    };\n  }\n}\n\nconst knownCaps = {\n  normal:    true,\n  proper:    true,\n  discard:   true,\n  duplicate: true,\n  linear:    true,\n  affine:    true,\n  arity:     true,\n}\n\nclass PropertyCase extends Case {\n  // test that an expression uses all of its inputs exactly once\n  constructor (input, options, terms) {\n    super(input, options);\n    if (terms.length > 1)\n      throw new Error('PropertyCase accepts exactly 1 string');\n    if (!options.caps || typeof options.caps !== 'object' || !Object.keys(options.caps).length)\n      throw new Error('PropertyCase requires a caps object with at least one capability');\n    const unknown = Object.keys(options.caps).filter( c => !knownCaps[c] );\n    if (unknown.length)\n      throw new Error('PropertyCase: don\\'t know how to test these capabilities: ' + unknown.join(', '));\n\n    this.expr = this.parse(terms[0]);\n    this.caps = options.caps;\n\n    if (this.caps.linear) {\n      delete this.caps.linear;\n      this.caps.duplicate = false;\n      this.caps.discard = false;\n      this.caps.normal = true;\n    }\n\n    if (this.caps.affine) {\n      delete this.caps.affine;\n      this.caps.normal = true;\n      this.caps.duplicate = false;\n    }\n  }\n\n  check (...expr) {\n    const start = this.expr.apply(expr);\n    const r = start.run({ max: this.max });\n    const guess = r.expr.infer({ max: this.max });\n\n    const reason = [];\n    for (const cap in this.caps) {\n      if (guess[cap] !== this.caps[cap])\n        reason.push('expected property ' + cap + ' to be ' + this.caps[cap] + ', found ' + guess[cap]);\n    }\n\n    return {\n      pass:   !reason.length,\n      reason: reason ? reason.join('\\n') : null,\n      steps:  r.steps,\n      start,\n      found:  r.expr,\n      case:   this,\n      note:   this.note,\n      args:   expr,\n    };\n  }\n}\n\nclass Subst {\n  /**\n   * @descr A placeholder object with exactly n free variables to be substituted later.\n   * @param {Expr} expr\n   * @param {FreeVar[]} env\n   */\n  constructor (expr, env) {\n    this.expr = expr;\n    this.env = env;\n  }\n\n  apply (list) {\n    if (list.length !== this.env.length)\n      throw new Error('Subst: expected ' + this.env.length + ' terms, got ' + list.length);\n\n    let expr = this.expr;\n    for (let i = 0; i < this.env.length; i++)\n      expr = expr.subst(this.env[i], list[i]) ?? expr;\n\n    return expr;\n  }\n}\n\n/**\n * @desc Concatenate long strings represented as arrays, or just pass along if already string or undefined.\n * @param {string|Array<string>|undefined} str\n * @returns {string|undefined}\n */\nfunction list2str (str) {\n  if (str === undefined || typeof str === 'string')\n    return str;\n  return Array.isArray(str) ? str.join(' ') : '' + str;\n}\n\nmodule.exports = { Quest };\n", "'use strict';\n\nconst { Expr, Alias, FreeVar } = require('./expr');\n\n/**\n * @desc  Extra utilities that do not belong in the core.\n */\n\n/**\n * @experimental\n * @desc  Look for an expression that matches the predicate,\n *        starting with the seed and applying the terms to one another.\n *\n *        A predicate returning 0 (or nothing) means \"keep looking\",\n *        a positive number stands for \"found\",\n *        and a negative means \"discard this term from further applications\".\n *\n *        The order of search is from shortest to longest expressions.\n *\n * @param {Expr[]} seed\n * @param {object} options\n * @param {number} [options.depth] - maximum generation to search for\n * @param {number} [options.tries] - maximum number of tries before giving up\n * @param {boolean} [options.infer] - whether to call infer(), default true.\n * @param {number} [options.maxArgs] - arguments in infer()\n * @param {number} [options.max] - step limit in infer()\n * @param {boolean} [options.noskip] - prevents skipping equivalent terms. Always true if infer is false.\n * @param {boolean} [retain] - if true. also add the whole cache to returned value\n * @param {({gen: number, total: number, probed: number, step: boolean}) => void} [options.progress]\n * @param {number} [options.progressInterval] - minimum number of tries between calls to options.progress, default 1000.\n * @param {(e: Expr, props: {}) => number?} predicate\n * @return {{expr?: Expr, total: number, probed: number, gen: number, cache?: Expr[][]}}\n */\nfunction search (seed, options, predicate) {\n  const {\n    depth = 16,\n    infer = true,\n    progressInterval = 1000,\n  } = options;\n  const hasSeen = infer && !options.noskip;\n\n  // cache[i] = ith generation, 0 is empty\n  const cache = [[]];\n  let total = 0;\n  let probed = 0;\n  const seen = {};\n\n  const maybeProbe = term => {\n    total++;\n    const props = infer ? term.infer({ max: options.max, maxArgs: options.maxArgs }) : null;\n    if (hasSeen && props.expr) {\n      if (seen[props.expr])\n        return { res: -1 };\n      seen[props.expr] = true;\n    }\n    probed++;\n    const res = predicate(term, props);\n    return { res, props };\n  };\n\n  // sieve through the seed\n  for (const term of seed) {\n    const { res } = maybeProbe(term);\n    if (res > 0)\n      return { expr: term, total, probed, gen: 1 };\n    else if (res < 0)\n      continue;\n\n    cache[0].push(term);\n  }\n\n  let lastProgress;\n\n  for (let gen = 1; gen < depth; gen++) {\n    if (options.progress) {\n      options.progress({ gen, total, probed, step: true });\n      lastProgress = total;\n    }\n    for (let i = 0; i < gen; i++) {\n      for (const a of cache[gen - i - 1] || []) {\n        for (const b of cache[i] || []) {\n          if (total >= options.tries)\n            return { total, probed, gen, ...(options.retain ? { cache } : {}) };\n          if (options.progress && total - lastProgress >= progressInterval) {\n            options.progress({ gen, total, probed, step: false });\n            lastProgress = total;\n          }\n          const term = a.apply(b);\n          const { res, props } = maybeProbe(term);\n\n          if (res > 0)\n            return { expr: term, total, probed, gen, ...(options.retain ? { cache } : {}) };\n          else if (res < 0)\n            continue;\n\n          // if the term is not reducible, it is more likely to be a dead end, so we push it further away\n          const offset = infer\n            ? ((props.expr ? 0 : 3) + (props.dup ? 1 : 0) + (props.proper ? 0 : 1))\n            : 0;\n          if (!cache[gen + offset])\n            cache[gen + offset] = [];\n          cache[gen + offset].push(term);\n        }\n      }\n    }\n  }\n\n  return { total, probed, gen: depth, ...(options.retain ? { cache } : {}) };\n}\n\n/**\n * @desc Recursively replace all instances of Expr in a data structure with\n *       respective string representation using the format() options.\n *       Objects of other types and primitive values are eft as is.\n *\n *       May be useful for debugging or diagnostic output.\n *\n * @experimental\n *\n * @param {any} obj\n * @param {object} [options] - see Expr.format()\n * @returns {any}\n */\nfunction deepFormat (obj, options = {}) {\n  if (obj instanceof Expr)\n    return obj.format(options);\n  if (Array.isArray(obj))\n    return obj.map(deepFormat);\n  if (typeof obj !== 'object' || obj === null || obj.constructor !== Object)\n    return obj;\n\n  // default = plain object\n  const out = {};\n  for (const key in obj)\n    out[key] = deepFormat(obj[key]);\n\n  return out;\n}\n\n/**\n * @desc  Given an expression and a hash of named terms,\n *        return a semicolon-separated string that declares said expression\n *        unambiguously.\n *\n * @example\n * var expr = ski.parse(\"T=CI; V=BCT; V x y\");\n * SKI.extras.declare(expr, expr.context.env);\n * // 'B; C; I; T=CI; V=BC(T); x=; y=; Vx y'\n *\n * @param {Expr} expr\n * @param {{[s: string]: Named}} [env]\n * @returns {string}\n */\nfunction declare (expr, env) {\n  const res = Expr.extras.toposort([expr], env);\n\n  return res.list.map(s => {\n    if (s instanceof Alias)\n      return s.name + '=' + s.impl.format({ inventory: res.env });\n    if (s instanceof FreeVar)\n      return s.name + '=';\n    return s.format({ inventory: res.env });\n  }).join('; ');\n}\n\nmodule.exports = { search, deepFormat, declare };\n", "const { SKI } = require('./src/parser');\nconst { Quest } = require('./src/quest');\nconst extras = require('./src/extras');\n\nSKI.Quest = Quest;\nSKI.extras = { ...extras, ...SKI.classes.Expr.extras };\n\n// SKI_REPL=1 node -r ./index.js\nif (typeof process === 'object' && process.env.SKI_REPL && typeof global !== 'undefined') {\n  global.SKI = SKI;\n  console.log('SKI_REPL activated, try `new SKI();`');\n}\n\n// we're in a browser\nif (typeof window !== 'undefined')\n  window.SKI = SKI;\n\nmodule.exports = { SKI, Quest }; // TODO remove Quest on next breaking release, it's in SKI already!\n", "class Store {\n  constructor (namespace) {\n    this.ns = namespace + ':';\n  }\n\n  save (key, value) {\n    window.localStorage.setItem(this.ns + key, JSON.stringify(value));\n  }\n\n  load (key) {\n    return JSON.parse(window.localStorage.getItem(this.ns + key));\n  }\n\n  scan () {\n    const st = window.localStorage;\n    const out = [];\n    for (let i = 0; i < st.length; i++) {\n      const key = st.key(i);\n      if (key.startsWith(this.ns))\n        out.push(key.substring(this.ns.length));\n    }\n    return out;\n  }\n\n  delete (key) {\n    window.localStorage.removeItem(this.ns + key);\n  }\n}\n\nmodule.exports = { Store };\n", "/**\n *   HTML-related utility functions. Poor man's jquery & react.\n */\n\n'use strict';\n\n/**\n * @desc Locate static elements with specific ids and them as hash.\n * camelCase ids are converted to hyphen-case for aesthetic reason.\n *\n * @param {string} ids\n * @return {{[id: string]: HTMLElement}}\n *\n * @example\n * // given <div id=\"foo-bar\"></div>, grabView('fooBar') will return { fooBar: HTMLDivElement }\n */\nfunction grabView (...ids) {\n  const view = {};\n  for (const name of ids) {\n    const hyphen = name.replace(/[A-Z]/g, char => '-' + char.toLowerCase())\n    view[name] = document.getElementById(hyphen);\n    if (!view[name])\n      throw new Error(`View element not found: ${hyphen}`);\n  }\n  return view;\n}\n\n/**\n * Create a new HTMLElement and append it to parent, if given.\n * @param parent - parent element to append to, or null to create an unattached element\n * @param tagname - tag name of the element to create\n * @param {object} options\n * @param {string[]} [options.class] - array of class names to add\n * @param {string} [options.content] - innerHTML content to set (not escaped whatsoever)\n * @param {boolean} [options.hidden] - whether to set hidden attribute\n * @param {string} [options.color] - color to set for the element\n * @param {(elem: HTMLElement) => void} decorate - do more stuff on element before returning it\n * @return {HTMLElement}\n *\n * @example\n * // create <div class=\"foo bar\" style=\"color: red\">Hello</div> and append to body\n * append(document.body, 'div', { class: ['foo', 'bar'], content: 'Hello', color: 'red' });\n */\nfunction append (parent, tagname, options = {}, decorate = null) {\n  const child = document.createElement(tagname);\n  if (options.class)\n    child.classList.add(...options.class);\n  if (options.content !== undefined)\n    child.innerHTML = '' + options.content;\n  if (options.hidden)\n    child.hidden = true;\n  if (options.color)\n    child.style.color = options.color;\n  if (parent)\n    parent.appendChild(child);\n  if (decorate)\n    decorate(child);\n  return child;\n}\n\n/**\n * Traverse a node tree and call func on each node.\n * @param node\n * @param func\n */\nfunction traverse (node, func) {\n  func(node);\n  for (const child of node.childNodes)\n    traverse(child, func);\n}\n\n/**\n * Escape HTML special characters in a string.\n * @param text\n * @returns {string}\n */\nfunction sanitize (text) {\n  if (typeof text !== 'string')\n    text = '' + text;\n  const escape = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n  };\n  return text.replace(/[<>&]/g, c => escape[c]);\n}\n\n/**\n * URL encode a string.\n * Forces encoding of parentheses because facebook (and possibly others)\n * and some markdown processors don't like raw parentheses in URLs.\n * Also replaces spaces with '+' for beauty.\n * @param s\n * @returns {string}\n */\nfunction encode (s) {\n  // md parser ambiguity compat\n  const parens = {\n    '(': '%28',\n    ')': '%29',\n  }\n  return encodeURIComponent(s)\n    .replace(/[()]/g, c => parens[c])\n    .replace(/%20/g, '+');\n}\nfunction decode (s) {\n  return decodeURIComponent(('' + s).replace(/\\+/g, ' '));\n}\n\nmodule.exports = { append, decode, encode, grabView, sanitize, traverse };\n", "'use strict';\n\nconst { append } = require('./html-util');\n\nclass EvalBox {\n  /**\n   * @desc  Create a visual container that can run SKI code step by step and display the results.\n   *\n   * @param {{\n   *      expr: string | Expr | [string, Expr],\n   *      engine: SKI,\n   *      generator?: function(e:Expr): IterableIterator<{final: boolean, expr: Expr, steps: number}>,\n   *      max?: number,\n   *      height?: number,\n   *      onStop?: function,\n   *      onStart?: function,\n   *      onStep?: function,\n   *      delay?: number,\n   *      id?: number,\n   *      parent?: Element,\n   * }} options\n   */\n  constructor (options = {}) {\n    // logic setup\n    // TODO if expr is given, store it (= was parsed eslewhere)\n    this.options    = options;\n    this.height     = options.height ?? 5;\n    this.running    = false;\n    this.delay      = options.delay ?? 0;\n    this.maxSteps   = options.max ?? Infinity;\n    this.onStart    = options.onStart ?? (() => {});\n    this.onStop     = options.onStop ?? (() => {});\n    this.onStep     = options.onStep ?? (() => {});\n    this.engine     = options.engine;\n    this.format     = options.format ?? { html: true };\n    this.generator  = options.generator ?? (e => e.walk());\n\n    // if given an expr, normalize it\n    this.set(options.expr);\n\n    // view setup\n    this.view = {};\n    this.view.parent  = options.parent;\n    this.view.scroll  = options.scroll ?? options.parent; // containing scrollable element, may != parent\n    this.view.main    = append(options.parent, 'ol', { class: ['ski-eval-box'] });\n  }\n\n  /**\n   * @descr   set this.src and this.expr according to arg, which may be:\n   *          - string: set this.src to arg, this.expr to this.engine.parse(arg)\n   *          - Expr: set this.expr to arg, this.src to arg.format()\n   *          - [src: string, expr: Expr]: set both directly\n   * @param {string|Expr|[src: string, expr: Expr]} arg\n   * @return this\n   */\n  set (arg) {\n    if (typeof arg === 'string') {\n      this.src = arg;\n      this.expr = this.engine.parse(arg);\n    } else if (Array.isArray(arg) && arg.length === 2) {\n      this.src = arg[0];\n      this.expr = arg[1];\n    } else if (!arg) {\n      this.expr = null;\n      this.src = null;\n    } else if (typeof arg === 'object' && typeof arg.format === 'function') {\n      // assume it's an Expr\n      this.expr = arg;\n      this.src = arg.format();\n    } else\n      throw new Error('EvalBox.set() expects a string, Expr, or [string, Expr]');\n\n    return this;\n  }\n\n  /**\n   *\n   * @param {string} [src] Set new source code to run\n   * @return EvalBox this\n   */\n  start (src) {\n    if (this.running)\n      this.stop();\n\n    try {\n      if (src !== undefined)\n        this.set(src);\n      this.seq = this.generator(this.expr);\n    } catch (e) {\n      console.error(e);\n      return this.stop(e.message);\n    }\n    this.view.main.innerHTML = '';\n    this.onStart();\n    this.running = true;\n    this.tick();\n    return this;\n  }\n\n  stop (reason) {\n    this.running = false;\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n    if (reason)\n      this.print(reason, { class: ['ski-eval-error'], line: '' });\n    this.onStop();\n  }\n\n  /**\n   * @desc resume execution after stopping, if the sequence is not finished yet\n   */\n  resume () {\n    if (this.running || !this.seq)\n      return;\n    this.running = true;\n    this.onStart();\n    this.tick();\n  }\n\n  tick () {\n    if (!this.running) return;\n    const { value, done } = this.seq.next();\n    // we're checking both done and value.final because some SKI operations know when they end and some don't\n\n    if (value)\n      this.print(value.expr.format(this.format), { line: value.steps });\n\n    this.onStep(value, done || value.final);\n\n    if (done || value.final) {\n      // could've just used next().done but that creates one extra iteration\n      // finished execution, congratulations\n      if (this.view.last)\n        this.view.last.classList.add('ski-eval-success');\n      this.seq = null; // allow GC + prevent resuming\n      return this.stop();\n    }\n\n    if (value.steps >= this.maxSteps)\n      return this.stop('Max steps reached: ' + this.maxSteps);\n    this.timer = setTimeout(() => this.tick(), this.delay);\n  }\n\n  remove () {\n    if (this.view.parent) {\n      this.view.parent.removeChild(this.view.main);\n      this.view.parent = null;\n    }\n  }\n\n  clear () {\n    this.stop();\n    this.view.main.innerHTML = '';\n  }\n\n  setHeight (height) {\n    this.height = height;\n  }\n\n  print (text, options = {}) {\n    const line = append(this.view.main, 'li', options);\n    if (options.line !== 0 && !options.line)\n      line.style['list-style'] = 'none';\n    else {\n      this.view.main.style['padding-left'] = ('' + options.line).length + 2.5 + 'ch';\n      line.value = options.line;\n    }\n    this.view.last = line;\n\n    if (options.raw)\n      line.innerHTML = text;\n    else {\n      append(line, 'span', {\n        class:   options.class ?? ['ski-eval-line'],\n        color:   options.color,\n        content: (text),\n      });\n\n      while (this.view.main.children.length > this.height)\n        this.view.main.removeChild(this.view.main.firstChild);\n    }\n\n    if (this.view.scroll)\n      this.view.scroll.scrollTop = line.offsetTop;\n\n    return line;\n  }\n}\n\nmodule.exports = { EvalBox };\n", "'use strict';\n\nconst { SKI } = require('../index');\nconst { Store } = require('./store');\nconst { EvalBox } = require('./eval-box');\nconst { append } = require('./html-util')\n\nclass QuestPage {\n  /**\n   * @desc  A collection of combinatory logic quests organized into chapters\n   *        and attached to specific elements for display.\n   *\n   *        Quest progress is saved in the localStorage under a given prefix.\n   *\n   *        The engine is also saved and loaded from the store,\n   *        so that unlocked terms persist across sessions and can be used in later quests.\n   *\n   * @param {{\n   *   index: string, // URL to fetch quest list from\n   *   baseUrl?: string, // root URL to fetch quest data from, default 'data/quests/'\n   *   storePrefix?: string, // prefix for localStorage keys, required unless 'store' object itself is provided\n   *   // page elements to attach to:\n   *   indexBox: HTMLElement, // element to attach chapter list to\n   *   contentBox: HTMLElement, // element to attach chapter content to\n   *   inventoryBox: HTMLElement, // element to attach inventory to\n   *   // extra stuff\n   *   linkedTo?: string, // id of element to scroll into view after loading\n   *   store: Store, // TODO move out into callbacks, also make async\n   *   engine?: SKI, // defautl = new SKI()\n   *   onLoad?: function, // callback for when quests are loaded, gets list of QuestChapter objects as argument\n   *   onSolved?: function, // callback for when a quest is solved\n   *   onFailed?: function, // callback for when a quest is attempted but not solved\n   *   onUnlock?: function, // callback for when a quest is solved and unlocks something in the engine\n   *   chapterList?: QuestChapter[], // optional write-only list for observability only\n   * }} options\n   */\n  constructor (options) {\n    this.view = {};\n    this.root = options.baseUrl ?? '.';\n\n    if (!options.store && !options.storePrefix)\n      throw new Error('No storePrefix provided');\n    this.store = options.store ?? new Store(options.storePrefix);\n    this.engine = options.engine ?? new SKI(this.store.load('engine') ?? { annotate: true, allow: 'SKI' });\n\n    if (options.inventoryBox) {\n      this.view.inventory = options.inventoryBox;\n      this.showKnown();\n    }\n    this.view.content = options.contentBox;\n    this.view.index = options.indexBox;\n\n    this._onSolved = options.onSolved;\n    this._onFailed = options.onFailed;\n    this._onUnlock = options.onUnlock;\n\n    this.chapters = [];\n  }\n\n  load (index, linkedTo, onLoad) {\n    // TODO convert link into this.root\n\n    fetch(this.mkLink(index))\n      .then(resp => resp.json())\n      .then(list => {\n        let chapterId = 0;\n        this.chapters = [];\n        const joint = [];\n        for (const item of list) {\n          const chapter = new QuestChapter({\n            number:   ++chapterId,\n            link:     this.mkLink(item),\n            engine:   this.engine,\n            store:    this.store,\n            onUnlock: x => this.onUnlock(x),\n            onSolved: x => this._onSolved(x),\n            onFailed: x => this._onFailed(x),\n          });\n          this.chapters.push(chapter);\n          chapter.attach(this.view.content, { placeholder: 'loading chapter' + chapter.number + '...' });\n          chapter.addLink(this.view.index);\n          joint.push(chapter.fetch().then(chapter => {\n            chapter.draw();\n          }));\n        }\n        Promise.all(joint).then(() => {\n          if (linkedTo) {\n            const target = document.getElementById(linkedTo);\n            if (target)\n              target.scrollIntoView();\n          }\n          if (onLoad)\n            onLoad(this);\n        });\n      });\n  }\n\n  mkLink (str) {\n    return (str.match(/^\\w+:\\/\\//) || str.match(/^[/.]/)) ? str : this.root + '/' + str;\n  }\n\n  onUnlock (term) {\n    this.engine.maybeAdd(term.name, term.impl);\n    if (this.store)\n      this.store.save('engine', this.engine);\n    this.showKnown();\n    if (this._onUnlock)\n      this._onUnlock(term);\n  }\n\n  showKnown () {\n    // TODO ul, li\n    if (!this.view.inventory)\n      return;\n    const elem = this.view.inventory;\n    elem.innerHTML = '';\n    const terms = this.engine.getTerms();\n    for (const entry of Object.keys(terms).sort().map(x => [x, terms[x]]))\n      append(elem, 'div', { content: `<dt>${entry[0]}</dt><dd>= ${showTerm(entry[1])}</dd>` });\n  }\n\n  demolish() {\n    for (const key of this.store.scan()) {\n      this.store.delete(key);\n    };\n    // TODO reset engine, chapters, and quest boxes\n  }\n}\n\nclass QuestBox {\n  /**\n   * @desc Create a quest box with given spec and options\n   * @param {QuestSpec} spec\n   * @param {{\n   *   engine?: SKI,\n   *   chapter?: QuestChapter,\n   *   number?: number,\n   *   store?: Store,\n   * }}options\n   */\n  constructor (spec, options) {\n    const engine = options.engine ?? (options.chapter?.engine);\n    if (!engine)\n      throw new Error('QuestBox requires an engine: SKI in either options or chapter');\n    const store = options.store ?? options.chapter?.store;\n    if (!store)\n      throw new Error('QuestBox requires a store: Store in either options or chapter');\n    this.impl = new SKI.Quest({ ...spec, engine });\n    this.name = this.impl.id ? 'quest-' + this.impl.id : '';\n    this.chapter = options.chapter;\n    if (this.chapter && options.number)\n      this.number = this.chapter.number + '.' + options.number;\n    this.store = store;\n    this.engine = engine;\n    this.view = {};\n    this.input = [];\n  }\n\n  load () {\n    const data = this.store.load(this.name) ?? {};\n    this.status = {\n      solved:   data.solved ?? false,\n      steps:    data.steps ?? 0,\n      attempts: data.attempts ?? 0,\n      weight:   data.weight ?? 0,\n      total:    data.total ?? 0,\n    };\n    if (this.status.solved)\n      this.onSolved();\n    return this;\n  }\n\n  save () {\n    this.store.save(this.name, this.status);\n    return this;\n  }\n\n  update (result) {\n    if (this.status.solved)\n      return;\n    this.status.attempts++;\n    this.status.total += result.steps;\n    this.status.steps = result.steps;\n    this.status.weight = result.weight;\n    if (result.pass) {\n      this.status.solved = true;\n      this.onSolved(result);\n    }\n    this.save();\n    this.showStatus();\n  }\n\n  onSolved (result) {\n    if (this.impl.meta.unlock && result) {\n      const term = new SKI.classes.Alias(this.impl.meta.unlock, result.expr.expand());\n      this.chapter?.onUnlock(term);\n    }\n    if (this.chapter)\n      this.chapter.addSolved(this.impl.id);\n  }\n\n  check () {\n    if (this.view.display)\n      this.view.display.innerHTML = 'running...';\n    const got = this.input.map(x => x.value);\n    const result = this.impl.check(...got);\n    this.showResult(result);\n    this.update(result);\n  }\n\n  draw (element) {\n    this.view.frame = append(element, 'div', { class: ['ski-quest-box'] });\n    this.view.frame.id = this.name;\n\n    const title = append(this.view.frame, 'h3');\n    const body = append(this.view.frame, 'div');\n    const expand = append(title, 'a', { content: this.number ? '#' + this.number + '' : 'Quest' });\n    expand.href = '#' + this.name;\n    expand.onclick = () => showhide(body, true);\n\n    append(title, 'span', { content: ' ' + this.impl.name });\n    const allowed = this.impl.allowed();\n    if (allowed)\n      append(title, 'span', { content: ' [' + allowed + ']' });\n    this.view.stat = append(title, 'span', { class: ['ski-quest-float-right'] });\n\n    const descr = append(body, 'div');\n    append(descr, 'div', { content: cat(this.impl.intro), class: ['ski-quest-note'] });\n    if (this.impl.meta.hint)\n      hint(descr, ' Hint:...', ' Hint: ' + this.impl.meta.hint);\n\n    this.view.display = append(body, 'div', { class: ['ski-quest-display'], content: '.....' });\n\n    this.view.solution = append(body, 'div', { class: ['ski-quest-solution'] });\n\n    this.drawInput(this.view.solution);\n\n    this.showStatus();\n  }\n\n  drawInput (element) {\n    const spec = this.impl.input;\n    const multi = spec.length !== 1;\n\n    for (const item of spec) {\n      if (multi) {\n        const label = append(element, 'div', { class: ['ski-quest-label'] });\n        append(label, 'b', { content: item.name });\n        if (item.note)\n          append(label, 'span', { content: ' // ' + item.note, class: ['ski-quest-comment'] });\n      }\n      const input = append(element, 'input');\n      input.type = 'text';\n      input.onkeydown = e => {\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          this.check();\n        }\n      };\n      this.input.push(input);\n      append(element, 'br');\n    }\n\n    const btn = append(element, 'button', { content: 'solve!' });\n    btn.onclick = () => this.check();\n  }\n\n  showStatus () {\n    if (!this.view.stat)\n      return;\n    if (this.status.attempts) {\n      const tries = 'in ' + this.status.attempts + (this.status.attempts === 1 ? ' try' : ' tries');\n      const steps = this.status.solved\n        ? '&check; ' + this.status.steps + ' steps/' + this.status.weight + ' terms '\n        : this.status.total + ' total steps ';\n      this.view.stat.innerHTML = steps + ' ' + tries;\n    }\n  }\n\n  /**\n   *\n   * @param {QuestResult} result\n   */\n  showResult (result) {\n    if (!this.view.display)\n      return;\n    this.view.display.innerHTML = '';\n    const echo = append(this.view.display, 'div');\n    append(echo, 'span', { content: 'Your solution: ' + expand(result.expr) + ' ' });\n\n    if (result.exception)\n      append(this.view.display, 'div', { class: ['ski-quest-error'], content: 'Execution failed: ' + result.exception });\n\n    for (const item of result.details) {\n      const line = append(this.view.display, 'div', { class: item.pass ? ['ski-quest-success'] : ['ski-quest-error'] });\n      append(line, 'span', { content: item.pass ? '&check; ' : '&cross; ' });\n      append(line, 'span', { content: `${item.start} &rarr; ${item.found} ` });\n      const showSteps = append(line, 'a', { content: `in ${item.steps} steps`, class: ['ski-quest-control'] });\n      append(line, 'span', { content: ' ' });\n      const hideSteps = append(line, 'a', { content: ' (hide)', class: ['ski-quest-control'], hidden: true });\n\n      if (!item.pass) {\n        append(line, 'br');\n        if (item.expected !== undefined) {\n          append(line, 'span', { content: '&nbsp;&nbsp;' + 'expected: ' + item.expected });\n          append(line, 'br');\n        }\n        if (item.reason) {\n          append(line, 'span', { content: '&nbsp;&nbsp;' + item.reason });\n          append(line, 'br');\n        }\n      }\n      // replay specific test case via EvalBox\n      const termDiv = append(line, 'div', {});\n      showSteps.onclick = () => {\n        termDiv.innerHTML = '';\n        hideSteps.hidden = false;\n        const box = new EvalBox({ parent: termDiv, engine: this.engine, height: Infinity, max: item.steps + 2, headless: true });\n        box.start(item.start);\n      };\n      hideSteps.onclick = () => {\n        termDiv.innerHTML = '';\n        hideSteps.hidden = true;\n      };\n    }\n  }\n}\n\nclass QuestChapter {\n  /**\n   * @desc A collection of quests, typically related,\n   *       with a title and intro text. Optionally numbered, too.\n   * @param {{\n   *   name?: string,\n   *   intro?: string|string[],\n   *   link: string, // URL to fetch quest list from\n   *   number?: number,\n   *   engine: SKI,\n   *   store: Store,\n   *   onUnlock?: function, // callback for when a quest is solved and unlocks something in the engine\n   * }}options\n   */\n  constructor (options) {\n    this.options = options;\n    this.quests = [];\n    this.solved = new Set();\n    this.view = {};\n    this.number = options.number ?? 0;\n    this.engine = options.engine;\n    this.store = options.store;\n    this.onUnlock = options.onUnlock ?? (() => {});\n    this.updateMeta();\n  }\n\n  updateMeta (meta = {}) {\n    this.options = { ...this.options, ...meta };\n    this.id = 'chapter-' + (meta.id ?? this.number);\n    if (this.view.frame)\n      this.view.frame.id = this.id;\n    if (this.view.link)\n      this.view.link.href = '#' + this.id;\n    if (this.options.name && this.view.linkText)\n      this.view.linkText.innerHTML = 'Chapter ' + this.number + ': ' + this.options.name;\n  }\n\n  fetch () {\n    return fetch(this.options.link)\n      .then( resp => resp.json() )\n      .then(data => {\n        if (Array.isArray(data))\n          data = { content: data };\n        if (!Array.isArray(data.content))\n          throw new Error('Invalid quest list in ' + this.options.link);\n\n        this.updateMeta(data);\n\n        let k = 0;\n        for (const item of data.content)\n          this.quests.push(new QuestBox(item, { chapter: this, number: ++k }));\n\n        return this;\n      });\n  }\n\n  addSolved (questId) {\n    if (this.solved.has(questId))\n      return;\n    this.solved.add(questId);\n    this.showStatus();\n  }\n\n  getProgress () {\n    return {\n      total:      this.quests.length,\n      solved:     this.solved.size,\n      complete:   this.solved.size === this.quests.length,\n      percentage: Math.round(this.solved.size / this.quests.length * 100),\n    }\n  }\n\n  attach (element, options) {\n    this.view.frame = append(element, 'div', { class: ['ski-quest-chapter'] });\n    this.view.frame.id = this.id;\n\n    if (options.placeholder)\n      this.view.placeholder = append(this.view.frame, 'div', { content: options.placeholder });\n    return this;\n  }\n\n  draw () {\n    this.visible = true;\n    this.view.placeholder?.remove();\n    const title = append(this.view.frame, 'h2');\n    const body = append(this.view.frame, 'div');\n    append(title, 'span', { content: 'Chapter ' + this.number + ': ' + this.options.name });\n    this.view.stat = append(title, 'span', { class: ['ski-quest-float-right'] });\n    title.onclick = () => { showhide(body, this.visible = !this.visible) };\n\n    this.view.intro = append(body, 'div', { content: cat(this.options.intro), class: ['ski-quest-note', 'ski-quest-chapter-intro'] });\n    this.view.content = append(body, 'div', { class: ['ski-quest-chapter-content'] });\n\n    for (const quest of this.quests) {\n      quest.load();\n      quest.draw(this.view.content);\n    }\n\n    this.showStatus();\n  }\n\n  showStatus () {\n    if (!this.view.stat)\n      return;\n    const progress = this.getProgress();\n    this.view.stat.innerHTML = 'Progress: ' + progress.solved + '/' + progress.total + ' (' + progress.percentage + '%)';\n    if (progress.complete)\n      this.view.stat.classList.add('success');\n    if (this.view.progressbar) {\n      this.view.progressbar.style.paddingRight = progress.percentage + '%';\n      this.view.progressbar.style.marginRight = -progress.percentage + '%';\n    }\n  }\n\n  addLink (element) {\n    const link = append(element, 'a');\n    link.href = '#' + this.id;\n    this.view.link = link;\n    this.view.progressbar = append(link, 'span', { class: ['ski-quest-completion'] });\n    this.view.linkText = append(link, 'span', { content: 'Chapter ' + this.number + '...' });\n  }\n\n  // TODO hide solved chapters\n}\n\n/**\n * @desc Create a self-revealing spoiler\n * @param element\n * @param shown\n * @param hidden\n */\n\nfunction hint (element, shown, hidden) {\n  const container = append(element, 'span', {});\n  const clickme = append(container, 'span', { content: shown, class: ['ski-quest-hint'] });\n  clickme.onclick = () => {\n    clickme.remove();\n    append(container, 'span', { content: hidden });\n  };\n}\n\n/**\n * @desc Coerce array of strings to string\n * @param {string[]|string|number} input\n * @return {string}\n */\nfunction cat (input) {\n  if (Array.isArray(input))\n    return input.join(' ');\n  else\n    return '' + input;\n}\n\nfunction expand (expr) {\n  return expr instanceof SKI.classes.Expr\n    ? (\n      expr instanceof SKI.classes.Alias\n        ? expr.name + ' = ' + expr.expand()\n        : '' + expr.expand()\n    )\n    : '' + expr;\n}\n\nfunction showhide (element, show) {\n  if (show === undefined)\n    show = element.hidden;\n  element.hidden = !show;\n}\n\nfunction showTerm (term) {\n  return term.note ?? (term.impl ?? term).format({ html: true, lambda: ['', ' &mapsto; ', ''] });\n}\n\nmodule.exports = { QuestPage, QuestChapter, QuestBox };", "'use strict';\n\nconst { QuestBox, QuestChapter, QuestPage } = require('./quest');\n\nif (typeof window !== 'undefined') {\n  window.QuestBox = QuestBox;\n  window.QuestChapter = QuestChapter;\n  window.QuestPage = QuestPage;\n}"],
  "mappings": "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",
  "names": ["i", "require_quest", "chapter", "expand"]
}
