(()=>{var j=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var M=j((kt,U)=>{var I=class{constructor(...t){let e="$|(\\s+)|"+t.map(s=>"(?:"+s+")").sort((s,r)=>r.length-s.length).join("|");this.rex=new RegExp(e,"gys")}split(t){this.rex.lastIndex=0;let e=[...t.matchAll(this.rex)],r=e.pop()?.index??0;if(r!==t.length)throw new Error("Unknown tokens at pos "+r+"/"+t.length+" starting with "+t.substring(r));return e.filter(i=>i[1]===void 0).map(i=>i[0])}},lt=new I("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");function ct(n,t){if(!t)return n;let e=new Set([...n]),s=0,r=[i=>{e=new Set([i]),s=1},i=>{e.add(i)},i=>{e.delete(i)}];for(let i of lt.split(t))i==="="?s=0:i==="+"?s=1:i==="-"?s=2:r[s](i);return e}U.exports={Tokenizer:I,restrict:ct}});var G=j((vt,J)=>{"use strict";var O={max:1e3,maxArgs:32},o=class n{constructor(){if(new.target===n)throw new Error("Attempt to instantiate abstract class Expr")}apply(...t){return t.length>0?new d(this,...t):this}expand(){return this}freeOnly(){return!this.any(t=>!(t instanceof m||t instanceof d))}traverse(t){return t(this)}any(t){return t(this)}weight(){return 1}infer(t={}){let e=t.max??O.max,s=t.maxArgs??O.maxArgs;return this._infer({max:e,maxArgs:s,index:0})}_infer(t,e=[],s=0){if(e.length>t.maxArgs||s>t.max)return{normal:!1,steps:s};if(this.freeOnly())return{normal:!0,steps:s,...W(e,this)};let r=this.run({max:(t.max-s)/3});if(s+=r.steps,!r.final)return{normal:!1,steps:s};if(r.steps!==0)return r.expr._infer(t,e,s);if(this._firstVar())return{normal:!1,steps:s};let i=B(e.length+t.index);return this.apply(i)._infer(t,[...e,i],s)}_aslist(){return[this]}_firstVar(){return!1}*toLambda(t={}){let e=this.traverse(s=>{if(s instanceof m||s instanceof d||s instanceof y||s instanceof g)return null;let r=s.infer({max:t.max,maxArgs:t.maxArgs});if(!r.normal)throw new Error("Failed to infer an equivalent  lambda term for "+s);return r.expr})??this;yield*F(e,t)}*toSKI(t={}){let e=0,s=this;for(;;){let r={max:t.max??1,steps:0},i=s._rski(r),h=r.steps===0;if(yield{expr:s,steps:e,final:h},h)break;s=i,e+=r.steps}}_rski(t){return this}subst(t,e){return this===t?e:null}invoke(t){return null}step(){return{expr:this,steps:0,changed:!1}}run(t={},...e){t instanceof n&&(e.unshift(t),t={});let s=e?this.apply(...e):this,r=t.steps??0,i=Math.max(t.max??O.max,1)+r,h=!1;for(;r<i;){let a=s.step();if(!a.changed){h=!0;break}r+=a.steps,s=a.expr}if(t.throw&&!h)throw new Error("Failed to compute expression in "+i+" steps");return{final:h,steps:r,expr:s}}*walk(t={}){let e=t.max??1/0,s=0,r=this,i=!1;for(;s<e;){let h=r.step();if(h.changed||(i=!0),yield{expr:r,steps:s,final:i},i)break;s+=h.steps,r=h.expr}}equals(t){return!this.diff(t)}diff(t,e=!1){return this===t?null:t instanceof g?t.impl.diff(this,!e):e?"["+t+" != "+this+"]":"["+this+" != "+t+"]"}expect(t,e=""){if(e=e?e+": ":"",!(t instanceof n))throw new Error(e+"attempt to expect a combinator to equal something else: "+t);let s=this.diff(t);if(!s)return;let r=new Error(e+s);throw r.expected=t+"",r.actual=this+"",r}toString(){return this.format()}_braced(t){return!1}_unspaced(t){return this._braced(!0)}format(t={}){let e=t.html?{brackets:["(",")"],space:" ",var:["<var>","</var>"],lambda:["","-&gt;",""],around:["",""],redex:["",""]}:{brackets:["(",")"],space:" ",var:["",""],lambda:["","->",""],around:["",""],redex:["",""]};return this._format({terse:t.terse??!0,brackets:t.brackets??e.brackets,space:t.space??e.space,var:t.var??e.var,lambda:t.lambda??e.lambda,around:t.around??e.around,redex:t.redex??e.redex,inventory:t.inventory,html:t.html??!1},0)}_format(t,e){throw new Error("No _format() method defined in class "+this.constructor.name)}_declare(t,e,s){}},d=class n extends o{constructor(t,...e){if(e.length===0)throw new Error("Attempt to create an application with no arguments (likely interpreter bug)");super(),this.arg=e.pop(),this.fun=e.length?new n(t,...e):t,this.final=!1,this.arity=this.fun.arity>0?this.fun.arity-1:0}weight(){return this.fun.weight()+this.arg.weight()}_infer(t,e=[],s=0){if(e.length>t.maxArgs||s>t.max)return{normal:!1,steps:s};let r=super._infer(t,e,s);if(r.normal)return r;s=r.steps;let[i,...h]=this._aslist();if(!(i instanceof m))return{normal:!1,steps:s};let a=!1,l=!1,c=[];for(let f of h){let u=f._infer({...t,maxArgs:t.maxArgs-e.length,max:t.max-s,index:e.length+t.index});if(s+=u.steps,!u.normal)return{normal:!1,steps:s};c.push(u.expr),a=a||u.discard,l=l||u.duplicate}return{normal:!0,steps:s,...W(e,new n(i,...c),{discard:a,duplicate:l})}}_firstVar(){return this.fun._firstVar()}expand(){return this.fun.expand().apply(this.arg.expand())}traverse(t){let e=t(this);if(e instanceof o)return e;let s=this.fun.traverse(t),r=this.arg.traverse(t);return!s&&!r?null:(s??this.fun).apply(r??this.arg)}any(t){return t(this)||this.fun.any(t)||this.arg.any(t)}subst(t,e){let s=this.fun.subst(t,e),r=this.arg.subst(t,e);return s||r?(s??this.fun).apply(r??this.arg):null}step(){if(!this.final){let t=this.fun.invoke(this.arg);if(t instanceof o)return{expr:t,steps:1,changed:!0};typeof t=="function"&&(this.invoke=t);let e=this.fun.step();if(e.changed)return{expr:e.expr.apply(this.arg),steps:e.steps,changed:!0};let s=this.arg.step();if(s.changed)return{expr:this.fun.apply(s.expr),steps:s.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}invoke(t){let e=this.fun.invoke(this.arg);return e instanceof o?e.apply(t):typeof e=="function"?(this.invoke=e,e(t)):(this.invoke=s=>null,null)}split(){return[this.fun,this.arg]}_aslist(){return[...this.fun._aslist(),this.arg]}_rski(t){return t.steps>=t.max?this:this.fun._rski(t).apply(this.arg._rski(t))}diff(t,e=!1){if(!(t instanceof n))return super.diff(t,e);let s=this.fun.diff(t.fun,e);if(s)return s+"(...)";let r=this.arg.diff(t.arg,e);return r?this.fun+"("+r+")":null}_braced(t){return!t}_format(t,e){let s=this.fun._format(t,e+1),r=this.arg._format(t,0),i=e?["",""]:t.around;return t.terse&&!this.arg._braced(!1)?i[0]+s+(this.fun._unspaced(this.arg)?"":t.space)+r+i[1]:i[0]+s+t.brackets[0]+r+t.brackets[1]+i[1]}_declare(t,e,s){this.fun._declare(t,e,s),this.arg._declare(t,e,s)}_unspaced(t){return this.arg._braced(!1)?!0:this.arg._unspaced(t)}},v=class n extends o{constructor(t){if(super(),typeof t!="string"||t.length===0)throw new Error("Attempt to create a named term with improper name");this.name=t}_unspaced(t){return!!(t instanceof n&&(this.name.match(/^[A-Z+]$/)&&t.name.match(/^[a-z+]/i)||this.name.match(/^[a-z+]/i)&&t.name.match(/^[A-Z+]$/)))}_format(t,e){let s=t.html?this.fancyName??this.name:this.name;return this.arity>0&&this.arity<=e?t.redex[0]+s+t.redex[1]:s}},ut=0,m=class n extends v{constructor(t,e){super(t),this.id=++ut,this.scope=e===void 0?this:e}weight(){return 0}_firstVar(){return!0}diff(t,e=!1){if(!(t instanceof n))return super.diff(t,e);if(this.name===t.name&&this.scope===t.scope)return null;let s=this.name+"["+this.id+"]",r=t.name+"["+t.id+"]";return e?"["+r+" != "+s+"]":"["+s+" != "+r+"]"}subst(t,e){return t instanceof n&&t.name===this.name&&t.scope===this.scope?e:null}_format(t,e){let s=t.html?this.fancyName??this.name:this.name;return t.var[0]+s+t.var[1]}},S=class extends v{constructor(t,e,s={}){super(t),this.invoke=e;let r=s.canonize??!0?this.infer():{normal:!1};this.arity=s.arity||r.arity||1,this.note=s.note??r.expr?.format({terse:!0,html:!0,lambda:[""," &mapsto; ",""]})}_rski(t){if(this===w.I||this===w.K||this===w.S||t.steps>=t.max)return this;let e=this.infer().expr;return e?(t.steps++,e._rski(t)):this}},w={};function k(n,t,e){w[n]=new S(n,t,e)}var y=class n extends o{constructor(t,e){if(Array.isArray(t)){if(t.length===0)throw new Error("empty argument list in lambda constructor");let[r,...i]=t,h=new Set([r.name]);for(;i.length>0;){let a=i.pop();if(h.has(a.name))throw new Error("Duplicate free var name "+a+" in lambda expression");h.add(a.name),e=new n(a,e)}t=r}super();let s=new m(t.name,this);this.arg=s,this.impl=e.subst(t,s)??e,this.arity=1}weight(){return this.impl.weight()+1}_infer(t,e=[],s=0){if(e.length>t.maxArgs)return{normal:!1,steps:s};let r=B(e.length+t.index);return this.invoke(r)._infer(t,[...e,r],s+1)}invoke(t){return this.impl.subst(this.arg,t)??this.impl}traverse(t){let e=t(this);if(e instanceof o)return e;let s=this.impl.traverse(t);return s?new n(this.arg,s):null}any(t){return t(this)||this.impl.any(t)}subst(t,e){if(t===this.arg)return null;let s=this.impl.subst(t,e);return s?new n(this.arg,s):null}expand(){return new n(this.arg,this.impl.expand())}_rski(t){let e=this.impl._rski(t);if(t.steps>=t.max)return new n(this.arg,e);if(t.steps++,e===this.arg)return w.I;if(!e.any(s=>s===this.arg))return w.K.apply(e);if(e instanceof d){let[s,r]=e.split();return r===this.arg&&!s.any(i=>i===this.arg)?s._rski(t):w.S.apply(new n(this.arg,s)._rski(t),new n(this.arg,r)._rski(t))}throw new Error("Don't know how to convert to SKI"+this)}diff(t,e=!1){if(!(t instanceof n))return super.diff(t,e);let s=new m("t"),r=this.invoke(s).diff(t.invoke(s),e);return r?"(t->"+r+")":null}_format(t,e){return(e>0?t.brackets[0]:"")+t.lambda[0]+this.arg._format(t,0)+t.lambda[1]+this.impl._format(t,0)+t.lambda[2]+(e>0?t.brackets[1]:"")}_declare(t,e,s){this.impl._declare(t,e,s)}_braced(t){return!0}},z=class n extends S{constructor(t){let e=Number.parseInt(t);if(!(e>=0))throw new Error("Church number must be a non-negative integer");let s=""+e,r=i=>h=>{let a=h;for(let l=e;l-- >0;)a=i.apply(a);return a};super(s,r,{arity:2,canonize:!1,note:s}),this.n=e,this.arity=2}diff(t,e=!1){return t instanceof n?this.n===t.n?null:e?"["+t.n+" != "+this.n+"]":"["+this.n+" != "+t.n+"]":super.diff(t,e)}_unspaced(t){return!1}};function Q(n,t){return e=>t<=1?n.apply(e):Q(n.apply(e),t-1)}var g=class extends v{constructor(t,e,s={}){super(t),this.impl=e,s.note&&(this.note=s.note);let r=s.canonize?e.infer({max:s.max,maxArgs:s.maxArgs}):{normal:!1};this.arity=r.proper&&r.arity||0,this.proper=r.proper??!1,this.terminal=s.terminal??this.proper,this.canonical=r.expr,this.invoke=Q(e,this.arity)}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}traverse(t){return t(this)??this.impl.traverse(t)}any(t){return t(this)||this.impl.any(t)}subst(t,e){return this===t?e:this.impl.subst(t,e)}_infer(t,e=[],s=0){return this.impl._infer(t,e,s)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}_firstVar(){return this.impl._firstVar()}diff(t,e=!1){return this===t?null:t.diff(this.impl,!e)}_rski(t){return this.impl._rski(t)}_braced(t){return this.outdated?this.impl._braced(t):!1}_format(t,e){return(t.inventory?t.inventory[this.name]!==this:this.outdated)?this.impl._format(t,e):super._format(t,e)}_declare(t,e,s){s.has(this)||(s.add(this),this.impl._declare(t,e,s),e[this.name]===this&&t.push(this.name+"="+this.impl.format({terse:!0,inventory:e})))}};k("I",n=>n);k("K",n=>t=>n);k("S",n=>t=>e=>n.apply(e,t.apply(e)));k("B",n=>t=>e=>n.apply(t.apply(e)));k("C",n=>t=>e=>n.apply(e).apply(t));k("W",n=>t=>n.apply(t).apply(t));k("+",n=>n instanceof z?new z(n.n+1):t=>e=>t.apply(n.apply(t,e)),{note:"Increase a Church numeral argument by 1, otherwise n => f => x => f(n f x)"});function ft(n){let t=Object.keys(n).filter(a=>!(n[a]instanceof v&&n[a].name===a)).map(a=>a+" = "+n[a]);if(t.length>0)throw new Error("Inventory must be a hash of named terms with matching names: "+t.join(", "));n={...n};let e=[],s=1;for(let a in w){if(!(n[a]instanceof g))continue;for(;"temp"+s in n;)s++;let l="temp"+s,c=n[a];delete n[a];let f=new g(l,c);for(let u in n)n[u]=n[u].subst(c,f)??n[u];n[l]=f,e.push([a,l])}let r=Object.values(n).filter(a=>a instanceof g).sort((a,l)=>a.name.localeCompare(l.name)),i=[],h=new Set;for(let a of r)a._declare(i,n,h);for(let[a,l]of e)i.push(a+"="+l),i.push(l+"=");return i}function W(n,t,e={}){let s=new Array(n.length).fill(0),r=!0;t.traverse(a=>{if(a instanceof m){let l=n.findIndex(c=>c.name===a.name);if(l>=0){s[l]++;return}}a instanceof d||(r=!1)});let i=new Set,h=new Set;for(let a=0;a<n.length;a++)s[a]===0?i.add(a):s[a]>1&&h.add(a);return{expr:n.length?new y(n,t):t,...e.synth?{}:{arity:n.length},...i.size?{skip:i}:{},...h.size?{dup:h}:{},duplicate:!!h.size||e.duplicate||!1,discard:!!i.size||e.discard||!1,proper:r}}function B(n){return new m("abcdefgh"[n]??"x"+n)}function*F(n,t={},e={steps:0}){if(yield{expr:n,steps:e.steps,comment:"(self)"},n.freeOnly())return;let s=n.weight();if(n instanceof y)for(let i of F(n.impl,t,e)){let h=new y(n.arg,i.expr);h.weight()<s&&(s=h.weight(),yield{expr:h,steps:e.steps,comment:"(lambda)"+i.comment})}if(n instanceof d){let[i,h]=n.split();for(let a of F(i,t,e)){let l=a.expr.apply(h);l.weight()<s&&(s=l.weight(),i=a.expr,yield{expr:l,steps:e.steps,comment:"(fun)"+a.comment})}for(let a of F(h,t,e)){let l=i.apply(a.expr);l.weight()<s&&(s=l.weight(),yield{expr:l,steps:e.steps,comment:"(arg)"+a.comment})}}let r=n.infer({max:t.max,maxArgs:t.maxArgs});e.steps+=r.steps,r.expr&&r.expr.weight()<s&&(yield{expr:r.expr,steps:e.steps,comment:"(canonical)"})}o.declare=ft;o.native=w;J.exports={Expr:o,App:d,FreeVar:m,Lambda:y,Native:S,Alias:g,Church:z}});var P=j((_t,et)=>{"use strict";var{Tokenizer:ot,restrict:N}=M(),X=G(),{Expr:K,Native:pt,Alias:_,FreeVar:V,Lambda:mt,Church:Y}=X,{native:L,declare:tt}=K,E=class extends K{apply(...t){return t.length?t.shift().apply(...t):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}},C=class n extends E{constructor(t,e={}){if(super(),this.impl=new E,t instanceof V)this.terms=[t];else if(t instanceof n){if(!(t.impl instanceof V))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...t.terms,t.impl]}else throw new Error("Expected FreeVar or PartialLambda")}apply(t,...e){if(t===null||e.length!==0)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(t),this}postParse(){return new mt(this.terms,this.impl)}};function H(n){return n.postParse?n.postParse():n}var dt=new ot("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+"),x=class n{constructor(t={}){if(this.annotate=t.annotate??!1,this.known={...L},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known)),Array.isArray(t.terms))this.bulkAdd(t.terms);else if(t.terms)for(let e in t.terms)t.terms[e].match(/^Native:/)||this.add(e,t.terms[e]);this.hasNumbers=t.numbers??!0,this.hasLambdas=t.lambdas??!0,t.allow&&this.restrict(t.allow)}add(t,e,s){if(t=this._named(t,e),this.annotate&&s===void 0){let r=t.infer();r.expr&&(s=r.expr.format({terse:!0,html:!0,lambda:[""," &mapsto; ",""]}))}return s!==void 0&&(t.note=s),this.known[t.name]&&(this.known[t.name].outdated=!0),this.known[t.name]=t,this.allow.add(t.name),this}_named(t,e){if(t instanceof _)return new _(t.name,t.impl,{canonize:!0});if(typeof t!="string")throw new Error("add(): term must be an Alias or a string");if(e===void 0)throw new Error("add(): impl must be provided when term is a string");if(typeof e=="string")return new _(t,this.parse(e),{canonize:!0});if(e instanceof K)return new _(t,e,{canonize:!0});if(typeof e=="function")return new pt(t,e);throw new Error("add(): impl must be an Expr, a string, or a function with a signature Expr => ... => Expr")}maybeAdd(t,e){return this.known[t]?this.allow.add(t):this.add(t,e),this}bulkAdd(t){for(let e of t){let s=e.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);if(!s)throw new Error("bulkAdd: invalid declaration: "+e);s[2]===""?this.remove(s[1]):this.add(s[1],this.parse(s[2]))}return this}restrict(t){return this.allow=N(this.allow,t),this}showRestrict(t="+"){let e=[],s=!0;for(let r of[...N(this.allow,t)].sort()){let i=r.match(/^[A-Z]$/);e.length&&!(s&&i)&&e.push(" "),e.push(r),s=i}return e.join("")}remove(t){return this.known[t].outdated=!0,delete this.known[t],this.allow.delete(t),this}getTerms(){let t={};for(let e of Object.keys(this.known))this.allow.has(e)&&(t[e]=this.known[e]);return t}declare(){return tt(this.getTerms())}parse(t,e={}){if(typeof t!="string")throw new Error("parse: source must be a string, got "+typeof t);let s=t.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter(h=>h.match(/\S/)),r={...e.env},i=new E;for(let h of s){let[a,l,c]=h.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(i instanceof _&&(i.outdated=!0),i=this.parseLine(c,r,e),l!==void 0){if(r[l]!==void 0)throw new Error("Attempt to redefine a known term: "+l);i=new _(l,i),r[l]=i}}return i}parseLine(t,e={},s={}){let r={numbers:s.numbers??this.hasNumbers,lambdas:s.lambdas??this.hasLambdas,allow:N(this.allow,s.allow)};r.numbers?r.allow.add("+"):r.allow.delete("+");let i=dt.split(t),h=new E,a=[h],l=s.scope||n;for(let c of i)if(c==="(")a.push(h);else if(c===")"){if(a.length<2)throw new Error("unbalanced input: extra closing parenthesis"+t);let f=H(a.pop()),u=a.pop();a.push(u.apply(f))}else if(c==="->"){if(!r.lambdas)throw new Error("Lambdas not supported, allow them explicitly");a.push(new C(a.pop(),e))}else if(c.match(/^[0-9]+$/)){if(!r.numbers)throw new Error("Church numbers not supported, allow them explicitly");let f=a.pop();a.push(f.apply(new Y(c)))}else{let f=a.pop();if(!e[c]&&this.known[c]&&!r.allow.has(c))throw new Error("Term '"+c+"' is not in the restricted set "+[...r.allow].sort().join(" "));let u=e[c]??this.known[c]??(e[c]=new V(c,l));a.push(f.apply(u))}if(a.length!==1)throw new Error("unbalanced input: missing "+(a.length-1)+" closing parenthesis:"+t);return H(a.pop())}toJSON(){return{version:"1.1.1",allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,annotate:this.annotate,terms:this.declare()}}};x.classes=X;x.vars=function(n={}){let t={};return new Proxy({},{get:(e,s)=>(s in t||(t[s]=new V(s,n)),t[s])})};x.church=n=>new Y(n);for(let n in L)x[n]=L[n];x.native=L;x.declare=tt;et.exports={SKI:x}});var nt=j((jt,rt)=>{var{SKI:A}=P(),{Expr:Et,FreeVar:wt,Alias:st,Lambda:At}=A.classes,$=class{constructor(t={}){let{input:e,vars:s,cases:r,allow:i,numbers:h,lambdas:a,subst:l,engine:c,engineFull:f,...u}=t;this.engine=c??new A,this.engineFull=f??new A,this.restrict={allow:i,numbers:h??!1,lambdas:a??!1},this.vars={},this.subst=Array.isArray(l)?l:[l??"phi"];let D={};for(let p of s??[]){let b=this.engineFull.parse(p,{env:D,scope:this});if(b instanceof A.classes.Alias)this.vars[b.name]=new st(b.name,b.impl,{terminal:!0,canonize:!1});else if(b instanceof A.classes.FreeVar)this.vars[b.name]=b;else throw new Error("Unsupported given variable type: "+p)}this.input=[];for(let p of Array.isArray(e)?e:[e])this.addInput(p);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");l&&(this.input[0].fancy=this.subst[0]),this.varsFull={...this.vars,...D};for(let p of this.input){if(p.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+p.name);this.varsFull[p.name]=p.placeholder}this.cases=[],this.title=u.title,u.descr=gt(u.descr),this.descr=u.descr,this.meta=u;for(let p of r??[])this.add(...p)}allowed(){let t=this.restrict.allow??"",e=Object.keys(this.vars).sort();return t?this.engine.showRestrict(t+"+"+e.join(" ")):e.map(s=>"+"+s).join(" ")}addInput(t){if(typeof t!="object"&&(t={name:t}),typeof t.name!="string")throw new Error("quest 'input' field must be a string or a {name: string, ...} object");t.placeholder=new A.classes.FreeVar(t.name),this.input.push(t)}add(t,...e){typeof t=="string"?(e.unshift(t),t={}):t={...t},t.engine=t.engine??this.engineFull,t.vars=t.vars??this.varsFull;let s=this.input.map(r=>r.placeholder);return this.cases.push(t.caps?new R(s,t,e):new Z(s,t,e)),this}prepare(...t){if(t.length!==this.input.length)throw new Error("Solutions provided "+t.length+" terms where "+this.input.length+" are expected");let e=0,s=[],r={...this.vars};for(let i=0;i<t.length;i++){let h=this.input[i],a=this.engine.parse(t[i],{env:r,allow:h.allow??this.restrict.allow,numbers:h.numbers??this.restrict.numbers,lambdas:h.lambdas??this.restrict.lambdas});e+=a.weight();let l=a instanceof wt?a:new st(h.fancy??h.name,a,{terminal:!0,canonize:!1});r[h.name]=l,s.push(l)}return{prepared:s,weight:e}}check(...t){try{let{prepared:e,weight:s}=this.prepare(...t),r=this.cases.map(a=>a.check(...e)),i=r.reduce((a,l)=>a&&l.pass,!0),h=r.reduce((a,l)=>a+l.steps,0);return{expr:e[0],input:e,pass:i,steps:h,details:r,weight:s}}catch(e){return{pass:!1,details:[],exception:e,steps:0,input:t}}}show(){return[...this.cases]}},q=class{constructor(t,e){this.max=e.max??1e3,this.note=e.note,this.vars={...e.vars??{}},this.input=t,this.engine=e.engine}parse(t){return new T(this.engine.parse(t,{env:this.vars,scope:this}),this.input)}check(...t){throw new Error("not implemented")}},Z=class extends q{constructor(t,e,s){if(s.length!==2)throw new Error("Case accepts exactly 2 strings");super(t,e),[this.e1,this.e2]=s.map(r=>this.parse(r))}check(...t){let e=this.e1.apply(t),s=e.run({max:this.max}),i=this.e2.apply(t).run({max:this.max}),h=null;return!s.final||!i.final?h="failed to reach normal form in "+this.max+" steps":h=s.expr.diff(i.expr),{pass:!h,reason:h,steps:s.steps,start:e,found:s.expr,expected:i.expr,note:this.note,args:t,case:this}}},xt={normal:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0},R=class extends q{constructor(t,e,s){if(super(t,e),s.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!e.caps||typeof e.caps!="object"||!Object.keys(e.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");let r=Object.keys(e.caps).filter(i=>!xt[i]);if(r.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+r.join(", "));this.expr=this.parse(s[0]),this.caps=e.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.normal=!0),this.caps.affine&&(delete this.caps.affine,this.caps.normal=!0,this.caps.duplicate=!1)}check(...t){let e=this.expr.apply(t),s=e.run({max:this.max}),r=s.expr.infer({max:this.max}),i=[];for(let h in this.caps)r[h]!==this.caps[h]&&i.push("expected property "+h+" to be "+this.caps[h]+", found "+r[h]);return{pass:!i.length,reason:i?i.join(`
`):null,steps:s.steps,start:e,found:s.expr,case:this,note:this.note,args:t}}},T=class{constructor(t,e){this.expr=t,this.vars=e}apply(t){if(t.length!==this.vars.length)throw new Error("Subst: expected "+this.vars.length+" terms, got "+t.length);let e=this.expr;for(let s=0;s<this.vars.length;s++)e=e.subst(this.vars[s],t[s])??e;return e}};function gt(n){return n===void 0?n:Array.isArray(n)?n.join(" "):""+n}rt.exports={Quest:$}});var bt=j((St,ht)=>{var it=P(),at=nt();ht.exports={...it,...at};typeof window<"u"&&(window.SKI=it.SKI,window.SKI.Quest=at.Quest)});bt();})();
//# sourceMappingURL=ski-interpreter.min.js.map
