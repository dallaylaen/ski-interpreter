(()=>{var A=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var K=A((St,B)=>{var F=class{constructor(...t){let e="$|(\\s+)|"+t.map(s=>"(?:"+s+")").sort((s,r)=>r.length-s.length).join("|");this.rex=new RegExp(e,"gys")}split(t){this.rex.lastIndex=0;let e=[...t.matchAll(this.rex)],r=e.pop()?.index??0;if(r!==t.length)throw new Error("Unknown tokens at pos "+r+"/"+t.length+" starting with "+t.substring(r));return e.filter(i=>i[1]===void 0).map(i=>i[0])}},it=new F("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");function at(n,t){if(!t)return n;let e=new Set([...n]),s=0,r=[i=>{e=new Set([i]),s=1},i=>{e.add(i)},i=>{e.delete(i)}];for(let i of it.split(t))i==="="?s=0:i==="+"?s=1:i==="-"?s=2:r[s](i);return e}function lt(n,t){let e=new Set,s=new Set;for(let r=0;r<n.length;r++){let i=t.get(n[r])??0;i?i>1&&s.add(r):e.add(r)}return[e,s]}function ot(n,t){for(let e of n)if(!t.has(e))return!1;return!0}B.exports={Tokenizer:F,restrict:at,skipDup:lt,isSubset:ot}});var G=A((Et,W)=>{"use strict";var{skipDup:ht,isSubset:ut}=K(),q={terse:!0,max:1e3,maxArgs:32},p=class n{constructor(){if(new.target===n)throw new Error("Attempt to instantiate abstract class Expr")}postParse(){return this}apply(...t){return t.length>0?new b(this,...t):this}expand(){return this}freeVars(){let t=this.getSymbols(),e=new Set;for(let[s,r]of t)s instanceof f&&e.add(s);return e}hasLambda(){return this.getSymbols().has(n.lambdaPlaceholder)}freeOnly(){for(let[t,e]of this.getSymbols())if(!(t instanceof f))return!1;return!0}getSymbols(){return new Map([[this,1]])}replace(t,e={}){let s=[];if(t.length===0)return this;for(let r of t){let i=Array.isArray(r)?r:[r,r];if(i[0]=i[0].guess(e).expr,!i[0])throw new Error("Failed to canonize term "+r);if(i.length!==2)throw new Error("Expected a pair of terms to replace, got "+r);s.push(i)}return this._replace(s,e)??this}_replace(t,e){let s=this.guess(e).expr;for(let[r,i]of t)if(s.equals(r))return i;return null}weight(){return 1}guess(t={}){let e=t.max??q.max,s=t.maxArgs??q.maxArgs;return this._guess({max:e,maxArgs:s,index:0})}_guess(t,e=[],s=0){if(e.length>t.maxArgs||s>t.max)return{normal:!1,steps:s};if(this.freeOnly())return{normal:!0,steps:s,...Q(e,this)};let r=this.run({max:(t.max-s)/3});if(s+=r.steps,!r.final)return{normal:!1,steps:s};if(r.steps!==0)return r.expr._guess(t,e,s);if(this._firstVar())return{normal:!1,steps:s};let i=U(e.length+t.index);return this.apply(i)._guess(t,[...e,i],s)}_aslist(){return[this]}_firstVar(){return!1}*lambdify(t={}){let e=_(this,t);yield*I(e,t)}*rewriteSKI(t={}){let e=0,s=this;for(;;){let r={max:t.max??1,steps:0},i=s._rski(r),l=r.steps===0;if(yield{expr:s,steps:e,final:l},l)break;s=i,e+=r.steps}}renameVars(t){return this}_rski(t){return this}reduce(t){return null}subst(t,e){return null}step(){return{expr:this,steps:0,changed:!1}}run(t={},...e){t instanceof n&&(e.unshift(t),t={});let s=e?this.apply(...e):this,r=t.steps??0,i=Math.max(t.max??q.max,1)+r,l=!1;for(;r<i;){let a=s.step();if(!a.changed){l=!0;break}r+=a.steps,s=a.expr}if(t.throw&&!l)throw new Error("Failed to compute expression in "+i+" steps");return{final:l,steps:r,expr:s}}*walk(t={}){let e=t.max??1/0,s=0,r=this,i=!1;for(;s<e;){let l=r.step();if(l.changed||(i=!0),yield{expr:r,steps:s,final:i},i)break;s+=l.steps,r=l.expr}}equals(t){return this===t?!0:t instanceof P?t.equals(this):!1}contains(t){return this===t||this.equals(t)}expect(t,e=""){if(e=e?e+": ":"",!(t instanceof n))throw new Error(e+"attempt to expect a combinator to equal something else: "+t);if(this.equals(t))return;let s=new Error(e+"found term "+this+" but expected "+t);throw s.expected=t.toString(),s.actual=this.toString(),s}toString(t={}){throw new Error("No toString() method defined in class "+this.constructor.name)}needsParens(t){return!1}toJSON(){return this.expand().toString({terse:!1})}},b=class n extends p{constructor(t,...e){if(e.length===0)throw new Error("Attempt to create an application with no arguments (likely interpreter bug)");super(),this.arg=e.pop(),this.fun=e.length?new n(t,...e):t,this.final=!1,this.arity=this.fun.arity>0?this.fun.arity-1:0}weight(){return this.fun.weight()+this.arg.weight()}getSymbols(){let t=this.fun.getSymbols();for(let[e,s]of this.arg.getSymbols())t.set(e,(t.get(e)??0)+s);return t}_guess(t,e=[],s=0){if(e.length>t.maxArgs||s>t.max)return{normal:!1,steps:s};let r=super._guess(t,e,s);if(r.normal)return r;s=r.steps;let[i,...l]=this._aslist();if(!(i instanceof f))return{normal:!1,steps:s};let a=!1,o=!1,h=[];for(let d of l){let u=d._guess({...t,maxArgs:t.maxArgs-e.length,max:t.max-s,index:e.length+t.index});if(s+=u.steps,!u.normal)return{normal:!1,steps:s};h.push(u.expr),a=a||u.discard,o=o||u.duplicate}return{normal:!0,steps:s,...Q(e,new n(i,...h),{discard:a,duplicate:o})}}_firstVar(){return this.fun._firstVar()}apply(...t){return t.length===0?this:new n(this,...t)}expand(){return this.fun.expand().apply(this.arg.expand())}_replace(t,e){let s=super._replace(t,e);if(s)return s;let[r,i]=this.split();return(r._replace(t,e)??r).apply(i._replace(t,e)??i)}renameVars(t){return this.fun.renameVars(t).apply(this.arg.renameVars(t))}subst(t,e){let s=this.fun.subst(t,e),r=this.arg.subst(t,e);return s||r?(s??this.fun).apply(r??this.arg):null}step(){if(!this.final){if(this.arity===0){let s=this.fun.reduce([this.arg]);if(s)return{expr:s,steps:1,changed:!0}}let t=this.fun.step();if(t.changed)return{expr:t.expr.apply(this.arg),steps:t.steps,changed:!0};let e=this.arg.step();if(e.changed)return{expr:this.fun.apply(e.expr),steps:e.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}reduce(t){return this.fun.reduce([this.arg,...t])}split(){return[this.fun,this.arg]}_aslist(){return[...this.fun._aslist(),this.arg]}_rski(t){return t.steps>=t.max?this:this.fun._rski(t).apply(this.arg._rski(t))}equals(t){return t instanceof n?this.fun.equals(t.fun)&&this.arg.equals(t.arg):super.equals(t)}contains(t){return this.fun.contains(t)||this.arg.contains(t)||super.contains(t)}needsParens(t){return!t}toString(t={}){let e=this.fun.toString(t),s=this.fun.needsParens(!0)?"("+e+")":e;if(t.terse??q.terse){let r=this.arg.toString(t);this.arg.needsParens(!1)&&(r="("+r+")");let i=s.match(/\)$/)||r.match(/^\(/)||s.match(/[A-Z]$/)&&r.match(/^[a-z]/i)?"":" ";return s+i+r}else return s+"("+this.arg.toString(t)+")"}},z=class extends p{constructor(t){if(super(),typeof t!="string"||t.length===0)throw new Error("Attempt to create a named term with improper name");this.name=t}toString(){return this.name}},ct=0,f=class extends z{constructor(t){super(t),this.id=++ct}subst(t,e){return this===t?e:null}weight(){return 0}_firstVar(){return!0}toString(t={}){return t.html&&/^[a-z]$/.test(this.name)?"<var>"+this.name+"</var>":this.name}},S=class extends z{constructor(t,e,s={}){super(t),this.impl=e,s.apply&&(this.onApply=s.apply),this.arity=s.arity??1;let r=s.canonize??!0?this.guess():{normal:!1};s.arity||(this.arity=r.arity||1),this.note=s.note??r.expr?.toString({terse:!0,html:!0})}apply(...t){if(this.onApply&&t.length>=1){if(typeof this.onApply!="function")throw new Error("Native combinator "+this+" has an invalid onApply property  of type"+typeof this.onApply+": "+this.onApply);let e=this.onApply(t[0]);if(e instanceof p)return e.apply(...t.slice(1))}return super.apply(...t)}_rski(t){if(this===w.I||this===w.K||this===w.S||t.steps>=t.max)return this;let e=this.guess().expr;return e?(t.steps++,e._rski(t)):this}reduce(t){if(t.length<this.arity)return null;let e=0,s=this.impl;for(;typeof s=="function";){if(e>=t.length)return null;s=s(t[e++])}if(!(s instanceof p))throw new Error("Native combinator "+this+" reduced to a non-expression: "+s);return s.apply(...t.slice(e))}toJSON(){return"Native:"+this.name}},w={};function k(n,t,e){w[n]=new S(n,t,e)}var g=class n extends p{constructor(t,e){if(Array.isArray(t)){if(t.length===0)throw new Error("empty argument list in lambda constructor");let[r,...i]=t,l=new Set([r.name]);for(;i.length>0;){let a=i.pop();if(l.has(a.name))throw new Error("Duplicate free var name "+a+" in lambda expression");l.add(a.name),e=new n(a,e)}t=r}super();let s=new f(t.name);this.arg=s,this.impl=e.subst(t,s)??e,this.arity=1}getSymbols(){let t=this.impl.getSymbols();return t.delete(this.arg),t.set(p.lambdaPlaceholder,(t.get(p.lambdaPlaceholder)??0)+1),t}weight(){return this.impl.weight()+1}_guess(t,e=[],s=0){if(e.length>t.maxArgs)return{normal:!1,steps:s};let r=U(e.length+t.index);return this.reduce([r])._guess(t,[...e,r],s+1)}reduce(t){if(t.length===0)return null;let[e,...s]=t;return(this.impl.subst(this.arg,e)??this.impl).apply(...s)}subst(t,e){if(t===this.arg)return null;let s=this.impl.subst(t,e);return s?new n(this.arg,s):null}expand(){return new n(this.arg,this.impl.expand())}renameVars(t){let e=new f(t.next().value),s=this.impl.subst(this.arg,e)??this.impl;return new n(e,s.renameVars(t))}_rski(t){let e=this.impl._rski(t);if(t.steps>=t.max)return new n(this.arg,e);if(t.steps++,e===this.arg)return w.I;if(!e.getSymbols().has(this.arg))return w.K.apply(e);if(e instanceof b){let[s,r]=e.split();return r===this.arg&&!s.getSymbols().has(this.arg)?s._rski(t):w.S.apply(new n(this.arg,s)._rski(t),new n(this.arg,r)._rski(t))}throw new Error("Don't know how to convert to SKI"+this)}_replace(t,e){let s=super._replace(t,e);return s||new n(this.arg,this.impl._replace(t,e)??this.impl)}equals(t){if(!(t instanceof n))return super.equals(t);let e=new f("t");return t.reduce([e]).equals(this.reduce([e]))}contains(t){return this.equals(t)||this.impl.contains(t)}toString(t={}){let e=t.html?" &mapsto; ":"->";return this.arg.toString(t)+e+this.impl.toString(t)}needsParens(t){return!0}},j=class n extends S{constructor(t){let e=Number.parseInt(t);if(!(e>=0))throw new Error("Church number must be a non-negative integer");let s=""+e,r=i=>l=>{let a=l;for(let o=e;o-- >0;)a=i.apply(a);return a};super(s,r,{arity:2,canonize:!1,note:s}),this.n=e,this.arity=2}equals(t){return t instanceof n?this.n===t.n:super.equals(t)}},P=class extends z{constructor(t,e,s={}){super(t),this.impl=e,s.note&&(this.note=s.note);let r=s.canonize?e.guess({max:s.max,maxArgs:s.maxArgs}):{normal:!1};this.arity=r.proper&&r.arity||0,this.proper=r.proper??!1,this.terminal=s.terminal??this.proper,this.canonical=r.expr}getSymbols(){return this.terminal?new Map([[this,1]]):this.impl.getSymbols()}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}subst(t,e){return this.impl.subst(t,e)}_guess(t,e=[],s=0){return this.impl._guess(t,e,s)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}reduce(t){return t.length<this.arity?null:this.impl.apply(...t)}_firstVar(){return this.impl._firstVar()}equals(t){return t.equals(this.impl)}contains(t){return this.impl.contains(t)}_rski(t){return this.impl._rski(t)}toString(t){return this.outdated?this.impl.toString(t):super.toString(t)}needsParens(t){return this.outdated?this.impl.needsParens():!1}};k("I",n=>n);k("K",n=>t=>n);k("S",n=>t=>e=>n.apply(e,t.apply(e)));k("B",n=>t=>e=>n.apply(t.apply(e)));k("C",n=>t=>e=>n.apply(e).apply(t));k("W",n=>t=>n.apply(t).apply(t));k("+",n=>t=>e=>t.apply(n.apply(t,e)),{note:"<var>n</var> &mapsto; <var>n</var> + 1 <i>or</i> SB",apply:n=>n instanceof j?new j(n.n+1):null});function Q(n,t,e={}){let s=t.getSymbols(),[r,i]=ht(n,s);return{expr:n.length?new g(n,t):t,...e.synth?{}:{arity:n.length},...r.size?{skip:r}:{},...i.size?{dup:i}:{},duplicate:!!i.size||e.duplicate||!1,discard:!!r.size||e.discard||!1,proper:ut(s.keys(),new Set(n))}}function _(n){if(n instanceof b)return _(n.fun).apply(_(n.arg));if(n instanceof g)return new g(n.arg,_(n.impl));if(n instanceof P)return _(n.impl);let t=n.guess();if(t.expr)return t.expr;throw new Error("Failed to canonize expression: "+n)}function*I(n,t={},e={steps:0}){if(yield{expr:n,steps:e.steps,comment:"(self)"},n.freeOnly())return;let s=n.weight();if(n instanceof g)for(let i of I(n.impl,t,e)){let l=new g(n.arg,i.expr);l.weight()<s&&(s=l.weight(),yield{expr:l,steps:e.steps,comment:"(lambda)"+i.comment})}if(n instanceof b){let[i,l]=n.split();for(let a of I(i,t,e)){let o=a.expr.apply(l);o.weight()<s&&(s=o.weight(),i=a.expr,yield{expr:o,steps:e.steps,comment:"(fun)"+a.comment})}for(let a of I(l,t,e)){let o=i.apply(a.expr);o.weight()<s&&(s=o.weight(),yield{expr:o,steps:e.steps,comment:"(arg)"+a.comment})}}let r=n.guess({max:t.max,maxArgs:t.maxArgs});e.steps+=r.steps,r.expr&&r.expr.weight()<s&&(yield{expr:r.expr,steps:e.steps,comment:"(canonical)"})}function U(n){return new f("abcdefgh"[n]??"x"+n)}p.lambdaPlaceholder=new S("->",n=>n,{arity:1,canonize:!1,note:"Lambda placeholder",apply:n=>{throw new Error("Attempt to use a placeholder in expression")}});W.exports={Expr:p,App:b,FreeVar:f,Lambda:g,Native:S,Alias:P,Church:j,globalOptions:q,native:w}});var Z=A((At,X)=>{var{Tokenizer:pt,restrict:$}=K(),{globalOptions:ft,Expr:O,App:vt,FreeVar:V,Lambda:H,Native:mt,Alias:y,Church:R,native:N}=G(),E=class extends O{apply(...t){return t.length?t.shift().apply(...t):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}},C=class n extends E{constructor(t,e={}){if(super(),this.impl=new E,t instanceof V)this.terms=[t];else if(t instanceof n){if(!(t.impl instanceof V))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...t.terms,t.impl]}else throw new Error("Expected FreeVar or PartialLambda")}apply(t,...e){if(t===null||e.length!==0)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(t),this}postParse(){return new H(this.terms,this.impl)}},dt=new pt("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+"),m=class n{constructor(t={}){this.annotate=t.annotate??!1,this.known={...N},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known));for(let e in t.terms??{})t.terms[e].match(/^Native:/)||this.add(e,t.terms[e]);this.hasNumbers=t.numbers??!0,this.hasLambdas=t.lambdas??!0,t.allow&&this.restrict(t.allow)}add(t,e,s){if(typeof t=="string")if(typeof e=="string")t=new y(t,this.parse(e),{canonize:!0});else if(e instanceof O)t=new y(t,e,{canonize:!0});else throw new Error("add: term must be an Alias or a string and impl must be an Expr or a string");else t instanceof y&&(t=new y(t.name,t.impl,{canonize:!0}));if(!(t instanceof y))throw new Error("add: term must be an Alias or a string (accompanied with an implementation)");return this.annotate&&s===void 0&&t.canonical&&(s=t.canonical.toString({terse:!0,html:!0})),s!==void 0&&(t.note=s),this.known[""+t]=t,this.allow.add(""+t),this}maybeAdd(t,e){return this.known[t]?this.allow.add(t):this.add(t,e),this}restrict(t){return this.allow=$(this.allow,t),this}showRestrict(t="+"){let e=[],s=!0;for(let r of[...$(this.allow,t)].sort()){let i=r.match(/^[A-Z]$/);e.length&&!(s&&i)&&e.push(" "),e.push(r),s=i}return e.join("")}remove(t){return this.known[t].outdated=!0,delete this.known[t],this.allow.delete(t),this}getTerms(){let t={};for(let e of Object.keys(this.known))this.allow.has(e)&&(t[e]=this.known[e]);return t}parse(t,e={},s={}){if(typeof t!="string")throw new Error("parse: source must be a string, got "+typeof t);let r=t.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter(a=>a.match(/\S/)),i={...e},l=new E;for(let a of r){let[o,h,d]=a.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(l instanceof y&&(l.outdated=!0),l=this.parseLine(d,i,s),h!==void 0){if(i[h]!==void 0)throw new Error("Attempt to redefine a known term: "+h);l=new y(h,l),i[h]=l}}for(let a in i)!e[a]&&i[a]instanceof n.classes.FreeVar&&(e[a]=i[a]);return l}parseLine(t,e={},s={}){let r={numbers:s.numbers??this.hasNumbers,lambdas:s.lambdas??this.hasLambdas,allow:$(this.allow,s.allow)};r.numbers?r.allow.add("+"):r.allow.delete("+");let i=dt.split(t),l=new E,a=[l];for(let o of i)if(o==="(")a.push(l);else if(o===")"){if(a.length<2)throw new Error("unbalanced input: extra closing parenthesis"+t);let h=a.pop().postParse(),d=a.pop();a.push(d.apply(h))}else if(o==="->"){if(!r.lambdas)throw new Error("Lambdas not supported, allow them explicitly");a.push(new C(a.pop(),e))}else if(o.match(/^[0-9]+$/)){if(!r.numbers)throw new Error("Church numbers not supported, allow them explicitly");let h=a.pop();a.push(h.apply(new R(o)))}else{let h=a.pop();if(!e[o]&&this.known[o]&&!r.allow.has(o))throw new Error("Term '"+o+"' is not in the restricted set "+[...r.allow].sort().join(" "));let d=e[o]??this.known[o]??(e[o]=new V(o));a.push(h.apply(d))}if(a.length!==1)throw new Error("unbalanced input: missing "+(a.length-1)+" closing parenthesis:"+t);return a.pop().postParse()}toJSON(){return{allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,terms:this.getTerms(),annotate:this.annotate}}};m.free=(...n)=>n.map(t=>new V(t));m.church=n=>new R(n);m.classes={Expr:O,Native:mt,Alias:y,FreeVar:V,Lambda:H,Church:R};for(let n in N)m[n]=N[n];m.native=N;m.options=ft;m.lambdaPlaceholder=O.lambdaPlaceholder;X.exports={SKI:m}});var et=A((qt,tt)=>{var{SKI:v}=Z(),{Expr:_t,FreeVar:wt,Alias:Y,Lambda:gt}=v.classes,D=class{constructor(t={}){let{input:e,vars:s,cases:r,allow:i,numbers:l,lambdas:a,subst:o,engine:h,engineFull:d,...u}=t;this.engine=h??new v,this.engineFull=d??new v,this.restrict={allow:i,numbers:l??!1,lambdas:a??!1},this.vars={},this.subst=Array.isArray(o)?o:[o??"phi"];let T={};for(let c of s??[]){let x=this.engineFull.parse(c,T);if(x instanceof v.classes.Alias)this.vars[x.name]=new Y(x.name,x.impl,{terminal:!0,canonize:!1});else if(x instanceof v.classes.FreeVar)this.vars[x.name]=x;else throw new Error("Unsupported given variable type: "+c)}this.input=[];for(let c of Array.isArray(e)?e:[e])this.addInput(c);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");o&&(this.input[0].fancy=this.subst[0]),this.varsFull={...this.vars,...T};for(let c of this.input){if(c.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+c.name);this.varsFull[c.name]=c.placeholder}this.cases=[],this.title=u.title,u.descr=xt(u.descr),this.descr=u.descr,this.meta=u;for(let c of r??[])this.add(...c)}allowed(){let t=this.restrict.allow??"",e=Object.keys(this.vars).sort();return t?this.engine.showRestrict(t+"+"+e.join(" ")):e.map(s=>"+"+s).join(" ")}addInput(t){if(typeof t!="object"&&(t={name:t}),typeof t.name!="string")throw new Error("quest 'input' field must be a string or a {name: string, ...} object");[t.placeholder]=v.free(t.name),this.input.push(t)}add(t,...e){typeof t=="string"?(e.unshift(t),t={}):t={...t},t.engine=t.engine??this.engineFull,t.vars=t.vars??this.varsFull;let s=this.input.map(r=>r.placeholder);return this.cases.push(t.caps?new J(s,t,e):new M(s,t,e)),this}prepare(...t){if(t.length!==this.input.length)throw new Error("Solutions provided "+t.length+" terms where "+this.input.length+" are expected");let e=0,s=[],r={...this.vars};for(let i=0;i<t.length;i++){let l=this.input[i],a=this.engine.parse(t[i],r,{allow:l.allow??this.restrict.allow,numbers:l.numbers??this.restrict.numbers,lambdas:l.lambdas??this.restrict.lambdas});e+=a.weight();let o=a instanceof wt?a:new Y(l.fancy??l.name,a,{terminal:!0,canonize:!1});r[l.name]=o,s.push(o)}return{prepared:s,weight:e}}check(...t){try{let{prepared:e,weight:s}=this.prepare(...t),r=this.cases.map(a=>a.check(...e)),i=r.reduce((a,o)=>a&&o.pass,!0),l=r.reduce((a,o)=>a+o.steps,0);return{expr:e[0],input:e,pass:i,steps:l,details:r,weight:s}}catch(e){return{pass:!1,details:[],exception:e,steps:0,input:t}}}show(){return[...this.cases]}},L=class{constructor(t,e){this.max=e.max??1e3,this.note=e.note,this.vars={...e.vars??{}},this.input=t,this.engine=e.engine}parse(t){return new gt(this.input,this.engine.parse(t,this.vars))}check(...t){throw new Error("not implemented")}},M=class extends L{constructor(t,e,s){if(s.length!==2)throw new Error("Case accepts exactly 2 strings");super(t,e),[this.e1,this.e2]=s.map(r=>this.parse(r))}check(...t){let e=(a,o)=>a.reduce(o)??a.apply(...o),s=e(this.e1,t),r=s.run({max:this.max}),i=e(this.e2,t).run({max:this.max}),l=null;return!r.final||!i.final?l="failed to reach normal form in "+this.max+" steps":r.expr.equals(i.expr)||(l="expected: "+i.expr),{pass:!l,reason:l,steps:r.steps,start:s,found:r.expr,expected:i.expr,note:this.note,args:t,case:this}}},yt={normal:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0},J=class extends L{constructor(t,e,s){if(super(t,e),s.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!e.caps||typeof e.caps!="object"||!Object.keys(e.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");let r=Object.keys(e.caps).filter(i=>!yt[i]);if(r.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+r.join(", "));this.expr=this.parse(s[0]),this.caps=e.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.normal=!0),this.caps.affine&&(delete this.caps.affine,this.caps.normal=!0,this.caps.duplicate=!1)}check(...t){let e=this.expr.apply(...t),s=e.run({max:this.max}),r=s.expr.guess({max:this.max}),i=[];for(let l in this.caps)r[l]!==this.caps[l]&&i.push("expected property "+l+" to be "+this.caps[l]+", found "+r[l]);return{pass:!i.length,reason:i?i.join(`
`):null,steps:s.steps,start:e,found:s.expr,case:this,note:this.note,args:t}}};function xt(n){return n===void 0?n:Array.isArray(n)?n.join(" "):""+n}tt.exports={Quest:D}});var bt=A((zt,nt)=>{var st=Z(),rt=et();nt.exports={...st,...rt};typeof window<"u"&&(window.SKI=st.SKI,window.SKI.Quest=rt.Quest)});bt();})();
//# sourceMappingURL=ski-interpreter.min.js.map
