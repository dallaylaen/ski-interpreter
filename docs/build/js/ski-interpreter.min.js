(()=>{var t={10:(t,s,e)=>{const r=e(755),n=e(76);t.exports={...r,...n},"undefined"!=typeof window&&(window.SKI=r.SKI,window.SKI.Quest=n.Quest)},695:(t,s,e)=>{const{missingIndices:r}=e(502);class n{constructor(){if(new.target===n)throw new Error("Attempt to instantiate abstract class Expr");this.arity=1/0}postParse(){return this}apply(...t){return t.length>0?new l(this,...t):this}expand(){return this}freeVars(){return new Set}guessArity(t={}){const s=t.max??1e3,e=t.maxArgs??32;let n=this;const i=[];for(let t=0;t<e;t++){const e=n.run({max:s});if(!e.final)break;if(n=e.expr,n.acceptsNoArgs()){const s=r(i,n.freeVars());return{arity:t,proper:n.hasOnly(new Set(i)),found:!0,canonical:i.length?new w(i,n):n,...s.size?{skip:s}:{}}}const a=new f("x"+t);i.push(a),n=n.apply(a)}return{proper:!1,found:!1}}hasOnly(t){return t.has(this)}acceptsNoArgs(){return!1}reduce(t){return null}subst(t,s){return null}step(){return{steps:0,expr:this}}run(t={},...s){t instanceof n&&(s.unshift(t),t={});let e=s?this.apply(...s):this,r=t.steps??0;const i=(t.max??1e3)+r;let a=!1;for(;r<i;){const t=e.step();if(0===t.steps){a=!0;break}r+=t.steps,e=t.expr}if(t.throw&&!a)throw new Error("Failed to compute expression in "+i+" steps");return{final:a,steps:r,expr:e}}*walk(t={}){const s=t.max??1/0;let e=0,r=this,n=!1;for(;e<s;){const t=r.step();if(0===t.steps&&(n=!0),yield{expr:r,steps:e,final:n},n)break;e+=t.steps,r=t.expr}}equals(t){return this===t}expect(t){if(!(t instanceof n))throw new Error("Attempt to expect a combinator to equal something else: "+t);if(this.equals(t))return;const s=new Error("Found term "+this+" but expected "+t);throw s.expected=t.toString(),s.actual=this.toString(),s}toString(t={}){throw new Error("No toString() method defined in class "+this.constructor.name)}needsParens(){return!1}toJSON(){return this.expand().toString({terse:!1})}}const[i,a,o,h]=function*(){for(let t=0;;yield t++);}(),p=new Set([(a<<4)+a,(a<<4)+o,(o<<4)+a,(o<<4)+o,(o<<4)+h,(h<<4)+a,(i<<4)+a]);class l extends n{constructor(t,...s){super(),this.fun=t,this.args=s,this.final=!1}freeVars(){return new Set([...this.fun.freeVars(),...this.args.flatMap((t=>[...t.freeVars()]))])}hasOnly(t){for(const s of[this.fun,...this.args])if(!s.hasOnly(t))return!1;return!0}acceptsNoArgs(){return this.fun.acceptsNoArgs()}apply(...t){return 0===t.length?this:this.fun.apply(...this.args,...t)}expand(){return this.fun.expand().apply(...this.args.map((t=>t.expand())))}subst(t,s){const e=this.fun.subst(t,s);let r=null===e?0:1;const n=[];for(const e of this.args){const i=e.subst(t,s);null===i?n.push(e):(n.push(i),r++)}return r?(e??this.fun).apply(...n):null}step(){if(this.final)return{expr:this,steps:0};let t=0;const s=this.fun.skip,e=(e,r)=>{if(s&&s.has(r))return e;const n=e.step();return t+=n.steps,n.expr},r=e(this.fun,-1),n=this.args.map(e),i=r.reduce(n);return i?{expr:i,steps:t+1}:t?{expr:r.apply(...n),steps:t}:(this.final=!0,{expr:this,steps:0})}equals(t){if(!(t instanceof l))return!1;if(t.args.length!==this.args.length)return!1;if(!this.fun.equals(t.fun))return!1;for(let s=0;s<this.args.length;s++)if(!this.args[s].equals(t.args[s]))return!1;return!0}toString(t={}){if(t.terse){const s=[];let e=0;for(const r of[this.fun,...this.args]){let n=r.toString(t),l=i;n.match(/^[A-Z]$/)?l=o:n.match(/^[a-z][a-z_0-9]*$/)?l=h:n.match(/^[0-9]+$/)||(0!==s.length||r.needsParens())&&(n="("+n+")",l=a),!p.has(e<<4|l)&&s.length>0&&s.push(" "),s.push(n),e=l}return s.join("")}return(this.fun.needsParens()?"("+this.fun+")":this.fun+"")+this.args.map((t=>"("+t+")")).join("")}}class u extends n{constructor(t){if(super(),"string"!=typeof t||0===t.length)throw new Error("Attempt to create a named term with improper name");this.name=t}toString(){return this.name}}let c=0;class f extends u{constructor(t){super(t),this.id=++c}subst(t,s){return this===t?s:null}freeVars(){return new Set([this])}acceptsNoArgs(){return!0}}class w extends n{constructor(t,s){if(Array.isArray(t)){if(0===t.length)throw new Error("empty argument list in lambda constructor");const[e,...r]=t,n=new Set([e.name]);for(;r.length>0;){const t=r.pop();if(n.has(t.name))throw new Error("Duplicate free var name "+t+" in lambda expression");n.add(t.name),s=new w(t,s)}t=e}super();const e=new f(t.name);this.arg=e,this.impl=s.subst(t,e)??s,this.arity=1}freeVars(){const t=this.impl.freeVars();return t.delete(this.arg),t}reduce(t){if(0===t.length)return null;const[s,...e]=t;return(this.impl.subst(this.arg,s)??this.impl).apply(...e)}subst(t,s){if(t===this.arg)return null;const e=this.impl.subst(t,s);return e?new w(this.arg,e):null}expand(){return new w(this.arg,this.impl.expand())}equals(t){if(!(t instanceof w))return!1;const s=new f("t");return t.reduce([s]).equals(this.reduce([s]))}toString(t={}){return this.arg+"->"+this.impl.toString(t)}needsParens(){return!0}}class d extends u{constructor(t,s,e,r={}){super(t),this.arity=s,this.impl=e,void 0!==r.skip&&(this.skip=new Set(r.skip)),void 0!==r.note&&(this.note=r.note)}reduce(t){return t.length<this.arity?null:this.impl(...t.slice(0,this.arity)).apply(...t.slice(this.arity))}toJSON(){return"Native:"+this.name}}class m extends d{constructor(t){const s=Number.parseInt(t);if(!(s>=0))throw new Error("Church number must be a nonnegative integer");super(""+s,2,(function(t,e){let r=e;for(let e=s;e-- >0;)r=t.apply(r);return r})),this.n=s,this.arity=2}equals(t){return t instanceof m&&this.n===t.n}}t.exports={Expr:n,App:l,FreeVar:f,Lambda:w,Native:d,Alias:class extends u{constructor(t,s){super(t),this.impl=s;const e=s.guessArity();this.arity=e.found&&e.proper&&e.arity||0,this.skip=e.skip}freeVars(){return this.impl.freeVars()}expand(){return this.impl.expand()}subst(t,s){return this.impl.subst(t,s)}reduce(t){return t.length<this.arity?null:this.impl.apply(...t)}equals(t){return t.equals(this.impl)}toString(t){return this.outdated?this.impl.toString(t):super.toString(t)}needsParens(){return!!this.outdated&&this.impl.needsParens()}},Church:m}},677:(t,s,e)=>{const{Expr:r,Church:n,FreeVar:i,App:a}=e(695),o={};class h extends r{constructor(t,s={}){if(super(),this.name=t,this.arity=s.arity??1,s.onReduce){const t=s.onReduce;this.reduce=function(s){if(s.length<this.arity)return null;const e=s.slice(0,this.arity),r=s.slice(this.arity);return t.apply(this,[e]).apply(...r)}}}register(){return o[this]=this,this}toString(t={}){return"!"+this.name}}new h("nat",{onReduce:function(t){const s=new i("x"),e=new i("y"),r=t[0].run({max:133120},s,e);if(!r.final)throw new Error(`Church number coercion failed: expression didn't terminate in 133120 steps: ${t[0]}`);let o=r.expr,h=0;for(;;){if(o===e)return new n(h);if(!(o instanceof a&&o.fun===s&&1===o.args.length))throw new Error("Church number coercion failed: expression is not a number: "+t[0]);h++,o=o.args[0]}}}).register(),t.exports={Inspector:h,inspectors:o}},755:(t,s,e)=>{const{Tokenizer:r,restrict:n}=e(502),{Expr:i,App:a,FreeVar:o,Lambda:h,Native:p,Alias:l,Church:u}=e(695),{Inspector:c,inspectors:f}=e(677);class w extends i{apply(...t){return t.length?t.shift().apply(...t):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}}class d extends w{constructor(t,s={}){if(super(),this.impl=new w,t instanceof o)this.terms=[t];else{if(!(t instanceof d))throw new Error("Expected FreeVar or PartialLambda");if(!(t.impl instanceof o))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...t.terms,t.impl]}}apply(t,...s){if(null===t||0!==s.length)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(t),this}postParse(){return new h(this.terms,this.impl)}}const m=new r("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","![a-z][a-z_0-9]*\\b");class g{constructor(t={}){this.known={...x},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known)),(t.inspectors??1)&&(this.inspectors={...f});for(const s in t.terms??{})t.terms[s].match(/^Native:/)||this.add(s,t.terms[s]);this.hasNumbers=t.numbers??!0,this.hasLambdas=t.lambdas??!0,t.allow&&this.restrict(t.allow)}add(t,s,e){if("string"==typeof s)s=new l(t,this.parseLine(s));else{if(!(s instanceof i))throw new Error("add: impl must be an Expr or a string");s=new l(t,s)}return void 0!==e&&(s.note=e),this.known[t]=s,this.allow.add(t),this}maybeAdd(t,s){return this.known[t]?this.allow.add(t):this.add(t,s),this}restrict(t){return this.allow=n(this.allow,t),this}showRestrict(t="+"){const s=[];let e=!0;for(const r of[...n(this.allow,t)].sort()){const t=r.match(/^[A-Z]$/);!s.length||e&&t||s.push(" "),s.push(r),e=t}return s.join("")}remove(t){return this.known[t].outdated=!0,delete this.known[t],this.allow.delete(t),this}getTerms(){const t={};for(const s of Object.keys(this.known))this.allow.has(s)&&(t[s]=this.known[s]);return t}parse(t,s={},e={}){const r=t.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter((t=>t.match(/\S/))),n={...s};let i=new w;for(const t of r){const[s,r,a]=t.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(i instanceof l&&(i.outdated=!0),i=this.parseLine(a,n,e),void 0!==r){if(void 0!==n[r])throw new Error("Attempt to redefine a known term: "+r);i=new l(r,i),n[r]=i}}for(const t in n)!s[t]&&n[t]instanceof g.classes.FreeVar&&(s[t]=n[t]);return i}parseLine(t,s={},e={}){const r={numbers:e.numbers??this.hasNumbers,lambdas:e.lambdas??this.hasLambdas,allow:n(this.allow,e.allow)},i=m.split(t),a=new w,h=[a];for(const e of i)if("("===e)h.push(a);else if(")"===e){if(h.length<2)throw new Error("unbalanced input: extra closing parenthesis"+t);const s=h.pop().postParse(),e=h.pop();h.push(e.apply(s))}else if("->"===e){if(!r.lambdas)throw new Error("Lambdas not supported, allow them explicitly");h.push(new d(h.pop(),s))}else if(e.match(/^[0-9]+$/)){if(!r.numbers)throw new Error("Church numbers not supported, allow them explicitly");const t=h.pop();h.push(t.apply(new u(e)))}else if(e.startsWith("!")){const t=this.inspectors[e];if(!t)throw new Error("Unknown inspector term "+e);h.push(h.pop().apply(t))}else{const t=h.pop();if(!s[e]&&this.known[e]&&!r.allow.has(e))throw new Error("Term "+e+" is not in the restricted set "+[...r.allow].sort().join(" "));const n=s[e]??this.known[e]??(s[e]=new o(e));h.push(t.apply(n))}if(1!==h.length)throw new Error("unbalanced input: missing "+(h.length-1)+" closing parenthesis:"+t);return h.pop().postParse()}toJSON(){return{allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,terms:this.getTerms()}}}g.free=(...t)=>t.map((t=>new o(t))),g.church=t=>new u(t),g.classes={Expr:i,Native:p,Alias:l,FreeVar:o,Lambda:h,Inspector:c};const x={I:new p("I",1,(t=>t),{note:"x -> x"}),K:new p("K",2,((t,s)=>t),{skip:[1],note:"x -> y -> x"}),S:new p("S",3,((t,s,e)=>t.apply(e,s.apply(e))),{note:"x -> y -> z -> x z (y z)"}),B:new p("B",3,((t,s,e)=>t.apply(s.apply(e))),{note:"x -> y -> z -> x (y z)"}),C:new p("C",3,((t,s,e)=>t.apply(e).apply(s)),{note:"x -> y -> z -> x z y"}),W:new p("W",2,((t,s)=>t.apply(s).apply(s)),{note:"x -> y -> x y y"})};for(const t in x)g[t]=x[t];g.native=x,t.exports={SKI:g}},76:(t,s,e)=>{const{SKI:r}=e(755),{Expr:n,FreeVar:i,Alias:a,Lambda:o}=r.classes;class h{constructor(t,s,e={},n={},i=new r){if(2!==s.length)throw new Error("Case accepts exactly 2 strings");const[a,h]=s;this.max=e.max??1e3,this.note=e.note,n={...n};const p=s=>new o(t,i.parse(s,n));this.e1=p(a),this.e2=p(h)}check(...t){const s=(t,s)=>t.reduce(s)??t.apply(...s),e=s(this.e1,t),r=e.expand().run({max:this.max}),n=s(this.e2,t).expand().run({max:this.max});return{pass:r.final&&n.final&&r.expr.equals(n.expr),steps:r.steps+n.steps,start:e,found:r.expr,expected:n.expr,note:this.note,args:t}}}t.exports={Quest:class{constructor(t={}){const{input:s,vars:e,cases:n,allow:i,numbers:a,lambdas:o,subst:h,engine:p,engineFull:l,...u}=t;this.engine=p??new r,this.engineFull=l??new r,this.restrict={allow:i,numbers:a??!1,lambdas:o??!1},this.vars={},this.subst=Array.isArray(h)?h:[h??"phi"];for(const t of e??[]){const s=this.engineFull.parse(t,this.vars);s instanceof r.classes.Alias&&(this.vars[s.name]=s.impl)}if(this.input=r.free(...Array.isArray(s)?s:[s]),0===s.length)throw new Error("input parameter must be string or string[]");this.varsFull={...this.vars};for(const t of this.input){if(t.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+t.name);this.varsFull[t.name]=t}var c;this.cases=[],this.title=u.title,u.descr=void 0===(c=u.descr)?c:Array.isArray(c)?c.join(" "):""+c,this.descr=u.descr,this.meta=u;for(const t of n??[])this.add(...t)}add(t,...s){return"string"==typeof t&&(s.unshift(t),t={}),this.cases.push(new h(this.input,s,t,this.varsFull,this.engineFull)),this}check(...t){try{if(t.length!==this.input.length)throw new Error("Solutions provided "+t.length+" terms where "+this.input.length+" are expected");const s=t.map((t=>"string"==typeof t?this.engine.parse(t,this.vars,this.restrict):t)).map(((t,s)=>new a(this.subst[s]??this.input[s],t))),e=this.cases.map((t=>t.check(...s))),r=e.reduce(((t,s)=>t&&s.pass),!0);return{expr:s[0],pass:r,details:e}}catch(t){return{pass:!1,details:[],exception:t}}}show(){return[...this.cases]}}}},502:t=>{class s{constructor(...t){const s="$|(\\s+)|"+t.map((t=>"(?:"+t+")")).sort(((t,s)=>s.length-t.length)).join("|");this.rex=new RegExp(s,"gys")}split(t){this.rex.lastIndex=0;const s=[...t.matchAll(this.rex)],e=s.pop()?.index??0;if(e!==t.length)throw new Error("Unknown tokens at pos "+e+"/"+t.length+" starting with "+t.substring(e));return s.filter((t=>void 0===t[1])).map((t=>t[0]))}}const e=new s("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");t.exports={Tokenizer:s,restrict:function(t,s){if(!s)return t;let r=new Set([...t]),n=0;const i=[t=>{r=new Set([t]),n=1},t=>{r.add(t)},t=>{r.delete(t)}];for(const t of e.split(s))"="===t?n=0:"+"===t?n=1:"-"===t?n=2:i[n](t);return r},missingIndices:function(t,s){const e=new Set;for(let r=0;r<t.length;r++)s.has(t[r])||e.add(r);return e}}}},s={};!function e(r){var n=s[r];if(void 0!==n)return n.exports;var i=s[r]={exports:{}};return t[r](i,i.exports,e),i.exports}(10)})();