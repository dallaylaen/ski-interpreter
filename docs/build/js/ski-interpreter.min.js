(()=>{var A=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var $=A((Se,B)=>{var F=class{constructor(...e){let t="$|(\\s+)|"+e.map(s=>"(?:"+s+")").sort((s,r)=>r.length-s.length).join("|");this.rex=new RegExp(t,"gys")}split(e){this.rex.lastIndex=0;let t=[...e.matchAll(this.rex)],r=t.pop()?.index??0;if(r!==e.length)throw new Error("Unknown tokens at pos "+r+"/"+e.length+" starting with "+e.substring(r));return t.filter(a=>a[1]===void 0).map(a=>a[0])}},ae=new F("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");function ie(n,e){if(!e)return n;let t=new Set([...n]),s=0,r=[a=>{t=new Set([a]),s=1},a=>{t.add(a)},a=>{t.delete(a)}];for(let a of ae.split(e))a==="="?s=0:a==="+"?s=1:a==="-"?s=2:r[s](a);return t}function le(n,e){let t=new Set,s=new Set;for(let r=0;r<n.length;r++){let a=e.get(n[r])??0;a?a>1&&s.add(r):t.add(r)}return[t,s]}function he(n,e){for(let t of n)if(!e.has(t))return!1;return!0}B.exports={Tokenizer:F,restrict:ie,skipDup:le,isSubset:he}});var G=A((_e,W)=>{"use strict";var{skipDup:oe,isSubset:ue}=$(),S={terse:!0,max:1e3,maxArgs:32},p=class n{constructor(){if(new.target===n)throw new Error("Attempt to instantiate abstract class Expr")}postParse(){return this}apply(...e){return e.length>0?new b(this,...e):this}expand(){return this}freeVars(){let e=this.getSymbols(),t=new Set;for(let[s,r]of e)s instanceof f&&t.add(s);return t}hasLambda(){return this.getSymbols().has(n.lambdaPlaceholder)}freeOnly(){for(let[e,t]of this.getSymbols())if(!(e instanceof f))return!1;return!0}getSymbols(){return new Map([[this,1]])}replace(e,t={}){let s=[];if(e.length===0)return this;for(let r of e){let a=Array.isArray(r)?r:[r,r];if(a[0]=a[0].guess(t).expr,!a[0])throw new Error("Failed to canonize term "+r);if(a.length!==2)throw new Error("Expected a pair of terms to replace, got "+r);s.push(a)}return this._replace(s,t)??this}_replace(e,t){let s=this.guess(t).expr;for(let[r,a]of e)if(s.equals(r))return a;return null}weight(){return 1}guess(e={}){let t=e.max??S.max,s=e.maxArgs??S.maxArgs;return this._guess({max:t,maxArgs:s,index:0})}_guess(e,t=[],s=0){if(t.length>e.maxArgs||s>e.max)return{normal:!1,steps:s};if(this.freeOnly())return{normal:!0,steps:s,...Q(t,this)};let r=this.run({max:(e.max-s)/3});if(s+=r.steps,!r.final)return{normal:!1,steps:s};if(r.steps!==0)return r.expr._guess(e,t,s);if(this._firstVar())return{normal:!1,steps:s};let a=U(t.length+e.index);return this.apply(a)._guess(e,[...t,a],s)}_aslist(){return[this]}_firstVar(){return!1}*lambdify(e={}){let t=q(this,e);yield*I(t,e)}*rewriteSKI(e={}){let t=0,s=this;for(;;){let r={max:e.max??1,steps:0},a=s._rski(r),l=r.steps===0;if(yield{expr:s,steps:t,final:l},l)break;s=a,t+=r.steps}}renameVars(e){return this}_rski(e){return this}reduce(e){return null}subst(e,t){return null}step(){return{expr:this,steps:0,changed:!1}}run(e={},...t){e instanceof n&&(t.unshift(e),e={});let s=t?this.apply(...t):this,r=e.steps??0,a=Math.max(e.max??S.max,1)+r,l=!1;for(;r<a;){let i=s.step();if(!i.changed){l=!0;break}r+=i.steps,s=i.expr}if(e.throw&&!l)throw new Error("Failed to compute expression in "+a+" steps");return{final:l,steps:r,expr:s}}*walk(e={}){let t=e.max??1/0,s=0,r=this,a=!1;for(;s<t;){let l=r.step();if(l.changed||(a=!0),yield{expr:r,steps:s,final:a},a)break;s+=l.steps,r=l.expr}}equals(e){return this===e?!0:e instanceof j?e.equals(this):!1}contains(e){return this===e||this.equals(e)}expect(e,t=""){if(t=t?t+": ":"",!(e instanceof n))throw new Error(t+"attempt to expect a combinator to equal something else: "+e);if(this.equals(e))return;let s=new Error(t+"found term "+this+" but expected "+e);throw s.expected=e.toString(),s.actual=this.toString(),s}toString(e={}){throw new Error("No toString() method defined in class "+this.constructor.name)}needsParens(e){return!1}_spaced(e){return!1}format(e={}){let t=e.html?{brackets:["(",")"],space:" ",var:["<var>","</var>"],lambda:["","-&gt;",""],around:["",""],redex:["<b>","</b>"]}:{brackets:["(",")"],space:" ",var:["",""],lambda:["","->",""],around:["",""],redex:["",""]};return this._format({terse:e.terse??S.terse,brackets:e.brackets??t.brackets,space:e.space??t.space,var:e.var??t.var,lambda:e.lambda??t.lambda,around:e.around??t.around,redex:e.redex??t.redex},0)}_format(e,t){throw new Error("No _format() method defined in class "+this.constructor.name)}toJSON(){return this.expand().toString({terse:!1})}},b=class n extends p{constructor(e,...t){if(t.length===0)throw new Error("Attempt to create an application with no arguments (likely interpreter bug)");super(),this.arg=t.pop(),this.fun=t.length?new n(e,...t):e,this.final=!1,this.arity=this.fun.arity>0?this.fun.arity-1:0}weight(){return this.fun.weight()+this.arg.weight()}getSymbols(){let e=this.fun.getSymbols();for(let[t,s]of this.arg.getSymbols())e.set(t,(e.get(t)??0)+s);return e}_guess(e,t=[],s=0){if(t.length>e.maxArgs||s>e.max)return{normal:!1,steps:s};let r=super._guess(e,t,s);if(r.normal)return r;s=r.steps;let[a,...l]=this._aslist();if(!(a instanceof f))return{normal:!1,steps:s};let i=!1,h=!1,o=[];for(let d of l){let u=d._guess({...e,maxArgs:e.maxArgs-t.length,max:e.max-s,index:t.length+e.index});if(s+=u.steps,!u.normal)return{normal:!1,steps:s};o.push(u.expr),i=i||u.discard,h=h||u.duplicate}return{normal:!0,steps:s,...Q(t,new n(a,...o),{discard:i,duplicate:h})}}_firstVar(){return this.fun._firstVar()}apply(...e){return e.length===0?this:new n(this,...e)}expand(){return this.fun.expand().apply(this.arg.expand())}_replace(e,t){let s=super._replace(e,t);if(s)return s;let[r,a]=this.split();return(r._replace(e,t)??r).apply(a._replace(e,t)??a)}renameVars(e){return this.fun.renameVars(e).apply(this.arg.renameVars(e))}subst(e,t){let s=this.fun.subst(e,t),r=this.arg.subst(e,t);return s||r?(s??this.fun).apply(r??this.arg):null}step(){if(!this.final){if(this.arity===0){let s=this.fun.reduce([this.arg]);if(s)return{expr:s,steps:1,changed:!0}}let e=this.fun.step();if(e.changed)return{expr:e.expr.apply(this.arg),steps:e.steps,changed:!0};let t=this.arg.step();if(t.changed)return{expr:this.fun.apply(t.expr),steps:t.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}reduce(e){return this.fun.reduce([this.arg,...e])}split(){return[this.fun,this.arg]}_aslist(){return[...this.fun._aslist(),this.arg]}_rski(e){return e.steps>=e.max?this:this.fun._rski(e).apply(this.arg._rski(e))}equals(e){return e instanceof n?this.fun.equals(e.fun)&&this.arg.equals(e.arg):super.equals(e)}contains(e){return this.fun.contains(e)||this.arg.contains(e)||super.contains(e)}needsParens(e){return!e}toString(e={}){let t=this.fun.toString(e),s=this.fun.needsParens(!0)?"("+t+")":t;if(e.terse??S.terse){let r=this.arg.toString(e);this.arg.needsParens(!1)&&(r="("+r+")");let a=s.match(/\)$/)||r.match(/^\(/)||s.match(/[A-Z]$/)&&r.match(/^[a-z]/i)?"":" ";return s+a+r}else return s+"("+this.arg.toString(e)+")"}_format(e,t){let s=this.fun._format(e,t+1),r=this.arg._format(e,0),a=t?["",""]:e.around;return e.terse&&!this.arg.needsParens(!1)?a[0]+s+(this.fun._spaced(this.arg)?e.space:"")+r+a[1]:a[0]+s+e.brackets[0]+r+e.brackets[1]+a[1]}_spaced(e){return this.arg.needsParens(!1)?!1:this.arg._spaced(e)}},z=class extends p{constructor(e){if(super(),typeof e!="string"||e.length===0)throw new Error("Attempt to create a named term with improper name");this.name=e}toString(){return this.name}_spaced(e){return!(this.name.match(/^[A-Z+]$/)||e.name.match(/^[A-Z+]$/))}},ce=0,f=class extends z{constructor(e){super(e),this.id=++ce}subst(e,t){return this===e?t:null}weight(){return 0}_firstVar(){return!0}toString(e={}){return e.html&&/^[a-z]$/.test(this.name)?"<var>"+this.name+"</var>":this.name}_format(e,t){return e.var[0]+this.name+e.var[1]}},_=class extends z{constructor(e,t,s={}){super(e),this.impl=t,s.apply&&(this.onApply=s.apply),this.arity=s.arity??1;let r=s.canonize??!0?this.guess():{normal:!1};s.arity||(this.arity=r.arity||1),this.note=s.note??r.expr?.toString({terse:!0,html:!0})}apply(...e){if(this.onApply&&e.length>=1){if(typeof this.onApply!="function")throw new Error("Native combinator "+this+" has an invalid onApply property  of type"+typeof this.onApply+": "+this.onApply);let t=this.onApply(e[0]);if(t instanceof p)return t.apply(...e.slice(1))}return super.apply(...e)}_rski(e){if(this===w.I||this===w.K||this===w.S||e.steps>=e.max)return this;let t=this.guess().expr;return t?(e.steps++,t._rski(e)):this}reduce(e){if(e.length<this.arity)return null;let t=0,s=this.impl;for(;typeof s=="function";){if(t>=e.length)return null;s=s(e[t++])}if(!(s instanceof p))throw new Error("Native combinator "+this+" reduced to a non-expression: "+s);return s.apply(...e.slice(t))}toJSON(){return"Native:"+this.name}_format(e,t){return this.arity>0&&this.arity<=t?e.redex[0]+this.name+e.redex[1]:this.name}},w={};function k(n,e,t){w[n]=new _(n,e,t)}var g=class n extends p{constructor(e,t){if(Array.isArray(e)){if(e.length===0)throw new Error("empty argument list in lambda constructor");let[r,...a]=e,l=new Set([r.name]);for(;a.length>0;){let i=a.pop();if(l.has(i.name))throw new Error("Duplicate free var name "+i+" in lambda expression");l.add(i.name),t=new n(i,t)}e=r}super();let s=new f(e.name);this.arg=s,this.impl=t.subst(e,s)??t,this.arity=1}getSymbols(){let e=this.impl.getSymbols();return e.delete(this.arg),e.set(p.lambdaPlaceholder,(e.get(p.lambdaPlaceholder)??0)+1),e}weight(){return this.impl.weight()+1}_guess(e,t=[],s=0){if(t.length>e.maxArgs)return{normal:!1,steps:s};let r=U(t.length+e.index);return this.reduce([r])._guess(e,[...t,r],s+1)}reduce(e){if(e.length===0)return null;let[t,...s]=e;return(this.impl.subst(this.arg,t)??this.impl).apply(...s)}subst(e,t){if(e===this.arg)return null;let s=this.impl.subst(e,t);return s?new n(this.arg,s):null}expand(){return new n(this.arg,this.impl.expand())}renameVars(e){let t=new f(e.next().value),s=this.impl.subst(this.arg,t)??this.impl;return new n(t,s.renameVars(e))}_rski(e){let t=this.impl._rski(e);if(e.steps>=e.max)return new n(this.arg,t);if(e.steps++,t===this.arg)return w.I;if(!t.getSymbols().has(this.arg))return w.K.apply(t);if(t instanceof b){let[s,r]=t.split();return r===this.arg&&!s.getSymbols().has(this.arg)?s._rski(e):w.S.apply(new n(this.arg,s)._rski(e),new n(this.arg,r)._rski(e))}throw new Error("Don't know how to convert to SKI"+this)}_replace(e,t){let s=super._replace(e,t);return s||new n(this.arg,this.impl._replace(e,t)??this.impl)}equals(e){if(!(e instanceof n))return super.equals(e);let t=new f("t");return e.reduce([t]).equals(this.reduce([t]))}contains(e){return this.equals(e)||this.impl.contains(e)}toString(e={}){let t=e.html?" &mapsto; ":"->";return this.arg.toString(e)+t+this.impl.toString(e)}_format(e,t){return(t>0?e.brackets[0]:"")+e.lambda[0]+this.arg._format(e,0)+e.lambda[1]+this.impl._format(e,0)+e.lambda[2]+(t>0?e.brackets[1]:"")}needsParens(e){return!0}},P=class n extends _{constructor(e){let t=Number.parseInt(e);if(!(t>=0))throw new Error("Church number must be a non-negative integer");let s=""+t,r=a=>l=>{let i=l;for(let h=t;h-- >0;)i=a.apply(i);return i};super(s,r,{arity:2,canonize:!1,note:s}),this.n=t,this.arity=2}equals(e){return e instanceof n?this.n===e.n:super.equals(e)}_spaced(e){return!0}},j=class extends z{constructor(e,t,s={}){super(e),this.impl=t,s.note&&(this.note=s.note);let r=s.canonize?t.guess({max:s.max,maxArgs:s.maxArgs}):{normal:!1};this.arity=r.proper&&r.arity||0,this.proper=r.proper??!1,this.terminal=s.terminal??this.proper,this.canonical=r.expr}getSymbols(){return this.terminal?new Map([[this,1]]):this.impl.getSymbols()}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}subst(e,t){return this.impl.subst(e,t)}_guess(e,t=[],s=0){return this.impl._guess(e,t,s)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}reduce(e){return e.length<this.arity?null:this.impl.apply(...e)}_firstVar(){return this.impl._firstVar()}equals(e){return e.equals(this.impl)}contains(e){return this.impl.contains(e)}_rski(e){return this.impl._rski(e)}toString(e){return this.outdated?this.impl.toString(e):super.toString(e)}needsParens(e){return this.outdated?this.impl.needsParens():!1}_format(e,t){return this.outdated?this.impl._format(e,t):this.arity>0&&this.arity<=t?e.redex[0]+this.name+e.redex[1]:this.name}};k("I",n=>n);k("K",n=>e=>n);k("S",n=>e=>t=>n.apply(t,e.apply(t)));k("B",n=>e=>t=>n.apply(e.apply(t)));k("C",n=>e=>t=>n.apply(t).apply(e));k("W",n=>e=>n.apply(e).apply(e));k("+",n=>e=>t=>e.apply(n.apply(e,t)),{note:"<var>n</var> &mapsto; <var>n</var> + 1 <i>or</i> SB",apply:n=>n instanceof P?new P(n.n+1):null});function Q(n,e,t={}){let s=e.getSymbols(),[r,a]=oe(n,s);return{expr:n.length?new g(n,e):e,...t.synth?{}:{arity:n.length},...r.size?{skip:r}:{},...a.size?{dup:a}:{},duplicate:!!a.size||t.duplicate||!1,discard:!!r.size||t.discard||!1,proper:ue(s.keys(),new Set(n))}}function q(n){if(n instanceof b)return q(n.fun).apply(q(n.arg));if(n instanceof g)return new g(n.arg,q(n.impl));if(n instanceof j)return q(n.impl);let e=n.guess();if(e.expr)return e.expr;throw new Error("Failed to canonize expression: "+n)}function*I(n,e={},t={steps:0}){if(yield{expr:n,steps:t.steps,comment:"(self)"},n.freeOnly())return;let s=n.weight();if(n instanceof g)for(let a of I(n.impl,e,t)){let l=new g(n.arg,a.expr);l.weight()<s&&(s=l.weight(),yield{expr:l,steps:t.steps,comment:"(lambda)"+a.comment})}if(n instanceof b){let[a,l]=n.split();for(let i of I(a,e,t)){let h=i.expr.apply(l);h.weight()<s&&(s=h.weight(),a=i.expr,yield{expr:h,steps:t.steps,comment:"(fun)"+i.comment})}for(let i of I(l,e,t)){let h=a.apply(i.expr);h.weight()<s&&(s=h.weight(),yield{expr:h,steps:t.steps,comment:"(arg)"+i.comment})}}let r=n.guess({max:e.max,maxArgs:e.maxArgs});t.steps+=r.steps,r.expr&&r.expr.weight()<s&&(yield{expr:r.expr,steps:t.steps,comment:"(canonical)"})}function U(n){return new f("abcdefgh"[n]??"x"+n)}p.lambdaPlaceholder=new _("->",n=>n,{arity:1,canonize:!1,note:"Lambda placeholder",apply:n=>{throw new Error("Attempt to use a placeholder in expression")}});W.exports={Expr:p,App:b,FreeVar:f,Lambda:g,Native:_,Alias:j,Church:P,globalOptions:S,native:w}});var R=A((Ee,X)=>{var{Tokenizer:pe,restrict:K}=$(),{globalOptions:fe,Expr:O,App:ve,FreeVar:V,Lambda:H,Native:me,Alias:y,Church:Z,native:N}=G(),v=class extends O{apply(...e){return e.length?e.shift().apply(...e):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}},C=class n extends v{constructor(e,t={}){if(super(),this.impl=new v,e instanceof V)this.terms=[e];else if(e instanceof n){if(!(e.impl instanceof V))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...e.terms,e.impl]}else throw new Error("Expected FreeVar or PartialLambda")}apply(e,...t){if(e===null||t.length!==0)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(e),this}postParse(){return new H(this.terms,this.impl)}},de=new pe("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+"),m=class n{constructor(e={}){this.annotate=e.annotate??!1,this.known={...N},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known));for(let t in e.terms??{})e.terms[t].match(/^Native:/)||this.add(t,e.terms[t]);this.hasNumbers=e.numbers??!0,this.hasLambdas=e.lambdas??!0,e.allow&&this.restrict(e.allow)}add(e,t,s){if(typeof e=="string")if(typeof t=="string")e=new y(e,this.parse(t),{canonize:!0});else if(t instanceof O)e=new y(e,t,{canonize:!0});else throw new Error("add: term must be an Alias or a string and impl must be an Expr or a string");else e instanceof y&&(e=new y(e.name,e.impl,{canonize:!0}));if(!(e instanceof y))throw new Error("add: term must be an Alias or a string (accompanied with an implementation)");return this.annotate&&s===void 0&&e.canonical&&(s=e.canonical.toString({terse:!0,html:!0})),s!==void 0&&(e.note=s),this.known[""+e]=e,this.allow.add(""+e),this}maybeAdd(e,t){return this.known[e]?this.allow.add(e):this.add(e,t),this}restrict(e){return this.allow=K(this.allow,e),this}showRestrict(e="+"){let t=[],s=!0;for(let r of[...K(this.allow,e)].sort()){let a=r.match(/^[A-Z]$/);t.length&&!(s&&a)&&t.push(" "),t.push(r),s=a}return t.join("")}remove(e){return this.known[e].outdated=!0,delete this.known[e],this.allow.delete(e),this}getTerms(){let e={};for(let t of Object.keys(this.known))this.allow.has(t)&&(e[t]=this.known[t]);return e}parse(e,t={},s={}){if(typeof e!="string")throw new Error("parse: source must be a string, got "+typeof e);let r=e.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter(i=>i.match(/\S/)),a={...t},l=new v;for(let i of r){let[h,o,d]=i.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(l instanceof y&&(l.outdated=!0),l=this.parseLine(d,a,s),o!==void 0){if(a[o]!==void 0)throw new Error("Attempt to redefine a known term: "+o);l=new y(o,l),a[o]=l}}for(let i in a)!t[i]&&a[i]instanceof n.classes.FreeVar&&(t[i]=a[i]);return l}parseLine(e,t={},s={}){let r={numbers:s.numbers??this.hasNumbers,lambdas:s.lambdas??this.hasLambdas,allow:K(this.allow,s.allow)};r.numbers?r.allow.add("+"):r.allow.delete("+");let a=de.split(e),l=new v,i=[l];for(let h of a)if(h==="(")i.push(l);else if(h===")"){if(i.length<2)throw new Error("unbalanced input: extra closing parenthesis"+e);let o=i.pop().postParse(),d=i.pop();i.push(d.apply(o))}else if(h==="->"){if(!r.lambdas)throw new Error("Lambdas not supported, allow them explicitly");i.push(new C(i.pop(),t))}else if(h.match(/^[0-9]+$/)){if(!r.numbers)throw new Error("Church numbers not supported, allow them explicitly");let o=i.pop();i.push(o.apply(new Z(h)))}else{let o=i.pop();if(!t[h]&&this.known[h]&&!r.allow.has(h))throw new Error("Term '"+h+"' is not in the restricted set "+[...r.allow].sort().join(" "));let d=t[h]??this.known[h]??(t[h]=new V(h));i.push(o.apply(d))}if(i.length!==1)throw new Error("unbalanced input: missing "+(i.length-1)+" closing parenthesis:"+e);return i.pop().postParse()}toJSON(){return{allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,terms:this.getTerms(),annotate:this.annotate}}};m.free=(...n)=>n.map(e=>new V(e));m.church=n=>new Z(n);m.classes={Expr:O,Native:me,Alias:y,FreeVar:V,Lambda:H,Church:Z};for(let n in N)m[n]=N[n];m.native=N;m.options=fe;m.lambdaPlaceholder=O.lambdaPlaceholder;X.exports={SKI:m}});var te=A((qe,ee)=>{var{SKI:E}=R(),{Expr:Ae,FreeVar:we,Alias:Y,Lambda:ge}=E.classes,D=class{constructor(e={}){let{input:t,vars:s,cases:r,allow:a,numbers:l,lambdas:i,subst:h,engine:o,engineFull:d,...u}=e;this.engine=o??new E,this.engineFull=d??new E,this.restrict={allow:a,numbers:l??!1,lambdas:i??!1},this.vars={},this.subst=Array.isArray(h)?h:[h??"phi"];let T={};for(let c of s??[]){let x=this.engineFull.parse(c,T);if(x instanceof E.classes.Alias)this.vars[x.name]=new Y(x.name,x.impl,{terminal:!0,canonize:!1});else if(x instanceof E.classes.FreeVar)this.vars[x.name]=x;else throw new Error("Unsupported given variable type: "+c)}this.input=[];for(let c of Array.isArray(t)?t:[t])this.addInput(c);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");h&&(this.input[0].fancy=this.subst[0]),this.varsFull={...this.vars,...T};for(let c of this.input){if(c.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+c.name);this.varsFull[c.name]=c.placeholder}this.cases=[],this.title=u.title,u.descr=xe(u.descr),this.descr=u.descr,this.meta=u;for(let c of r??[])this.add(...c)}allowed(){let e=this.restrict.allow??"",t=Object.keys(this.vars).sort();return e?this.engine.showRestrict(e+"+"+t.join(" ")):t.map(s=>"+"+s).join(" ")}addInput(e){if(typeof e!="object"&&(e={name:e}),typeof e.name!="string")throw new Error("quest 'input' field must be a string or a {name: string, ...} object");[e.placeholder]=E.free(e.name),this.input.push(e)}add(e,...t){typeof e=="string"?(t.unshift(e),e={}):e={...e},e.engine=e.engine??this.engineFull,e.vars=e.vars??this.varsFull;let s=this.input.map(r=>r.placeholder);return this.cases.push(e.caps?new J(s,e,t):new M(s,e,t)),this}prepare(...e){if(e.length!==this.input.length)throw new Error("Solutions provided "+e.length+" terms where "+this.input.length+" are expected");let t=0,s=[],r={...this.vars};for(let a=0;a<e.length;a++){let l=this.input[a],i=this.engine.parse(e[a],r,{allow:l.allow??this.restrict.allow,numbers:l.numbers??this.restrict.numbers,lambdas:l.lambdas??this.restrict.lambdas});t+=i.weight();let h=i instanceof we?i:new Y(l.fancy??l.name,i,{terminal:!0,canonize:!1});r[l.name]=h,s.push(h)}return{prepared:s,weight:t}}check(...e){try{let{prepared:t,weight:s}=this.prepare(...e),r=this.cases.map(i=>i.check(...t)),a=r.reduce((i,h)=>i&&h.pass,!0),l=r.reduce((i,h)=>i+h.steps,0);return{expr:t[0],input:t,pass:a,steps:l,details:r,weight:s}}catch(t){return{pass:!1,details:[],exception:t,steps:0,input:e}}}show(){return[...this.cases]}},L=class{constructor(e,t){this.max=t.max??1e3,this.note=t.note,this.vars={...t.vars??{}},this.input=e,this.engine=t.engine}parse(e){return new ge(this.input,this.engine.parse(e,this.vars))}check(...e){throw new Error("not implemented")}},M=class extends L{constructor(e,t,s){if(s.length!==2)throw new Error("Case accepts exactly 2 strings");super(e,t),[this.e1,this.e2]=s.map(r=>this.parse(r))}check(...e){let t=(i,h)=>i.reduce(h)??i.apply(...h),s=t(this.e1,e),r=s.run({max:this.max}),a=t(this.e2,e).run({max:this.max}),l=null;return!r.final||!a.final?l="failed to reach normal form in "+this.max+" steps":r.expr.equals(a.expr)||(l="expected: "+a.expr),{pass:!l,reason:l,steps:r.steps,start:s,found:r.expr,expected:a.expr,note:this.note,args:e,case:this}}},ye={normal:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0},J=class extends L{constructor(e,t,s){if(super(e,t),s.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!t.caps||typeof t.caps!="object"||!Object.keys(t.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");let r=Object.keys(t.caps).filter(a=>!ye[a]);if(r.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+r.join(", "));this.expr=this.parse(s[0]),this.caps=t.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.normal=!0),this.caps.affine&&(delete this.caps.affine,this.caps.normal=!0,this.caps.duplicate=!1)}check(...e){let t=this.expr.apply(...e),s=t.run({max:this.max}),r=s.expr.guess({max:this.max}),a=[];for(let l in this.caps)r[l]!==this.caps[l]&&a.push("expected property "+l+" to be "+this.caps[l]+", found "+r[l]);return{pass:!a.length,reason:a?a.join(`
`):null,steps:s.steps,start:t,found:s.expr,case:this,note:this.note,args:e}}};function xe(n){return n===void 0?n:Array.isArray(n)?n.join(" "):""+n}ee.exports={Quest:D}});var be=A((ze,ne)=>{var se=R(),re=te();ne.exports={...se,...re};typeof window<"u"&&(window.SKI=se.SKI,window.SKI.Quest=re.Quest)});be();})();
//# sourceMappingURL=ski-interpreter.min.js.map
