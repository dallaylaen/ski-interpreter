(()=>{var _=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var H=_((Ve,G)=>{var F=class{constructor(...e){let t="$|(\\s+)|"+e.map(r=>"(?:"+r+")").sort((r,s)=>s.length-r.length).join("|");this.rex=new RegExp(t,"gys")}split(e){this.rex.lastIndex=0;let t=[...e.matchAll(this.rex)],s=t.pop()?.index??0;if(s!==e.length)throw new Error("Unknown tokens at pos "+s+"/"+e.length+" starting with "+e.substring(s));return t.filter(a=>a[1]===void 0).map(a=>a[0])}},we=new F("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");function xe(n,e){if(!e)return n;let t=new Set([...n]),r={"=":a=>{t=new Set([a]),s="+"},"+":a=>{t.add(a)},"-":a=>{t.delete(a)}},s="=";for(let a of we.split(e))r[a]?s=a:r[s](a);return t}G.exports={Tokenizer:F,restrict:xe}});var re=_((qe,te)=>{"use strict";var $={max:1e3,maxArgs:32},m=class n{constructor(){if(new.target===n)throw new Error("Attempt to instantiate abstract class Expr")}apply(...e){return e.length>0?new w(this,...e):this}expand(){return this}freeOnly(){return!this.any(e=>!(e instanceof d||e instanceof w))}traverse(e){return e(this)}any(e){return e(this)}weight(){return 1}infer(e={}){let t=e.max??$.max,r=e.maxArgs??$.maxArgs;return this._infer({max:t,maxArgs:r,index:0})}_infer(e,t=[],r=0){if(t.length>e.maxArgs||r>e.max)return{normal:!1,steps:r};if(this.freeOnly())return{normal:!0,steps:r,...Y(t,this)};let s=this.run({max:(e.max-r)/3});if(r+=s.steps,!s.final)return{normal:!1,steps:r};if(s.steps!==0)return s.expr._infer(e,t,r);if(this._firstVar())return{normal:!1,steps:r};let a=ee(t.length+e.index);return this.apply(a)._infer(e,[...t,a],r)}_aslist(){return[this]}_firstVar(){return!1}*toLambda(e={}){let t=this.traverse(r=>{if(r instanceof d||r instanceof w||r instanceof y||r instanceof b)return null;let s=r.infer({max:e.max,maxArgs:e.maxArgs});if(!s.normal)throw new Error("Failed to infer an equivalent  lambda term for "+r);return s.expr})??this;yield*V(t,e)}*toSKI(e={}){let t=0,r=this;for(;;){let s={max:e.max??1,steps:0},a=r._rski(s),l=s.steps===0;if(yield{expr:r,steps:t,final:l},l)break;r=a,t+=s.steps}}_rski(e){return this}subst(e,t){return this===e?t:null}invoke(e){return null}step(){return{expr:this,steps:0,changed:!1}}run(e={},...t){e instanceof n&&(t.unshift(e),e={});let r=t?this.apply(...t):this,s=e.steps??0,a=Math.max(e.max??$.max,1)+s,l=!1;for(;s<a;){let i=r.step();if(!i.changed){l=!0;break}s+=i.steps,r=i.expr}if(e.throw&&!l)throw new Error("Failed to compute expression in "+a+" steps");return{final:l,steps:s,expr:r}}*walk(e={}){let t=e.max??1/0,r=0,s=this,a=!1;for(;r<t;){let l=s.step();if(l.changed||(a=!0),yield{expr:s,steps:r,final:a},a)break;r+=l.steps,s=l.expr}}equals(e){return!this.diff(e)}diff(e,t=!1){return this===e?null:e instanceof b?e.impl.diff(this,!t):t?"["+e+" != "+this+"]":"["+this+" != "+e+"]"}expect(e,t=""){if(t=t?t+": ":"",!(e instanceof n))throw new Error(t+"attempt to expect a combinator to equal something else: "+e);let r=this.diff(e);if(!r)return;let s=new Error(t+r);throw s.expected=e+"",s.actual=this+"",s}toString(){return this.format()}_braced(e){return!1}_unspaced(e){return this._braced(!0)}format(e={}){let t=e.html?{brackets:["(",")"],space:" ",var:["<var>","</var>"],lambda:["","-&gt;",""],around:["",""],redex:["",""]}:{brackets:["(",")"],space:" ",var:["",""],lambda:["","->",""],around:["",""],redex:["",""]};return this._format({terse:e.terse??!0,brackets:e.brackets??t.brackets,space:e.space??t.space,var:e.var??t.var,lambda:e.lambda??t.lambda,around:e.around??t.around,redex:e.redex??t.redex,inventory:e.inventory,html:e.html??!1},0)}_format(e,t){throw new Error("No _format() method defined in class "+this.constructor.name)}_declare(e,t,r){}},w=class n extends m{constructor(e,...t){if(t.length===0)throw new Error("Attempt to create an application with no arguments (likely interpreter bug)");super(),this.arg=t.pop(),this.fun=t.length?new n(e,...t):e,this.final=!1,this.arity=this.fun.arity>0?this.fun.arity-1:0}weight(){return this.fun.weight()+this.arg.weight()}_infer(e,t=[],r=0){if(t.length>e.maxArgs||r>e.max)return{normal:!1,steps:r};let s=super._infer(e,t,r);if(s.normal)return s;r=s.steps;let[a,...l]=this._aslist();if(!(a instanceof d))return{normal:!1,steps:r};let i=!1,h=!1,c=[];for(let p of l){let f=p._infer({...e,maxArgs:e.maxArgs-t.length,max:e.max-r,index:t.length+e.index});if(r+=f.steps,!f.normal)return{normal:!1,steps:r};c.push(f.expr),i=i||f.discard,h=h||f.duplicate}return{normal:!0,steps:r,...Y(t,new n(a,...c),{discard:i,duplicate:h})}}_firstVar(){return this.fun._firstVar()}expand(){return this.fun.expand().apply(this.arg.expand())}traverse(e){let t=e(this);if(t instanceof m)return t;let r=this.fun.traverse(e),s=this.arg.traverse(e);return!r&&!s?null:(r??this.fun).apply(s??this.arg)}any(e){return e(this)||this.fun.any(e)||this.arg.any(e)}subst(e,t){let r=this.fun.subst(e,t),s=this.arg.subst(e,t);return r||s?(r??this.fun).apply(s??this.arg):null}step(){if(!this.final){let e=this.fun.invoke(this.arg);if(e instanceof m)return{expr:e,steps:1,changed:!0};typeof e=="function"&&(this.invoke=e);let t=this.fun.step();if(t.changed)return{expr:t.expr.apply(this.arg),steps:t.steps,changed:!0};let r=this.arg.step();if(r.changed)return{expr:this.fun.apply(r.expr),steps:r.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}invoke(e){let t=this.fun.invoke(this.arg);return t instanceof m?t.apply(e):typeof t=="function"?(this.invoke=t,t(e)):(this.invoke=r=>null,null)}split(){return[this.fun,this.arg]}_aslist(){return[...this.fun._aslist(),this.arg]}_rski(e){return e.steps>=e.max?this:this.fun._rski(e).apply(this.arg._rski(e))}diff(e,t=!1){if(!(e instanceof n))return super.diff(e,t);let r=this.fun.diff(e.fun,t);if(r)return r+"(...)";let s=this.arg.diff(e.arg,t);return s?this.fun+"("+s+")":null}_braced(e){return!e}_format(e,t){let r=this.fun._format(e,t+1),s=this.arg._format(e,0),a=t?["",""]:e.around;return e.terse&&!this.arg._braced(!1)?a[0]+r+(this.fun._unspaced(this.arg)?"":e.space)+s+a[1]:a[0]+r+e.brackets[0]+s+e.brackets[1]+a[1]}_declare(e,t,r){this.fun._declare(e,t,r),this.arg._declare(e,t,r)}_unspaced(e){return this.arg._braced(!1)?!0:this.arg._unspaced(e)}},E=class n extends m{constructor(e){if(super(),typeof e!="string"||e.length===0)throw new Error("Attempt to create a named term with improper name");this.name=e}_unspaced(e){return!!(e instanceof n&&(this.name.match(/^[A-Z+]$/)&&e.name.match(/^[a-z+]/i)||this.name.match(/^[a-z+]/i)&&e.name.match(/^[A-Z+]$/)))}_format(e,t){let r=e.html?this.fancyName??this.name:this.name;return this.arity>0&&this.arity<=t?e.redex[0]+r+e.redex[1]:r}},ge=0,d=class n extends E{constructor(e,t){super(e),this.id=++ge,this.scope=t===void 0?this:t}weight(){return 0}_firstVar(){return!0}diff(e,t=!1){if(!(e instanceof n))return super.diff(e,t);if(this.name===e.name&&this.scope===e.scope)return null;let r=this.name+"["+this.id+"]",s=e.name+"["+e.id+"]";return t?"["+s+" != "+r+"]":"["+r+" != "+s+"]"}subst(e,t){return e instanceof n&&e.name===this.name&&e.scope===this.scope?t:null}_format(e,t){let r=e.html?this.fancyName??this.name:this.name;return e.var[0]+r+e.var[1]}},z=class extends E{constructor(e,t,r={}){super(e),this.invoke=t;let s=r.canonize??!0?this.infer():{normal:!1};this.arity=r.arity||s.arity||1,this.note=r.note??s.expr?.format({terse:!0,html:!0,lambda:[""," &mapsto; ",""]})}_rski(e){if(this===x.I||this===x.K||this===x.S||e.steps>=e.max)return this;let t=this.infer().expr;return t?(e.steps++,t._rski(e)):this}},x={};function k(n,e,t){x[n]=new z(n,e,t)}var y=class n extends m{constructor(e,t){if(Array.isArray(e)){if(e.length===0)throw new Error("empty argument list in lambda constructor");let[s,...a]=e,l=new Set([s.name]);for(;a.length>0;){let i=a.pop();if(l.has(i.name))throw new Error("Duplicate free var name "+i+" in lambda expression");l.add(i.name),t=new n(i,t)}e=s}super();let r=new d(e.name,this);this.arg=r,this.impl=t.subst(e,r)??t,this.arity=1}weight(){return this.impl.weight()+1}_infer(e,t=[],r=0){if(t.length>e.maxArgs)return{normal:!1,steps:r};let s=ee(t.length+e.index);return this.invoke(s)._infer(e,[...t,s],r+1)}invoke(e){return this.impl.subst(this.arg,e)??this.impl}traverse(e){let t=e(this);if(t instanceof m)return t;let r=this.impl.traverse(e);return r?new n(this.arg,r):null}any(e){return e(this)||this.impl.any(e)}subst(e,t){if(e===this.arg)return null;let r=this.impl.subst(e,t);return r?new n(this.arg,r):null}expand(){return new n(this.arg,this.impl.expand())}_rski(e){let t=this.impl._rski(e);if(e.steps>=e.max)return new n(this.arg,t);if(e.steps++,t===this.arg)return x.I;if(!t.any(r=>r===this.arg))return x.K.apply(t);if(t instanceof w){let[r,s]=t.split();return s===this.arg&&!r.any(a=>a===this.arg)?r._rski(e):x.S.apply(new n(this.arg,r)._rski(e),new n(this.arg,s)._rski(e))}throw new Error("Don't know how to convert to SKI"+this)}diff(e,t=!1){if(!(e instanceof n))return super.diff(e,t);let r=new d("t"),s=this.invoke(r).diff(e.invoke(r),t);return s?"(t->"+s+")":null}_format(e,t){return(t>0?e.brackets[0]:"")+e.lambda[0]+this.arg._format(e,0)+e.lambda[1]+this.impl._format(e,0)+e.lambda[2]+(t>0?e.brackets[1]:"")}_declare(e,t,r){this.impl._declare(e,t,r)}_braced(e){return!0}},I=class n extends z{constructor(e){let t=Number.parseInt(e);if(!(t>=0))throw new Error("Church number must be a non-negative integer");let r=""+t,s=a=>l=>{let i=l;for(let h=t;h-- >0;)i=a.apply(i);return i};super(r,s,{arity:2,canonize:!1,note:r}),this.n=t,this.arity=2}diff(e,t=!1){return e instanceof n?this.n===e.n?null:t?"["+e.n+" != "+this.n+"]":"["+this.n+" != "+e.n+"]":super.diff(e,t)}_unspaced(e){return!1}};function X(n,e){return t=>e<=1?n.apply(t):X(n.apply(t),e-1)}var b=class extends E{constructor(e,t,r={}){super(e),this.impl=t,r.note&&(this.note=r.note);let s=r.canonize?t.infer({max:r.max,maxArgs:r.maxArgs}):{normal:!1};this.arity=s.proper&&s.arity||0,this.proper=s.proper??!1,this.terminal=r.terminal??this.proper,this.canonical=s.expr,this.invoke=X(t,this.arity)}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}traverse(e){return e(this)??this.impl.traverse(e)}any(e){return e(this)||this.impl.any(e)}subst(e,t){return this===e?t:this.impl.subst(e,t)}_infer(e,t=[],r=0){return this.impl._infer(e,t,r)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}_firstVar(){return this.impl._firstVar()}diff(e,t=!1){return this===e?null:e.diff(this.impl,!t)}_rski(e){return this.impl._rski(e)}_braced(e){return this.outdated?this.impl._braced(e):!1}_format(e,t){return(e.inventory?e.inventory[this.name]!==this:this.outdated)?this.impl._format(e,t):super._format(e,t)}_declare(e,t,r){r.has(this)||(r.add(this),this.impl._declare(e,t,r),t[this.name]===this&&e.push(this.name+"="+this.impl.format({terse:!0,inventory:t})))}};k("I",n=>n);k("K",n=>e=>n);k("S",n=>e=>t=>n.apply(t,e.apply(t)));k("B",n=>e=>t=>n.apply(e.apply(t)));k("C",n=>e=>t=>n.apply(t).apply(e));k("W",n=>e=>n.apply(e).apply(e));k("+",n=>n instanceof I?new I(n.n+1):e=>t=>e.apply(n.apply(e,t)),{note:"Increase a Church numeral argument by 1, otherwise n => f => x => f(n f x)"});function be(n){let e=Object.keys(n).filter(i=>!(n[i]instanceof E&&n[i].name===i)).map(i=>i+" = "+n[i]);if(e.length>0)throw new Error("Inventory must be a hash of named terms with matching names: "+e.join(", "));n={...n};let t=[],r=1;for(let i in x){if(!(n[i]instanceof b))continue;for(;"temp"+r in n;)r++;let h="temp"+r,c=n[i];delete n[i];let p=new b(h,c);for(let f in n)n[f]=n[f].subst(c,p)??n[f];n[h]=p,t.push([i,h])}let s=Object.values(n).filter(i=>i instanceof b).sort((i,h)=>i.name.localeCompare(h.name)),a=[],l=new Set;for(let i of s)i._declare(a,n,l);for(let[i,h]of t)a.push(i+"="+h),a.push(h+"=");return a}function Y(n,e,t={}){let r=new Array(n.length).fill(0),s=!0;e.traverse(i=>{if(i instanceof d){let h=n.findIndex(c=>c.name===i.name);if(h>=0){r[h]++;return}}i instanceof w||(s=!1)});let a=new Set,l=new Set;for(let i=0;i<n.length;i++)r[i]===0?a.add(i):r[i]>1&&l.add(i);return{expr:n.length?new y(n,e):e,...t.synth?{}:{arity:n.length},...a.size?{skip:a}:{},...l.size?{dup:l}:{},duplicate:!!l.size||t.duplicate||!1,discard:!!a.size||t.discard||!1,proper:s}}function ee(n){return new d("abcdefgh"[n]??"x"+n)}function*V(n,e={},t={steps:0}){if(yield{expr:n,steps:t.steps,comment:"(self)"},n.freeOnly())return;let r=n.weight();if(n instanceof y)for(let a of V(n.impl,e,t)){let l=new y(n.arg,a.expr);l.weight()<r&&(r=l.weight(),yield{expr:l,steps:t.steps,comment:"(lambda)"+a.comment})}if(n instanceof w){let[a,l]=n.split();for(let i of V(a,e,t)){let h=i.expr.apply(l);h.weight()<r&&(r=h.weight(),a=i.expr,yield{expr:h,steps:t.steps,comment:"(fun)"+i.comment})}for(let i of V(l,e,t)){let h=a.apply(i.expr);h.weight()<r&&(r=h.weight(),yield{expr:h,steps:t.steps,comment:"(arg)"+i.comment})}}let s=n.infer({max:e.max,maxArgs:e.maxArgs});t.steps+=s.steps,s.expr&&s.expr.weight()<r&&(yield{expr:s.expr,steps:t.steps,comment:"(canonical)"})}m.declare=be;m.native=x;te.exports={Expr:m,App:w,FreeVar:d,Lambda:y,Native:z,Alias:b,Church:I}});var D=_((Le,le)=>{"use strict";var{Tokenizer:ye,restrict:Z}=H(),ne=re(),{Expr:T,Native:ke,Alias:A,FreeVar:q,Lambda:ve,Church:ae}=ne,{native:L,declare:ie}=T,S=class extends T{apply(...e){return e.length?e.shift().apply(...e):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}},R=class n extends S{constructor(e,t={}){if(super(),this.impl=new S,e instanceof q)this.terms=[e];else if(e instanceof n){if(!(e.impl instanceof q))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...e.terms,e.impl]}else throw new Error("Expected FreeVar or PartialLambda")}apply(e,...t){if(e===null||t.length!==0)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(e),this}postParse(){return new ve(this.terms,this.impl)}};function se(n){return n.postParse?n.postParse():n}var _e=new ye("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+"),g=class n{constructor(e={}){if(this.annotate=e.annotate??!1,this.known={...L},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known)),Array.isArray(e.terms))this.bulkAdd(e.terms);else if(e.terms)for(let t in e.terms)e.terms[t].match(/^Native:/)||this.add(t,e.terms[t]);this.hasNumbers=e.numbers??!0,this.hasLambdas=e.lambdas??!0,e.allow&&this.restrict(e.allow)}add(e,t,r){if(e=this._named(e,t),this.annotate&&r===void 0){let s=e.infer();s.expr&&(r=s.expr.format({terse:!0,html:!0,lambda:[""," &mapsto; ",""]}))}return r!==void 0&&(e.note=r),this.known[e.name]&&(this.known[e.name].outdated=!0),this.known[e.name]=e,this.allow.add(e.name),this}_named(e,t){if(e instanceof A)return new A(e.name,e.impl,{canonize:!0});if(typeof e!="string")throw new Error("add(): term must be an Alias or a string");if(t===void 0)throw new Error("add(): impl must be provided when term is a string");if(typeof t=="string")return new A(e,this.parse(t),{canonize:!0});if(t instanceof T)return new A(e,t,{canonize:!0});if(typeof t=="function")return new ke(e,t);throw new Error("add(): impl must be an Expr, a string, or a function with a signature Expr => ... => Expr")}maybeAdd(e,t){return this.known[e]?this.allow.add(e):this.add(e,t),this}bulkAdd(e){for(let t of e){let r=t.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);if(!r)throw new Error("bulkAdd: invalid declaration: "+t);r[2]===""?this.remove(r[1]):this.add(r[1],this.parse(r[2]))}return this}restrict(e){return this.allow=Z(this.allow,e),this}showRestrict(e="+"){let t=[],r=!0;for(let s of[...Z(this.allow,e)].sort()){let a=s.match(/^[A-Z]$/);t.length&&!(r&&a)&&t.push(" "),t.push(s),r=a}return t.join("")}remove(e){return this.known[e].outdated=!0,delete this.known[e],this.allow.delete(e),this}getTerms(){let e={};for(let t of Object.keys(this.known))this.allow.has(t)&&(e[t]=this.known[t]);return e}declare(){return ie(this.getTerms())}parse(e,t={}){if(typeof e!="string")throw new Error("parse: source must be a string, got "+typeof e);let r=e.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter(l=>l.match(/\S/)),s={...t.env},a=new S;for(let l of r){let[i,h,c]=l.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(a instanceof A&&(a.outdated=!0),a=this.parseLine(c,s,t),h!==void 0){if(s[h]!==void 0)throw new Error("Attempt to redefine a known term: "+h);a=new A(h,a),s[h]=a}}return a}parseLine(e,t={},r={}){let s={numbers:r.numbers??this.hasNumbers,lambdas:r.lambdas??this.hasLambdas,allow:Z(this.allow,r.allow)};s.numbers?s.allow.add("+"):s.allow.delete("+");let a=_e.split(e),l=new S,i=[l],h=r.scope||n;for(let c of a)if(c==="(")i.push(l);else if(c===")"){if(i.length<2)throw new Error("unbalanced input: extra closing parenthesis"+e);let p=se(i.pop()),f=i.pop();i.push(f.apply(p))}else if(c==="->"){if(!s.lambdas)throw new Error("Lambdas not supported, allow them explicitly");i.push(new R(i.pop(),t))}else if(c.match(/^[0-9]+$/)){if(!s.numbers)throw new Error("Church numbers not supported, allow them explicitly");let p=i.pop();i.push(p.apply(new ae(c)))}else{let p=i.pop();if(!t[c]&&this.known[c]&&!s.allow.has(c))throw new Error("Term '"+c+"' is not in the restricted set "+[...s.allow].sort().join(" "));let f=t[c]??this.known[c]??(t[c]=new q(c,h));i.push(p.apply(f))}if(i.length!==1)throw new Error("unbalanced input: missing "+(i.length-1)+" closing parenthesis:"+e);return se(i.pop())}toJSON(){return{version:"1.1.1",allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,annotate:this.annotate,terms:this.declare()}}};g.classes=ne;g.vars=function(n={}){let e={};return new Proxy({},{get:(t,r)=>(r in e||(e[r]=new q(r,n)),e[r])})};g.church=n=>new ae(n);for(let n in L)g[n]=L[n];g.native=L;g.declare=ie;le.exports={SKI:g}});var ue=_((Pe,ce)=>{var{SKI:j}=D(),{Expr:Oe,FreeVar:Ee,Alias:he,Lambda:Ne}=j.classes,U=class{constructor(e={}){let{input:t,vars:r,cases:s,allow:a,numbers:l,lambdas:i,subst:h,engine:c,engineFull:p,...f}=e;this.engine=c??new j,this.engineFull=p??new j,this.restrict={allow:a,numbers:l??!1,lambdas:i??!1},this.vars={},this.subst=Array.isArray(h)?h:[h??"phi"];let v={};for(let u of r??[]){let o=this.engineFull.parse(u,{env:v,scope:this});if(o instanceof j.classes.Alias)this.vars[o.name]=new he(o.name,o.impl,{terminal:!0,canonize:!1});else if(o instanceof j.classes.FreeVar)this.vars[o.name]=o;else throw new Error("Unsupported given variable type: "+u)}this.input=[];for(let u of Array.isArray(t)?t:[t])this.addInput(u);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");h&&(this.input[0].fancy=this.subst[0]),this.varsFull={...this.vars,...v};for(let u of this.input){if(u.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+u.name);this.varsFull[u.name]=u.placeholder}this.cases=[],this.title=f.title,f.descr=Se(f.descr),this.descr=f.descr,this.meta=f;for(let u of s??[])this.add(...u)}allowed(){let e=this.restrict.allow??"",t=Object.keys(this.vars).sort();return e?this.engine.showRestrict(e+"+"+t.join(" ")):t.map(r=>"+"+r).join(" ")}addInput(e){if(typeof e!="object"&&(e={name:e}),typeof e.name!="string")throw new Error("quest 'input' field must be a string or a {name: string, ...} object");e.placeholder=new j.classes.FreeVar(e.name),this.input.push(e)}add(e,...t){typeof e=="string"?(t.unshift(e),e={}):e={...e},e.engine=e.engine??this.engineFull,e.vars=e.vars??this.varsFull;let r=this.input.map(s=>s.placeholder);return this.cases.push(e.caps?new Q(r,e,t):new M(r,e,t)),this}prepare(...e){if(e.length!==this.input.length)throw new Error("Solutions provided "+e.length+" terms where "+this.input.length+" are expected");let t=0,r=[],s={...this.vars};for(let a=0;a<e.length;a++){let l=this.input[a],i=this.engine.parse(e[a],{env:s,allow:l.allow??this.restrict.allow,numbers:l.numbers??this.restrict.numbers,lambdas:l.lambdas??this.restrict.lambdas});t+=i.weight();let h=i instanceof Ee?i:new he(l.fancy??l.name,i,{terminal:!0,canonize:!1});s[l.name]=h,r.push(h)}return{prepared:r,weight:t}}check(...e){try{let{prepared:t,weight:r}=this.prepare(...e),s=this.cases.map(i=>i.check(...t)),a=s.reduce((i,h)=>i&&h.pass,!0),l=s.reduce((i,h)=>i+h.steps,0);return{expr:t[0],input:t,pass:a,steps:l,details:s,weight:r}}catch(t){return{pass:!1,details:[],exception:t,steps:0,input:e}}}show(){return[...this.cases]}},O=class{constructor(e,t){this.max=t.max??1e3,this.note=t.note,this.vars={...t.vars??{}},this.input=e,this.engine=t.engine}parse(e){return new W(this.engine.parse(e,{env:this.vars,scope:this}),this.input)}check(...e){throw new Error("not implemented")}},M=class extends O{constructor(e,t,r){if(r.length!==2)throw new Error("Case accepts exactly 2 strings");super(e,t),[this.e1,this.e2]=r.map(s=>this.parse(s))}check(...e){let t=this.e1.apply(e),r=t.run({max:this.max}),a=this.e2.apply(e).run({max:this.max}),l=null;return!r.final||!a.final?l="failed to reach normal form in "+this.max+" steps":l=r.expr.diff(a.expr),{pass:!l,reason:l,steps:r.steps,start:t,found:r.expr,expected:a.expr,note:this.note,args:e,case:this}}},Ae={normal:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0},Q=class extends O{constructor(e,t,r){if(super(e,t),r.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!t.caps||typeof t.caps!="object"||!Object.keys(t.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");let s=Object.keys(t.caps).filter(a=>!Ae[a]);if(s.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+s.join(", "));this.expr=this.parse(r[0]),this.caps=t.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.normal=!0),this.caps.affine&&(delete this.caps.affine,this.caps.normal=!0,this.caps.duplicate=!1)}check(...e){let t=this.expr.apply(e),r=t.run({max:this.max}),s=r.expr.infer({max:this.max}),a=[];for(let l in this.caps)s[l]!==this.caps[l]&&a.push("expected property "+l+" to be "+this.caps[l]+", found "+s[l]);return{pass:!a.length,reason:a?a.join(`
`):null,steps:r.steps,start:t,found:r.expr,case:this,note:this.note,args:e}}},W=class{constructor(e,t){this.expr=e,this.vars=t}apply(e){if(e.length!==this.vars.length)throw new Error("Subst: expected "+this.vars.length+" terms, got "+e.length);let t=this.expr;for(let r=0;r<this.vars.length;r++)t=t.subst(this.vars[r],e[r])??t;return t}};function Se(n){return n===void 0?n:Array.isArray(n)?n.join(" "):""+n}ce.exports={Quest:U}});var oe=_((Ke,fe)=>{function je(n,e,t){let{depth:r=16,infer:s=!0,progressInterval:a=1e3}=e,l=s&&!e.noskip,i=[null,[]],h=0,c=0,p={},f=u=>{h++;let o=s?u.infer({max:e.max,maxArgs:e.maxArgs}):null;if(l&&o.expr){if(p[o.expr])return{res:-1};p[o.expr]=!0}return c++,{res:t(u,o),props:o}};for(let u of n){let{res:o}=f(u);if(o>0)return{expr:u,total:h,probed:c,gen:1};if(o<0)continue;i[1].push(u)}let v;for(let u=2;u<r;u++){e.progress&&(e.progress({gen:u,total:h,probed:c,step:!0}),v=h);for(let o=1;o<u;o++)for(let B of i[o]||[])for(let de of i[u-o]||[]){if(h>=e.tries)return{total:h,probed:c,gen:u};e.progress&&h-v>=a&&(e.progress({gen:u,total:h,probed:c,step:!1}),v=h);let P=B.apply(de),{res:J,props:K}=f(P);if(J>0)return{expr:P,total:h,probed:c,gen:u};if(J<0)continue;let C=s?(K.expr?0:3)+(K.dup?1:0)+(K.proper?0:1):0;i[u+C]||(i[u+C]=[]),i[u+C].push(P)}}return{total:h,probed:c,gen:r}}fe.exports={search:je}});var Ie=_((Ce,me)=>{var N=D(),pe=ue(),ze=oe();N.SKI.Quest=pe.Quest;N.SKI.extras=ze;me.exports={...N,...pe};typeof window<"u"&&(window.SKI=N.SKI)});Ie();})();
//# sourceMappingURL=ski-interpreter.min.js.map
