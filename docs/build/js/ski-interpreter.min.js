(()=>{var L=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports);var M=L((Qe,se)=>{var V=class{constructor(...e){let t="$|(\\s+)|"+e.map(r=>"(?:"+r+")").sort((r,n)=>n.length-r.length).join("|");this.rex=new RegExp(t,"gys")}split(e){this.rex.lastIndex=0;let t=[...e.matchAll(this.rex)],n=t.pop()?.index??0;if(n!==e.length)throw new Error("Unknown tokens at pos "+n+"/"+e.length+" starting with "+e.substring(n));return t.filter(s=>s[1]===void 0).map(s=>s[0])}},_e=new V("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");function Ae(i,e){if(!e)return i;let t=new Set([...i]),r={"=":s=>{t=new Set([s]),n="+"},"+":s=>{t.add(s)},"-":s=>{t.delete(s)}},n="=";for(let s of _e.split(e))r[s]?n=s:r[n](s);return t}var C=class{constructor(e,t){this.value=e,this.decoration=t}};function Ee(i){return i instanceof C?[i.value??void 0,i.decoration]:[i??void 0,void 0]}function Se(i){let e=t=>new C(t,e);return e.label=i,e.toString=()=>"TraverseControl::"+i,e}se.exports={Tokenizer:V,restrict:Ae,unwrap:Ee,prepareWrapper:Se}});var Q=L((We,oe)=>{"use strict";var{unwrap:y,prepareWrapper:K}=M(),U={max:1e3,maxArgs:32},Ie={"leftmost-outermost":"LO","leftmost-innermost":"LI",LO:"LO",LI:"LI"},f={descend:K("descend"),prune:K("prune"),redo:K("redo"),stop:K("stop")},j={},w=class i{_setup(e={}){if(e.fancy!==void 0&&(this.fancyName=e.fancyName),e.note!==void 0&&(this.note=e.note),e.arity!==void 0&&(this.arity=e.arity),e.canonize){let t=this.infer(e);t.normal&&(this.arity=this.arity??t.arity,this.note=this.note??t.expr.format({html:!0,lambda:[""," &mapsto; ",""]}),delete t.steps,this.props=t)}return this}apply(...e){let t=this;for(let r of e)t=new x(t,r);return t}expand(){return this.traverse(e=>{if(e instanceof _)return e.impl.expand()})??this}freeOnly(){return!this.any(e=>!(e instanceof g||e instanceof x))}traverse(e,t){typeof e=="function"&&(t=e,e={});let r=Ie[e.order??"LO"];if(r===void 0)throw new Error("Unknown traversal order: "+e.order);let[n,s]=y(this._traverse_redo({order:r},t));return n}_traverse_redo(e,t){let r,n=this,s;do{s=n;let o=e.order==="LI"?n._traverse_descend(e,t)??t(n):t(n)??n._traverse_descend(e,t);[n,r]=y(o)}while(n&&r===f.redo);return!n&&s!==this&&(n=s),r?r(n):n}_traverse_descend(e,t){return null}any(e){return e(this)}fold(e,t){let[r,n]=y(this._fold(e,t));return r??e}_fold(e,t){return t(e,this)}weight(){return 1}infer(e={}){return this._infer({max:e.max??U.max,maxArgs:e.maxArgs??U.maxArgs},0)}_infer(e,t){let r=[],n=0,s=this;e:for(let o=0;o<e.maxArgs;o++){let a=s.run({max:e.max-n});if(n+=a.steps,!a.final)break;if(Le(a.expr)){if(s=a.expr,!s.any(c=>!(c instanceof g||c instanceof x)))return ie(r,s,{steps:n});let u=s.unroll(),h=!1,m=!1,p=[];for(let c=1;c<u.length;c++){let d=u[c]._infer({maxArgs:e.maxArgs-t,max:e.max-n},t+o);if(n+=d.steps,!d.expr)break e;d.discard&&(h=!0),d.duplicate&&(m=!0),p.push(d.expr)}return ie(r,u[0].apply(...p),{discard:h,duplicate:m,steps:n})}let l=$e(t+o);r.push(l),s=a.expr.apply(l)}return{normal:!1,proper:!1,steps:n}}unroll(){return[this]}*toLambda(e={}){let t=this.traverse(s=>{if(s instanceof g||s instanceof x||s instanceof b||s instanceof _)return null;let o=s.infer({max:e.max,maxArgs:e.maxArgs});if(!o.normal)throw new Error("Failed to infer an equivalent  lambda term for "+s);return o.expr})??this,r=new Set,n=0;for(;t;){let s=t.traverse({order:"LI"},o=>{if(r.has(o))return null;if(o instanceof x&&o.fun instanceof b){let a=o.infer({max:e.max,maxArgs:e.maxArgs});return n+=a.steps,a.normal?f.stop(a.expr):(r.add(o),null)}});yield{expr:t,steps:n},t=s}}*toSKI(e={}){let t=this.traverse(n=>n instanceof g||n instanceof x||n instanceof b||n instanceof _?null:n.infer().expr)??this,r=0;for(;t;){let n=t.traverse({order:"LI"},s=>{if(!(s instanceof b)||s.impl instanceof b)return null;if(s.impl===s.arg)return f.stop(j.I);if(!s.impl.any(o=>o===s.arg))return f.stop(j.K.apply(s.impl));if(!(s.impl instanceof x))throw new Error("toSKI: assert failed: lambda body is of unexpected type "+s.impl.constructor.name);return s.impl.arg===s.arg&&!s.impl.fun.any(o=>o===s.arg)?f.stop(s.impl.fun):f.stop(j.S.apply(new b(s.arg,s.impl.fun),new b(s.arg,s.impl.arg)))});yield{expr:t,steps:r,final:!n},r++,t=n}}subst(e,t){return this===e?t:null}invoke(e){return null}step(){return{expr:this,steps:0,changed:!1}}run(e={},...t){e instanceof i&&(t.unshift(e),e={});let r=t?this.apply(...t):this,n=e.steps??0,s=Math.max(e.max??U.max,1)+n,o=!1;for(;n<s;){let a=r.step();if(!a.changed){o=!0;break}n+=a.steps,r=a.expr}if(e.throw&&!o)throw new Error("Failed to compute expression in "+s+" steps");return{final:o,steps:n,expr:r}}*walk(e={}){let t=e.max??1/0,r=0,n=this,s=!1;for(;r<t;){let o=n.step();if(o.changed||(s=!0),yield{expr:n,steps:r,final:s},s)break;r+=o.steps,n=o.expr}}equals(e){return!this.diff(e)}diff(e,t=!1){return this===e?null:e instanceof _?e.impl.diff(this,!t):t?"["+e+" != "+this+"]":"["+this+" != "+e+"]"}expect(e,t=""){if(t=t?t+": ":"",!(e instanceof i))throw new Error(t+"Expected a combinator but found "+e?.constructor?.name);let r=this.diff(e);if(!r)return;let n=new Error(t+r);throw n.expected=this.diag(),n.actual=e.diag(),n}toString(){return this.format()}_braced(e){return!1}_unspaced(e){return this._braced(!0)}format(e={}){let t=e.html?{brackets:["(",")"],space:" ",var:["<var>","</var>"],lambda:["","-&gt;",""],around:["",""],redex:["",""]}:{brackets:["(",")"],space:" ",var:["",""],lambda:["","->",""],around:["",""],redex:["",""]};return this._format({terse:e.terse??!0,brackets:e.brackets??t.brackets,space:e.space??t.space,var:e.var??t.var,lambda:e.lambda??t.lambda,around:e.around??t.around,redex:e.redex??t.redex,inventory:e.inventory,html:e.html??!1},0)}_format(e,t){throw new Error("No _format() method defined in class "+this.constructor.name)}diag(){let e=(r,n)=>r instanceof x?[n+"App:",...r.unroll().flatMap(s=>e(s,n+"  "))]:r instanceof b?[`${n}Lambda (${r.arg}[${r.arg.id}]):`,...e(r.impl,n+"  ")]:r instanceof _?[`${n}Alias (${r.name}): \\`,...e(r.impl,n)]:r instanceof g?[`${n}FreeVar: ${r.name}[${r.id}]`]:[`${n}${r.constructor.name}: ${r}`];return e(this,"").join(`
`)}toJSON(){return this.format()}},x=class i extends w{constructor(e,t){super(),this.arg=t,this.fun=e}weight(){return this.fun.weight()+this.arg.weight()}_traverse_descend(e,t){let[r,n]=y(this.fun._traverse_redo(e,t));if(n===f.stop)return f.stop(r?r.apply(this.arg):null);let[s,o]=y(this.arg._traverse_redo(e,t)),a=r||s?(r??this.fun).apply(s??this.arg):null;return o===f.stop?f.stop(a):a}any(e){return e(this)||this.fun.any(e)||this.arg.any(e)}_fold(e,t){let[r=e,n="descend"]=y(t(e,this));if(n===f.prune)return r;if(n===f.stop)return f.stop(r);let[s=r,o="descend"]=y(this.fun._fold(r,t));if(o===f.stop)return f.stop(s);let[a=s,l="descend"]=y(this.arg._fold(s,t));return l===f.stop?f.stop(a):a}subst(e,t){let r=this.fun.subst(e,t),n=this.arg.subst(e,t);return r||n?(r??this.fun).apply(n??this.arg):null}step(){if(!this.final){let e=this.fun.invoke(this.arg);if(e instanceof w)return{expr:e,steps:1,changed:!0};typeof e=="function"&&(this.invoke=e);let t=this.fun.step();if(t.changed)return{expr:t.expr.apply(this.arg),steps:t.steps,changed:!0};let r=this.arg.step();if(r.changed)return{expr:this.fun.apply(r.expr),steps:r.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}invoke(e){let t=this.fun.invoke(this.arg);return t instanceof w?t.apply(e):typeof t=="function"?(this.invoke=t,t(e)):(this.invoke=r=>null,null)}unroll(){return[...this.fun.unroll(),this.arg]}diff(e,t=!1){if(!(e instanceof i))return super.diff(e,t);let r=this.fun.diff(e.fun,t);if(r)return r+"(...)";let n=this.arg.diff(e.arg,t);return n?this.fun+"("+n+")":null}_braced(e){return!e}_format(e,t){let r=this.fun._format(e,t+1),n=this.arg._format(e,0),s=t?["",""]:e.around;return e.terse&&!this.arg._braced(!1)?s[0]+r+(this.fun._unspaced(this.arg)?"":e.space)+n+s[1]:s[0]+r+e.brackets[0]+n+e.brackets[1]+s[1]}_unspaced(e){return this.arg._braced(!1)?!0:this.arg._unspaced(e)}},A=class i extends w{constructor(e){if(super(),typeof e!="string"||e.length===0)throw new Error("Attempt to create a named term with improper name");this.name=e}_unspaced(e){return!!(e instanceof i&&(this.name.match(/^[A-Z+]$/)&&e.name.match(/^[a-z+]/i)||this.name.match(/^[a-z+]/i)&&e.name.match(/^[A-Z+]$/)))}_format(e,t){let r=e.html?this.fancyName??this.name:this.name;return this.arity>0&&this.arity<=t?e.redex[0]+r+e.redex[1]:r}},ze=0,g=class i extends A{constructor(e,t){super(e),this.id=++ze,this.scope=t===void 0?this:t}weight(){return 0}diff(e,t=!1){if(!(e instanceof i))return super.diff(e,t);if(this.name===e.name&&this.scope===e.scope)return null;let r=this.name+"["+this.id+"]",n=e.name+"["+e.id+"]";return t?"["+n+" != "+r+"]":"["+r+" != "+n+"]"}subst(e,t){return e instanceof i&&e.name===this.name&&e.scope===this.scope?t:null}_format(e,t){let r=e.html?this.fancyName??this.name:this.name;return e.var[0]+r+e.var[1]}};g.global=["global"];var R=class extends A{constructor(e,t,r={}){super(e),this.invoke=t,this._setup({canonize:!0,...r})}},b=class i extends w{constructor(e,t){if(Array.isArray(e)){if(e.length===0)throw new Error("empty argument list in lambda constructor");let[n,...s]=e,o=new Set([n.name]);for(;s.length>0;){let a=s.pop();if(o.has(a.name))throw new Error("Duplicate free var name "+a+" in lambda expression");o.add(a.name),t=new i(a,t)}e=n}super();let r=new g(e.name,this);this.arg=r,this.impl=t.subst(e,r)??t,this.arity=1}weight(){return this.impl.weight()+1}invoke(e){return this.impl.subst(this.arg,e)??this.impl}_traverse_descend(e,t){let[r,n]=y(this.impl._traverse_redo(e,t)),s=r?new i(this.arg,r):null;return n===f.stop?f.stop(s):s}any(e){return e(this)||this.impl.any(e)}_fold(e,t){let[r=e,n="descend"]=y(t(e,this));if(n===f.prune)return r;if(n===f.stop)return f.stop(r);let[s,o]=y(this.impl._fold(r,t));return o===f.stop?f.stop(s):s??r}subst(e,t){if(e===this.arg)return null;let r=this.impl.subst(e,t);return r?new i(this.arg,r):null}diff(e,t=!1){if(!(e instanceof i))return super.diff(e,t);let r=new g("t"),n=this.invoke(r).diff(e.invoke(r),t);return n?"(t->"+n+")":null}_format(e,t){return(t>0?e.brackets[0]:"")+e.lambda[0]+this.arg._format(e,0)+e.lambda[1]+this.impl._format(e,0)+e.lambda[2]+(t>0?e.brackets[1]:"")}_braced(e){return!0}},N=class i extends w{constructor(e){if(e=Number.parseInt(e),!(e>=0))throw new Error("Church number must be a non-negative integer");super(),this.invoke=t=>r=>{let n=r;for(let s=e;s-- >0;)n=t.apply(n);return n},this.n=e,this.arity=2}diff(e,t=!1){return e instanceof i?this.n===e.n?null:t?"["+e.n+" != "+this.n+"]":"["+this.n+" != "+e.n+"]":super.diff(e,t)}_unspaced(e){return!1}_format(e,t){return t>=2?e.redex[0]+this.n+e.redex[1]:this.n+""}};function ae(i,e){return t=>e<=1?i.apply(t):ae(i.apply(t),e-1)}var _=class extends A{constructor(e,t,r={}){if(super(e),!(t instanceof w))throw new Error("Attempt to create an alias for a non-expression: "+t);this.impl=t,this._setup(r),this.terminal=r.terminal??this.props?.proper,this.invoke=ae(t,this.arity??0)}weight(){return this.terminal?1:this.impl.weight()}_traverse_descend(e,t){return this.impl._traverse_redo(e,t)}any(e){return e(this)||this.impl.any(e)}_fold(e,t){let[r=e,n]=y(t(e,this));if(n===f.prune)return r;if(n===f.stop)return f.stop(r);let[s,o]=y(this.impl._fold(r,t));return o===f.stop?f.stop(s):s??r}subst(e,t){return this===e?t:this.impl.subst(e,t)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}diff(e,t=!1){return this===e?null:e.diff(this.impl,!t)}_braced(e){return this.outdated?this.impl._braced(e):!1}_format(e,t){return(e.inventory?e.inventory[this.name]!==this:this.outdated)?this.impl._format(e,t):super._format(e,t)}};function S(i,e,t){j[i]=new R(i,e,t)}S("I",i=>i);S("K",i=>e=>i);S("S",i=>e=>t=>i.apply(t,e.apply(t)));S("B",i=>e=>t=>i.apply(e.apply(t)));S("C",i=>e=>t=>i.apply(t).apply(e));S("W",i=>e=>i.apply(e).apply(e));S("+",i=>i instanceof N?new N(i.n+1):e=>t=>e.apply(i.apply(e,t)),{note:"Increase a Church numeral argument by 1, otherwise n => f => x => f(n f x)"});function Le(i){for(;i instanceof x;)i=i.fun;return i instanceof g}function ie(i,e,t={}){let r=new Array(i.length).fill(0),n=!0;e.traverse(a=>{if(a instanceof g){let l=i.findIndex(u=>u.name===a.name);if(l>=0){r[l]++;return}}a instanceof x||(n=!1)});let s=new Set,o=new Set;for(let a=0;a<i.length;a++)r[a]===0?s.add(a):r[a]>1&&o.add(a);return{normal:!0,steps:t.steps,expr:i.length?new b(i,e):e,arity:i.length,...s.size?{skip:s}:{},...o.size?{dup:o}:{},duplicate:!!o.size||t.duplicate||!1,discard:!!s.size||t.discard||!1,proper:n}}function $e(i){return new g("abcdefgh"[i]??"x"+i)}function Fe(i,e){if(i instanceof w&&(i=[i]),e)i||(i=Object.keys(e).sort().map(s=>e[s]));else{if(!i)return[];if(!e){e={};for(let s of i)if(s instanceof A){if(e[s.name])throw new Error("duplicate name "+s);e[s.name]=s}}}let t=[],r=new Set,n=s=>{r.has(s)||(s.fold(null,(o,a)=>{if(a!==s&&a instanceof A&&e[a.name]===a)return n(a),w.control.prune(null)}),t.push(s),r.add(s))};for(let s of i)n(s);return{list:t,env:e}}w.native=j;w.control=f;w.extras={toposort:Fe};oe.exports={Expr:w,App:x,Named:A,FreeVar:g,Lambda:b,Native:R,Alias:_,Church:N}});var B=L((Be,fe)=>{"use strict";var{Tokenizer:je,restrict:W}=M(),ce=Q(),{Expr:O,Named:Je,Native:Ne,Alias:v,FreeVar:I,Lambda:Oe,Church:ue}=ce,{native:q}=O,$=class extends O{apply(...e){return e.length?e.shift().apply(...e):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}},J=class i extends ${constructor(e,t={}){if(super(),this.impl=new $,e instanceof I)this.terms=[e];else if(e instanceof i){if(!(e.impl instanceof I))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...e.terms,e.impl]}else throw new Error("Expected FreeVar or PartialLambda")}apply(e,...t){if(e===null||t.length!==0)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(e),this}postParse(){return new Oe(this.terms,this.impl)}};function le(i){return i.postParse?i.postParse():i}var qe=new je("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+"),k=class{constructor(e={}){if(this.annotate=e.annotate??!1,this.known={...q},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known)),Array.isArray(e.terms))this.bulkAdd(e.terms);else if(e.terms)for(let t in e.terms)e.terms[t].match(/^Native:/)||this.add(t,e.terms[t]);this.hasNumbers=e.numbers??!0,this.hasLambdas=e.lambdas??!0,e.allow&&this.restrict(e.allow)}add(e,t,r){return e=this._named(e,t),typeof r=="string"&&(r={note:r,canonize:!1}),e._setup({canonize:this.annotate,...r}),this.known[e.name]&&(this.known[e.name].outdated=!0),this.known[e.name]=e,this.allow.add(e.name),this}_named(e,t){if(e instanceof v)return new v(e.name,e.impl,{canonize:!0});if(typeof e!="string")throw new Error("add(): term must be an Alias or a string");if(t===void 0)throw new Error("add(): impl must be provided when term is a string");if(typeof t=="string")return new v(e,this.parse(t),{canonize:!0});if(t instanceof O)return new v(e,t,{canonize:!0});if(typeof t=="function")return new Ne(e,t);throw new Error("add(): impl must be an Expr, a string, or a function with a signature Expr => ... => Expr")}maybeAdd(e,t){return this.known[e]?this.allow.add(e):this.add(e,t),this}bulkAdd(e){for(let t of e){let r=t.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);if(!r)throw new Error("bulkAdd: invalid declaration: "+t);r[2]===""?this.remove(r[1]):this.add(r[1],this.parse(r[2]))}return this}restrict(e){return this.allow=W(this.allow,e),this}showRestrict(e="+"){let t=[],r=!0;for(let n of[...W(this.allow,e)].sort()){let s=n.match(/^[A-Z]$/);t.length&&!(r&&s)&&t.push(" "),t.push(n),r=s}return t.join("")}remove(e){return this.known[e].outdated=!0,delete this.known[e],this.allow.delete(e),this}getTerms(){let e={};for(let t of Object.keys(this.known))this.allow.has(t)&&(e[t]=this.known[t]);return e}declare(){let e=this.getTerms();for(let a in e)e[a]instanceof v||delete e[a];let t={},r=1;for(let a in q){if(!(e[a]instanceof v))continue;for(;"tmp"+r in e;)r++;let l=new v("tmp"+r,e[a]);t[l]=e[a],e[l]=l,delete e[a]}let n=O.extras.toposort(void 0,e).list,s=new Map;if(Object.keys(t).length){let a=l=>l.traverse(u=>{if(!(u instanceof v))return null;let h=s.get(u);return h||new v(u.name,a(u.impl))})??l;for(let l=0;l<n.length;l++)n[l]=a(n[l],s),s.set(t[n[l].name],n[l]),e[n[l].name]=n[l],console.log(`list[${l}] = ${n[l].name}=${n[l].impl};`);console.log("detour:",s)}let o=n.map(a=>t[a]?a.name+"="+t[a].name+"="+a.impl.format({inventory:e}):a.name+"="+a.impl.format({inventory:e}));for(let[a,l]of s)o.push(a+"="+l,l+"=");return o}parse(e,t={}){if(typeof e!="string")throw new Error("parse: source must be a string, got "+typeof e);let r=e.replace(/\/\/[^\n]*$/gm," ").replace(/\/\*.*?\*\//gs," ").trim().split(/\s*;[\s;]*/).filter(o=>o.match(/\S/)),n={...t.env},s=new $;for(let o of r){s instanceof v&&(s.outdated=!0);let a=o.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=(.*)$/s);if(a&&a[2]===""?s=new I(a[1],t.scope??I.global):s=this.parseLine(o,n,t),a){if(n[a[1]]!==void 0)throw new Error("Attempt to redefine a known term: "+a[1]);n[a[1]]=s}}return s.context={env:{...this.getTerms(),...n},scope:t.scope,src:e,parser:this},s}parseLine(e,t={},r={}){let n=e.match(/^\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);if(n)return new v(n[1],this.parseLine(n[2],t,r));let s={numbers:r.numbers??this.hasNumbers,lambdas:r.lambdas??this.hasLambdas,allow:W(this.allow,r.allow)};s.numbers?s.allow.add("+"):s.allow.delete("+");let o=qe.split(e),a=new $,l=[a],u=r.scope||I.global;for(let h of o)if(h==="(")l.push(a);else if(h===")"){if(l.length<2)throw new Error("unbalanced input: extra closing parenthesis"+e);let m=le(l.pop()),p=l.pop();l.push(p.apply(m))}else if(h==="->"){if(!s.lambdas)throw new Error("Lambdas not supported, allow them explicitly");l.push(new J(l.pop(),t))}else if(h.match(/^[0-9]+$/)){if(!s.numbers)throw new Error("Church numbers not supported, allow them explicitly");let m=l.pop();l.push(m.apply(new ue(h)))}else{let m=l.pop();if(!t[h]&&this.known[h]&&!s.allow.has(h))throw new Error("Term '"+h+"' is not in the restricted set "+[...s.allow].sort().join(" "));let p=t[h]??this.known[h]??(t[h]=new I(h,u));l.push(m.apply(p))}if(l.length!==1)throw new Error("unbalanced input: missing "+(l.length-1)+" closing parenthesis:"+e);return le(l.pop())}toJSON(){return{version:"1.1.1",allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,annotate:this.annotate,terms:this.declare()}}};k.vars=function(i={}){let e={};return new Proxy({},{get:(t,r)=>(r in e||(e[r]=new I(r,i)),e[r])})};k.church=i=>new ue(i);for(let i in q)k[i]=q[i];k.classes=ce;k.native=q;k.control=O.control;fe.exports={SKI:k}});var ee=L((Xe,me)=>{var{SKI:E}=B(),{Expr:He,FreeVar:Pe,Alias:he,Lambda:Ge}=E.classes,z=class{constructor(e){let{input:t,cases:r,allow:n,numbers:s,lambdas:o,engine:a,engineFull:l,...u}=e,h=e.env??e.vars;this.engine=a??new E,this.engineFull=l??new E,this.restrict={allow:n,numbers:s??!1,lambdas:o??!1},this.env={};let m={};for(let p of h??[]){let c=this.engineFull.parse(p,{env:m,scope:this});if(c instanceof E.classes.Alias)this.env[c.name]=new he(c.name,c.impl,{terminal:!0,canonize:!1});else if(c instanceof E.classes.FreeVar)this.env[c.name]=c;else throw new Error("Unsupported given variable type: "+p)}this.input=[];for(let p of Array.isArray(t)?t:[t])this.addInput(p);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");this.envFull={...this.env,...m};for(let p of this.input){if(p.name in this.envFull)throw new Error("input placeholder name is duplicated or clashes with env: "+p.name);this.envFull[p.name]=p.placeholder}this.cases=[],this.name=u.name??u.title,u.intro=pe(u.intro??u.descr),this.intro=u.intro,this.id=u.id,this.meta=u;for(let p of r??[])this.add(...p)}allowed(){let e=this.restrict.allow??"",t=Object.keys(this.env).sort();return e?this.engine.showRestrict(e+"+"+t.join(" ")):t.map(r=>"+"+r).join(" ")}addInput(e){if(typeof e!="object"&&(e={name:e}),typeof e.name!="string")throw new Error("quest 'input' field must be a string or a {name: string, ...} object");e.placeholder=new E.classes.FreeVar(e.name),this.input.push(e)}add(e,...t){typeof e=="string"?(t.unshift(e),e={}):e={...e},e.engine=e.engine??this.engineFull,e.env=e.env??this.envFull;let r=this.input.map(n=>n.placeholder);return this.cases.push(e.caps?new G(r,e,t):new H(r,e,t)),this}prepare(...e){if(e.length!==this.input.length)throw new Error("Solutions provided "+e.length+" terms where "+this.input.length+" are expected");let t=0,r=[],n={...this.env};for(let s=0;s<e.length;s++){let o=this.input[s],a=this.engine.parse(e[s],{env:n,allow:o.allow??this.restrict.allow,numbers:o.numbers??this.restrict.numbers,lambdas:o.lambdas??this.restrict.lambdas}),l={...this.engine.getTerms(),...n};t+=a.fold(0,(h,m)=>{if(m instanceof E.classes.Named&&l[m.name]===m)return E.control.prune(h+1)});let u=a instanceof Pe?a:new he(o.fancy??o.name,a,{terminal:!0,canonize:!1});n[o.name]=u,r.push(u)}return{prepared:r,weight:t}}check(...e){try{let{prepared:t,weight:r}=this.prepare(...e),n=this.cases.map(a=>a.check(...t)),s=n.reduce((a,l)=>a&&l.pass,!0),o=n.reduce((a,l)=>a+l.steps,0);return{expr:t[0],input:t,pass:s,steps:o,details:n,weight:r}}catch(t){return{pass:!1,details:[],exception:t,steps:0,input:e}}}verify(e){let t=this.verifyMeta(e);if(e.solutions){let r=this.verifySolutions(e.solutions);r&&(t.solutions=r)}return e.seen&&(this.id||(t.seen="No id in quest "+(this.name??"(unnamed)")),e.seen.has(this.id)&&(t.seen="Duplicate quest id "+this.id),e.seen.add(this.id)),Object.keys(t).length?t:null}verifySolutions(e){if(typeof e=="object"&&!Array.isArray(e?.accepted)&&!Array.isArray(e?.rejected)&&(!this.id||!e[this.id]))return null;let{accepted:t=[],rejected:r=[]}=e[this.id]??e,n={shouldPass:[],shouldFail:[]};for(let s of t){let o=this.check(...s);o.pass||n.shouldPass.push({input:s,result:o})}for(let s of r){let o=this.check(...s);o.pass&&n.shouldFail.push({input:s,result:o})}return n.shouldFail.length+n.shouldPass.length?n:null}verifyMeta(e={}){let t={};for(let r of["name","intro"]){let n=de(this[r]);n&&(t[r]=n)}if(e.date){let r=new Date(this.meta.created_at);isNaN(r)?t.date="invalid date format: "+this.meta.created_at:(r<new Date("2024-07-15")||r>new Date)&&(t.date="date out of range: "+this.meta.created_at)}return t}show(){return[...this.cases]}},P=class{constructor(e,t){this.max=t.max??1e3,this.note=t.note,this.env={...t.env??{}},this.input=e,this.engine=t.engine}parse(e){return new X(this.engine.parse(e,{env:this.env,scope:this}),this.input)}check(...e){throw new Error("not implemented")}},H=class extends P{constructor(e,t,r){if(r.length!==2)throw new Error("Case accepts exactly 2 strings");super(e,t),[this.e1,this.e2]=r.map(n=>this.parse(n))}check(...e){let t=this.e1.apply(e),r=t.run({max:this.max}),s=this.e2.apply(e).run({max:this.max}),o=null;return!r.final||!s.final?o="failed to reach normal form in "+this.max+" steps":o=r.expr.diff(s.expr),{pass:!o,reason:o,steps:r.steps,start:t,found:r.expr,expected:s.expr,note:this.note,args:e,case:this}}},Ve={normal:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0},G=class extends P{constructor(e,t,r){if(super(e,t),r.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!t.caps||typeof t.caps!="object"||!Object.keys(t.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");let n=Object.keys(t.caps).filter(s=>!Ve[s]);if(n.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+n.join(", "));this.expr=this.parse(r[0]),this.caps=t.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.normal=!0),this.caps.affine&&(delete this.caps.affine,this.caps.normal=!0,this.caps.duplicate=!1)}check(...e){let t=this.expr.apply(e),r=t.run({max:this.max}),n=r.expr.infer({max:this.max}),s=[];for(let o in this.caps)n[o]!==this.caps[o]&&s.push("expected property "+o+" to be "+this.caps[o]+", found "+n[o]);return{pass:!s.length,reason:s?s.join(`
`):null,steps:r.steps,start:t,found:r.expr,case:this,note:this.note,args:e}}},X=class{constructor(e,t){this.expr=e,this.env=t}apply(e){if(e.length!==this.env.length)throw new Error("Subst: expected "+this.env.length+" terms, got "+e.length);let t=this.expr;for(let r=0;r<this.env.length;r++)t=t.subst(this.env[r],e[r])??t;return t}},Y=class{constructor(e){this.name=e.name,this.intro=pe(e.intro),this.id=e.id,e.content&&(this.content=e.content.map(t=>t instanceof z?t:new z(t)))}verify(e){let t={},r=Ce(this.id,e.seen);r&&(t[this.id]=r);for(let n of["name","intro"]){let s=de(this[n]);s&&(t[n]=s)}return t.content=this.content.map(n=>n.verify(e)),t}};function pe(i){return i===void 0||typeof i=="string"?i:Array.isArray(i)?i.join(" "):""+i}function Ce(i,e){if(i===void 0)return"missing";if(typeof i!="string"&&typeof i!="number")return"is a "+typeof i;if(e){if(e.has(i))return"duplicate id "+i;e.add(i)}}function de(i){if(i===void 0)return"missing";if(typeof i!="string")return"not a string but "+typeof i;let e=[],t=/<\/?([a-z]+)(?:\s[^>]*)?>/gi,r;for(;(r=t.exec(i))!==null;){let[n,s]=r;if(n.startsWith("</")){if(e.length===0||e.pop()!==s)return`Unmatched closing tag: </${s}>`}else e.push(s)}return e.length>0?`Unclosed tags: ${e.join(", ")}`:null}z.Group=Y;z.Case=P;me.exports={Quest:z}});var ye=L((Ye,xe)=>{"use strict";var{Expr:ge,Alias:Ke,FreeVar:Re}=Q(),{Quest:we}=ee();function De(i,e,t){let{depth:r=16,infer:n=!0,progressInterval:s=1e3}=e,o=n&&!e.noskip,a=[[]],l=0,u=0,h={},m=c=>{l++;let d=n?c.infer({max:e.max,maxArgs:e.maxArgs}):null;if(o&&d.expr){if(h[d.expr])return{res:-1};h[d.expr]=!0}return u++,{res:t(c,d),props:d}};for(let c of i){let{res:d}=m(c);if(d>0)return{expr:c,total:l,probed:u,gen:1};if(d<0)continue;a[0].push(c)}let p;for(let c=1;c<r;c++){e.progress&&(e.progress({gen:c,total:l,probed:u,step:!0}),p=l);for(let d=0;d<c;d++)for(let re of a[c-d-1]||[])for(let ke of a[d]||[]){if(l>=e.tries)return{total:l,probed:u,gen:c,...e.retain?{cache:a}:{}};e.progress&&l-p>=s&&(e.progress({gen:c,total:l,probed:u,step:!1}),p=l);let D=re.apply(ke),{res:ne,props:Z}=m(D);if(ne>0)return{expr:D,total:l,probed:u,gen:c,...e.retain?{cache:a}:{}};if(ne<0)continue;let T=n?(Z.expr?0:3)+(Z.dup?1:0)+(Z.proper?0:1):0;a[c+T]||(a[c+T]=[]),a[c+T].push(D)}}return{total:l,probed:u,gen:r,...e.retain?{cache:a}:{}}}function te(i,e={}){if(i instanceof ge)return i.format(e);if(i instanceof we)return"Quest("+i.name+")";if(i instanceof we.Case)return"Quest.Case";if(Array.isArray(i))return i.map(te);if(typeof i!="object"||i===null||i.constructor!==Object)return i;let t={};for(let r in i)t[r]=te(i[r]);return t}function Ze(i,e){let t=ge.extras.toposort([i],e);return t.list.map(r=>r instanceof Ke?r.name+"="+r.impl.format({inventory:t.env}):r instanceof Re?r.name+"=":r.format({inventory:t.env})).join("; ")}xe.exports={search:De,deepFormat:te,declare:Ze}});var Me=L((et,ve)=>{var{SKI:F}=B(),{Quest:be}=ee(),Te=ye();F.Quest=be;F.extras={...Te,...F.classes.Expr.extras};typeof process=="object"&&process.env.SKI_REPL&&typeof global<"u"&&(global.SKI=F,console.log("SKI_REPL activated, try `new SKI();`"));typeof window<"u"&&(window.SKI=F);ve.exports={SKI:F,Quest:be}});Me();})();
//# sourceMappingURL=ski-interpreter.min.js.map
