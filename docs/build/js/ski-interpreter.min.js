(()=>{var j=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports);var Q=j((vt,M)=>{var F=class{constructor(...t){let e="$|(\\s+)|"+t.map(s=>"(?:"+s+")").sort((s,n)=>n.length-s.length).join("|");this.rex=new RegExp(e,"gys")}split(t){this.rex.lastIndex=0;let e=[...t.matchAll(this.rex)],n=e.pop()?.index??0;if(n!==t.length)throw new Error("Unknown tokens at pos "+n+"/"+t.length+" starting with "+t.substring(n));return e.filter(a=>a[1]===void 0).map(a=>a[0])}},ut=new F("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");function ct(r,t){if(!t)return r;let e=new Set([...r]),s=0,n=[a=>{e=new Set([a]),s=1},a=>{e.add(a)},a=>{e.delete(a)}];for(let a of ut.split(t))a==="="?s=0:a==="+"?s=1:a==="-"?s=2:n[s](a);return e}M.exports={Tokenizer:F,restrict:ct}});var H=j((_t,G)=>{"use strict";var N={max:1e3,maxArgs:32},f=class r{constructor(){if(new.target===r)throw new Error("Attempt to instantiate abstract class Expr")}apply(...t){return t.length>0?new m(this,...t):this}expand(){return this}freeOnly(){return!this.any(t=>!(t instanceof w||t instanceof m))}traverse(t){return t(this)}any(t){return t(this)}weight(){return 1}guess(t={}){let e=t.max??N.max,s=t.maxArgs??N.maxArgs;return this._guess({max:e,maxArgs:s,index:0})}_guess(t,e=[],s=0){if(e.length>t.maxArgs||s>t.max)return{normal:!1,steps:s};if(this.freeOnly())return{normal:!0,steps:s,...B(e,this)};let n=this.run({max:(t.max-s)/3});if(s+=n.steps,!n.final)return{normal:!1,steps:s};if(n.steps!==0)return n.expr._guess(t,e,s);if(this._firstVar())return{normal:!1,steps:s};let a=J(e.length+t.index);return this.apply(a)._guess(t,[...e,a],s)}_aslist(){return[this]}_firstVar(){return!1}*lambdify(t={}){let e=z(this,t);yield*V(e,t)}*rewriteSKI(t={}){let e=0,s=this;for(;;){let n={max:t.max??1,steps:0},a=s._rski(n),h=n.steps===0;if(yield{expr:s,steps:e,final:h},h)break;s=a,e+=n.steps}}_rski(t){return this}subst(t,e){return this===t?e:null}invoke(t){return null}step(){return{expr:this,steps:0,changed:!1}}run(t={},...e){t instanceof r&&(e.unshift(t),t={});let s=e?this.apply(...e):this,n=t.steps??0,a=Math.max(t.max??N.max,1)+n,h=!1;for(;n<a;){let i=s.step();if(!i.changed){h=!0;break}n+=i.steps,s=i.expr}if(t.throw&&!h)throw new Error("Failed to compute expression in "+a+" steps");return{final:h,steps:n,expr:s}}*walk(t={}){let e=t.max??1/0,s=0,n=this,a=!1;for(;s<e;){let h=n.step();if(h.changed||(a=!0),yield{expr:n,steps:s,final:a},a)break;s+=h.steps,n=h.expr}}equals(t){return!this.diff(t)}diff(t,e=!1){return this===t?null:t instanceof x?t.impl.diff(this,!e):e?"["+t+" != "+this+"]":"["+this+" != "+t+"]"}expect(t,e=""){if(e=e?e+": ":"",!(t instanceof r))throw new Error(e+"attempt to expect a combinator to equal something else: "+t);let s=this.diff(t);if(!s)return;let n=new Error(e+s);throw n.expected=t+"",n.actual=this+"",n}toString(){return this.format()}_braced(t){return!1}_unspaced(t){return this._braced(!0)}format(t={}){let e=t.html?{brackets:["(",")"],space:" ",var:["<var>","</var>"],lambda:["","-&gt;",""],around:["",""],redex:["",""]}:{brackets:["(",")"],space:" ",var:["",""],lambda:["","->",""],around:["",""],redex:["",""]};return this._format({terse:t.terse??!0,brackets:t.brackets??e.brackets,space:t.space??e.space,var:t.var??e.var,lambda:t.lambda??e.lambda,around:t.around??e.around,redex:t.redex??e.redex,inventory:t.inventory,html:t.html??!1},0)}_format(t,e){throw new Error("No _format() method defined in class "+this.constructor.name)}_declare(t,e,s){}},m=class r extends f{constructor(t,...e){if(e.length===0)throw new Error("Attempt to create an application with no arguments (likely interpreter bug)");super(),this.arg=e.pop(),this.fun=e.length?new r(t,...e):t,this.final=!1,this.arity=this.fun.arity>0?this.fun.arity-1:0}weight(){return this.fun.weight()+this.arg.weight()}_guess(t,e=[],s=0){if(e.length>t.maxArgs||s>t.max)return{normal:!1,steps:s};let n=super._guess(t,e,s);if(n.normal)return n;s=n.steps;let[a,...h]=this._aslist();if(!(a instanceof w))return{normal:!1,steps:s};let i=!1,l=!1,u=[];for(let o of h){let c=o._guess({...t,maxArgs:t.maxArgs-e.length,max:t.max-s,index:e.length+t.index});if(s+=c.steps,!c.normal)return{normal:!1,steps:s};u.push(c.expr),i=i||c.discard,l=l||c.duplicate}return{normal:!0,steps:s,...B(e,new r(a,...u),{discard:i,duplicate:l})}}_firstVar(){return this.fun._firstVar()}expand(){return this.fun.expand().apply(this.arg.expand())}traverse(t){let e=t(this);if(e instanceof f)return e;let s=this.fun.traverse(t),n=this.arg.traverse(t);return!s&&!n?null:(s??this.fun).apply(n??this.arg)}any(t){return t(this)||this.fun.any(t)||this.arg.any(t)}subst(t,e){let s=this.fun.subst(t,e),n=this.arg.subst(t,e);return s||n?(s??this.fun).apply(n??this.arg):null}step(){if(!this.final){let t=this.fun.invoke(this.arg);if(t instanceof f)return{expr:t,steps:1,changed:!0};typeof t=="function"&&(this.invoke=t);let e=this.fun.step();if(e.changed)return{expr:e.expr.apply(this.arg),steps:e.steps,changed:!0};let s=this.arg.step();if(s.changed)return{expr:this.fun.apply(s.expr),steps:s.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}invoke(t){let e=this.fun.invoke(this.arg);return e instanceof f?e.apply(t):typeof e=="function"?(this.invoke=e,e(t)):(this.invoke=s=>null,null)}split(){return[this.fun,this.arg]}_aslist(){return[...this.fun._aslist(),this.arg]}_rski(t){return t.steps>=t.max?this:this.fun._rski(t).apply(this.arg._rski(t))}diff(t,e=!1){if(!(t instanceof r))return super.diff(t,e);let s=this.fun.diff(t.fun,e);if(s)return s+"(...)";let n=this.arg.diff(t.arg,e);return n?this.fun+"("+n+")":null}_braced(t){return!t}_format(t,e){let s=this.fun._format(t,e+1),n=this.arg._format(t,0),a=e?["",""]:t.around;return t.terse&&!this.arg._braced(!1)?a[0]+s+(this.fun._unspaced(this.arg)?"":t.space)+n+a[1]:a[0]+s+t.brackets[0]+n+t.brackets[1]+a[1]}_declare(t,e,s){this.fun._declare(t,e,s),this.arg._declare(t,e,s)}_unspaced(t){return this.arg._braced(!1)?!0:this.arg._unspaced(t)}},v=class r extends f{constructor(t){if(super(),typeof t!="string"||t.length===0)throw new Error("Attempt to create a named term with improper name");this.name=t}_unspaced(t){return!!(t instanceof r&&(this.name.match(/^[A-Z+]$/)&&t.name.match(/^[a-z+]/i)||this.name.match(/^[a-z+]/i)&&t.name.match(/^[A-Z+]$/)))}_format(t,e){let s=t.html?this.fancyName??this.name:this.name;return this.arity>0&&this.arity<=e?t.redex[0]+s+t.redex[1]:s}},ot=0,w=class r extends v{constructor(t,e){super(t),this.id=++ot,this.scope=e===void 0?this:e}weight(){return 0}_firstVar(){return!0}diff(t,e=!1){if(!(t instanceof r))return super.diff(t,e);if(this.name===t.name&&this.scope===t.scope)return null;let s=this.name+"["+this.id+"]",n=t.name+"["+t.id+"]";return e?"["+n+" != "+s+"]":"["+s+" != "+n+"]"}subst(t,e){return t instanceof r&&t.name===this.name&&t.scope===this.scope?e:null}_format(t,e){let s=t.html?this.fancyName??this.name:this.name;return t.var[0]+s+t.var[1]}},S=class extends v{constructor(t,e,s={}){super(t),this.invoke=e;let n=s.canonize??!0?this.guess():{normal:!1};this.arity=s.arity||n.arity||1,this.note=s.note??n.expr?.format({terse:!0,html:!0,lambda:[""," &mapsto; ",""]})}_rski(t){if(this===d.I||this===d.K||this===d.S||t.steps>=t.max)return this;let e=this.guess().expr;return e?(t.steps++,e._rski(t)):this}},d={};function k(r,t,e){d[r]=new S(r,t,e)}var b=class r extends f{constructor(t,e){if(Array.isArray(t)){if(t.length===0)throw new Error("empty argument list in lambda constructor");let[n,...a]=t,h=new Set([n.name]);for(;a.length>0;){let i=a.pop();if(h.has(i.name))throw new Error("Duplicate free var name "+i+" in lambda expression");h.add(i.name),e=new r(i,e)}t=n}super();let s=new w(t.name,this);this.arg=s,this.impl=e.subst(t,s)??e,this.arity=1}weight(){return this.impl.weight()+1}_guess(t,e=[],s=0){if(e.length>t.maxArgs)return{normal:!1,steps:s};let n=J(e.length+t.index);return this.invoke(n)._guess(t,[...e,n],s+1)}invoke(t){return this.impl.subst(this.arg,t)??this.impl}traverse(t){let e=t(this);if(e instanceof f)return e;let s=this.impl.traverse(t);return s?new r(this.arg,s):null}any(t){return t(this)||this.impl.any(t)}subst(t,e){if(t===this.arg)return null;let s=this.impl.subst(t,e);return s?new r(this.arg,s):null}expand(){return new r(this.arg,this.impl.expand())}_rski(t){let e=this.impl._rski(t);if(t.steps>=t.max)return new r(this.arg,e);if(t.steps++,e===this.arg)return d.I;if(!e.any(s=>s===this.arg))return d.K.apply(e);if(e instanceof m){let[s,n]=e.split();return n===this.arg&&!s.any(a=>a===this.arg)?s._rski(t):d.S.apply(new r(this.arg,s)._rski(t),new r(this.arg,n)._rski(t))}throw new Error("Don't know how to convert to SKI"+this)}diff(t,e=!1){if(!(t instanceof r))return super.diff(t,e);let s=new w("t"),n=this.invoke(s).diff(t.invoke(s),e);return n?"(t->"+n+")":null}_format(t,e){return(e>0?t.brackets[0]:"")+t.lambda[0]+this.arg._format(t,0)+t.lambda[1]+this.impl._format(t,0)+t.lambda[2]+(e>0?t.brackets[1]:"")}_declare(t,e,s){this.impl._declare(t,e,s)}_braced(t){return!0}},I=class r extends S{constructor(t){let e=Number.parseInt(t);if(!(e>=0))throw new Error("Church number must be a non-negative integer");let s=""+e,n=a=>h=>{let i=h;for(let l=e;l-- >0;)i=a.apply(i);return i};super(s,n,{arity:2,canonize:!1,note:s}),this.n=e,this.arity=2}diff(t,e=!1){return t instanceof r?this.n===t.n?null:e?"["+t.n+" != "+this.n+"]":"["+this.n+" != "+t.n+"]":super.diff(t,e)}_unspaced(t){return!1}};function W(r,t){return e=>t<=1?r.apply(e):W(r.apply(e),t-1)}var x=class extends v{constructor(t,e,s={}){super(t),this.impl=e,s.note&&(this.note=s.note);let n=s.canonize?e.guess({max:s.max,maxArgs:s.maxArgs}):{normal:!1};this.arity=n.proper&&n.arity||0,this.proper=n.proper??!1,this.terminal=s.terminal??this.proper,this.canonical=n.expr,this.invoke=W(e,this.arity)}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}traverse(t){return t(this)??this.impl.traverse(t)}any(t){return t(this)||this.impl.any(t)}subst(t,e){return this===t?e:this.impl.subst(t,e)}_guess(t,e=[],s=0){return this.impl._guess(t,e,s)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}_firstVar(){return this.impl._firstVar()}diff(t,e=!1){return this===t?null:t.diff(this.impl,!e)}_rski(t){return this.impl._rski(t)}_braced(t){return this.outdated?this.impl._braced(t):!1}_format(t,e){return(t.inventory?t.inventory[this.name]!==this:this.outdated)?this.impl._format(t,e):super._format(t,e)}_declare(t,e,s){s.has(this)||(s.add(this),this.impl._declare(t,e,s),e[this.name]===this&&t.push(this.name+"="+this.impl.format({terse:!0,inventory:e})))}};k("I",r=>r);k("K",r=>t=>r);k("S",r=>t=>e=>r.apply(e,t.apply(e)));k("B",r=>t=>e=>r.apply(t.apply(e)));k("C",r=>t=>e=>r.apply(e).apply(t));k("W",r=>t=>r.apply(t).apply(t));k("+",r=>r instanceof I?new I(r.n+1):t=>e=>t.apply(r.apply(t,e)),{note:"Increase a Church numeral argument by 1, otherwise n => f => x => f(n f x)"});function ft(r){let t=Object.keys(r).filter(i=>!(r[i]instanceof v&&r[i].name===i)).map(i=>i+" = "+r[i]);if(t.length>0)throw new Error("Inventory must be a hash of named terms with matching names: "+t.join(", "));r={...r};let e=[],s=1;for(let i in d){if(!(r[i]instanceof x))continue;for(;"temp"+s in r;)s++;let l="temp"+s,u=r[i];delete r[i];let o=new x(l,u);for(let c in r)r[c]=r[c].subst(u,o)??r[c];r[l]=o,e.push([i,l])}let n=Object.values(r).filter(i=>i instanceof x).sort((i,l)=>i.name.localeCompare(l.name)),a=[],h=new Set;for(let i of n)i._declare(a,r,h);for(let[i,l]of e)a.push(i+"="+l),a.push(l+"=");return a}function B(r,t,e={}){let s=new Array(r.length).fill(0),n=!0;t.traverse(i=>{if(i instanceof w){let l=r.findIndex(u=>u.name===i.name);if(l>=0){s[l]++;return}}i instanceof m||(n=!1)});let a=new Set,h=new Set;for(let i=0;i<r.length;i++)s[i]===0?a.add(i):s[i]>1&&h.add(i);return{expr:r.length?new b(r,t):t,...e.synth?{}:{arity:r.length},...a.size?{skip:a}:{},...h.size?{dup:h}:{},duplicate:!!h.size||e.duplicate||!1,discard:!!a.size||e.discard||!1,proper:n}}function z(r){if(r instanceof m)return z(r.fun).apply(z(r.arg));if(r instanceof b)return new b(r.arg,z(r.impl));if(r instanceof x)return z(r.impl);let t=r.guess();if(t.expr)return t.expr;throw new Error("Failed to canonize expression: "+r)}function J(r){return new w("abcdefgh"[r]??"x"+r)}function*V(r,t={},e={steps:0}){if(yield{expr:r,steps:e.steps,comment:"(self)"},r.freeOnly())return;let s=r.weight();if(r instanceof b)for(let a of V(r.impl,t,e)){let h=new b(r.arg,a.expr);h.weight()<s&&(s=h.weight(),yield{expr:h,steps:e.steps,comment:"(lambda)"+a.comment})}if(r instanceof m){let[a,h]=r.split();for(let i of V(a,t,e)){let l=i.expr.apply(h);l.weight()<s&&(s=l.weight(),a=i.expr,yield{expr:l,steps:e.steps,comment:"(fun)"+i.comment})}for(let i of V(h,t,e)){let l=a.apply(i.expr);l.weight()<s&&(s=l.weight(),yield{expr:l,steps:e.steps,comment:"(arg)"+i.comment})}}let n=r.guess({max:t.max,maxArgs:t.maxArgs});e.steps+=n.steps,n.expr&&n.expr.weight()<s&&(yield{expr:n.expr,steps:e.steps,comment:"(canonical)"})}f.declare=ft;f.native=d;G.exports={Expr:f,App:m,FreeVar:w,Lambda:b,Native:S,Alias:x,Church:I}});var $=j((Et,st)=>{"use strict";var{Tokenizer:pt,restrict:C}=Q(),Y=H(),{Expr:P,Native:dt,Alias:_,FreeVar:L,Lambda:mt,Church:tt}=Y,{native:O,declare:et}=P,E=class extends P{apply(...t){return t.length?t.shift().apply(...t):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}},K=class r extends E{constructor(t,e={}){if(super(),this.impl=new E,t instanceof L)this.terms=[t];else if(t instanceof r){if(!(t.impl instanceof L))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...t.terms,t.impl]}else throw new Error("Expected FreeVar or PartialLambda")}apply(t,...e){if(t===null||e.length!==0)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(t),this}postParse(){return new mt(this.terms,this.impl)}};function X(r){return r.postParse?r.postParse():r}var wt=new pt("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+"),g=class r{constructor(t={}){if(this.annotate=t.annotate??!1,this.known={...O},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known)),Array.isArray(t.terms))this.bulkAdd(t.terms);else if(t.terms)for(let e in t.terms)t.terms[e].match(/^Native:/)||this.add(e,t.terms[e]);this.hasNumbers=t.numbers??!0,this.hasLambdas=t.lambdas??!0,t.allow&&this.restrict(t.allow)}add(t,e,s){if(t=this._named(t,e),this.annotate&&s===void 0){let n=t.guess();n.expr&&(s=n.expr.format({terse:!0,html:!0,lambda:[""," &mapsto; ",""]}))}return s!==void 0&&(t.note=s),this.known[t.name]&&(this.known[t.name].outdated=!0),this.known[t.name]=t,this.allow.add(t.name),this}_named(t,e){if(t instanceof _)return new _(t.name,t.impl,{canonize:!0});if(typeof t!="string")throw new Error("add(): term must be an Alias or a string");if(e===void 0)throw new Error("add(): impl must be provided when term is a string");if(typeof e=="string")return new _(t,this.parse(e),{canonize:!0});if(e instanceof P)return new _(t,e,{canonize:!0});if(typeof e=="function")return new dt(t,e);throw new Error("add(): impl must be an Expr, a string, or a function with a signature Expr => ... => Expr")}maybeAdd(t,e){return this.known[t]?this.allow.add(t):this.add(t,e),this}bulkAdd(t){for(let e of t){let s=e.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);if(!s)throw new Error("bulkAdd: invalid declaration: "+e);s[2]===""?this.remove(s[1]):this.add(s[1],this.parse(s[2]))}return this}restrict(t){return this.allow=C(this.allow,t),this}showRestrict(t="+"){let e=[],s=!0;for(let n of[...C(this.allow,t)].sort()){let a=n.match(/^[A-Z]$/);e.length&&!(s&&a)&&e.push(" "),e.push(n),s=a}return e.join("")}remove(t){return this.known[t].outdated=!0,delete this.known[t],this.allow.delete(t),this}getTerms(){let t={};for(let e of Object.keys(this.known))this.allow.has(e)&&(t[e]=this.known[e]);return t}declare(){return et(this.getTerms())}parse(t,e={}){if(typeof t!="string")throw new Error("parse: source must be a string, got "+typeof t);let s=t.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter(h=>h.match(/\S/)),n={...e.env},a=new E;for(let h of s){let[i,l,u]=h.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(a instanceof _&&(a.outdated=!0),a=this.parseLine(u,n,e),l!==void 0){if(n[l]!==void 0)throw new Error("Attempt to redefine a known term: "+l);a=new _(l,a),n[l]=a}}return a}parseLine(t,e={},s={}){let n={numbers:s.numbers??this.hasNumbers,lambdas:s.lambdas??this.hasLambdas,allow:C(this.allow,s.allow)};n.numbers?n.allow.add("+"):n.allow.delete("+");let a=wt.split(t),h=new E,i=[h],l=s.scope||r;for(let u of a)if(u==="(")i.push(h);else if(u===")"){if(i.length<2)throw new Error("unbalanced input: extra closing parenthesis"+t);let o=X(i.pop()),c=i.pop();i.push(c.apply(o))}else if(u==="->"){if(!n.lambdas)throw new Error("Lambdas not supported, allow them explicitly");i.push(new K(i.pop(),e))}else if(u.match(/^[0-9]+$/)){if(!n.numbers)throw new Error("Church numbers not supported, allow them explicitly");let o=i.pop();i.push(o.apply(new tt(u)))}else{let o=i.pop();if(!e[u]&&this.known[u]&&!n.allow.has(u))throw new Error("Term '"+u+"' is not in the restricted set "+[...n.allow].sort().join(" "));let c=e[u]??this.known[u]??(e[u]=new L(u,l));i.push(o.apply(c))}if(i.length!==1)throw new Error("unbalanced input: missing "+(i.length-1)+" closing parenthesis:"+t);return X(i.pop())}toJSON(){return{version:"1.1.1",allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,annotate:this.annotate,terms:this.declare()}}};g.classes=Y;g.vars=function(r={}){let t={};return new Proxy({},{get:(e,s)=>(s in t||(t[s]=new L(s,r)),t[s])})};g.church=r=>new tt(r);for(let r in O)g[r]=O[r];g.native=O;g.declare=et;st.exports={SKI:g}});var at=j((zt,nt)=>{var{SKI:A}=$(),{Expr:At,FreeVar:gt,Alias:rt,Lambda:jt}=A.classes,Z=class{constructor(t={}){let{input:e,vars:s,cases:n,allow:a,numbers:h,lambdas:i,subst:l,engine:u,engineFull:o,...c}=t;this.engine=u??new A,this.engineFull=o??new A,this.restrict={allow:a,numbers:h??!1,lambdas:i??!1},this.vars={},this.subst=Array.isArray(l)?l:[l??"phi"];let U={};for(let p of s??[]){let y=this.engineFull.parse(p,{env:U,scope:this});if(y instanceof A.classes.Alias)this.vars[y.name]=new rt(y.name,y.impl,{terminal:!0,canonize:!1});else if(y instanceof A.classes.FreeVar)this.vars[y.name]=y;else throw new Error("Unsupported given variable type: "+p)}this.input=[];for(let p of Array.isArray(e)?e:[e])this.addInput(p);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");l&&(this.input[0].fancy=this.subst[0]),this.varsFull={...this.vars,...U};for(let p of this.input){if(p.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+p.name);this.varsFull[p.name]=p.placeholder}this.cases=[],this.title=c.title,c.descr=bt(c.descr),this.descr=c.descr,this.meta=c;for(let p of n??[])this.add(...p)}allowed(){let t=this.restrict.allow??"",e=Object.keys(this.vars).sort();return t?this.engine.showRestrict(t+"+"+e.join(" ")):e.map(s=>"+"+s).join(" ")}addInput(t){if(typeof t!="object"&&(t={name:t}),typeof t.name!="string")throw new Error("quest 'input' field must be a string or a {name: string, ...} object");t.placeholder=new A.classes.FreeVar(t.name),this.input.push(t)}add(t,...e){typeof t=="string"?(e.unshift(t),t={}):t={...t},t.engine=t.engine??this.engineFull,t.vars=t.vars??this.varsFull;let s=this.input.map(n=>n.placeholder);return this.cases.push(t.caps?new T(s,t,e):new R(s,t,e)),this}prepare(...t){if(t.length!==this.input.length)throw new Error("Solutions provided "+t.length+" terms where "+this.input.length+" are expected");let e=0,s=[],n={...this.vars};for(let a=0;a<t.length;a++){let h=this.input[a],i=this.engine.parse(t[a],{env:n,allow:h.allow??this.restrict.allow,numbers:h.numbers??this.restrict.numbers,lambdas:h.lambdas??this.restrict.lambdas});e+=i.weight();let l=i instanceof gt?i:new rt(h.fancy??h.name,i,{terminal:!0,canonize:!1});n[h.name]=l,s.push(l)}return{prepared:s,weight:e}}check(...t){try{let{prepared:e,weight:s}=this.prepare(...t),n=this.cases.map(i=>i.check(...e)),a=n.reduce((i,l)=>i&&l.pass,!0),h=n.reduce((i,l)=>i+l.steps,0);return{expr:e[0],input:e,pass:a,steps:h,details:n,weight:s}}catch(e){return{pass:!1,details:[],exception:e,steps:0,input:t}}}show(){return[...this.cases]}},q=class{constructor(t,e){this.max=e.max??1e3,this.note=e.note,this.vars={...e.vars??{}},this.input=t,this.engine=e.engine}parse(t){return new D(this.engine.parse(t,{env:this.vars,scope:this}),this.input)}check(...t){throw new Error("not implemented")}},R=class extends q{constructor(t,e,s){if(s.length!==2)throw new Error("Case accepts exactly 2 strings");super(t,e),[this.e1,this.e2]=s.map(n=>this.parse(n))}check(...t){let e=this.e1.apply(t),s=e.run({max:this.max}),a=this.e2.apply(t).run({max:this.max}),h=null;return!s.final||!a.final?h="failed to reach normal form in "+this.max+" steps":h=s.expr.diff(a.expr),{pass:!h,reason:h,steps:s.steps,start:e,found:s.expr,expected:a.expr,note:this.note,args:t,case:this}}},xt={normal:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0},T=class extends q{constructor(t,e,s){if(super(t,e),s.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!e.caps||typeof e.caps!="object"||!Object.keys(e.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");let n=Object.keys(e.caps).filter(a=>!xt[a]);if(n.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+n.join(", "));this.expr=this.parse(s[0]),this.caps=e.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.normal=!0),this.caps.affine&&(delete this.caps.affine,this.caps.normal=!0,this.caps.duplicate=!1)}check(...t){let e=this.expr.apply(t),s=e.run({max:this.max}),n=s.expr.guess({max:this.max}),a=[];for(let h in this.caps)n[h]!==this.caps[h]&&a.push("expected property "+h+" to be "+this.caps[h]+", found "+n[h]);return{pass:!a.length,reason:a?a.join(`
`):null,steps:s.steps,start:e,found:s.expr,case:this,note:this.note,args:t}}},D=class{constructor(t,e){this.expr=t,this.vars=e}apply(t){if(t.length!==this.vars.length)throw new Error("Subst: expected "+this.vars.length+" terms, got "+t.length);let e=this.expr;for(let s=0;s<this.vars.length;s++)e=e.subst(this.vars[s],t[s])??e;return e}};function bt(r){return r===void 0?r:Array.isArray(r)?r.join(" "):""+r}nt.exports={Quest:Z}});var yt=j((St,lt)=>{var it=$(),ht=at();lt.exports={...it,...ht};typeof window<"u"&&(window.SKI=it.SKI,window.SKI.Quest=ht.Quest)});yt();})();
//# sourceMappingURL=ski-interpreter.min.js.map
