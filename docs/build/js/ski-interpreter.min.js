(()=>{var z=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports);var $=z((Ee,B)=>{var F=class{constructor(...e){let t="$|(\\s+)|"+e.map(s=>"(?:"+s+")").sort((s,n)=>n.length-s.length).join("|");this.rex=new RegExp(t,"gys")}split(e){this.rex.lastIndex=0;let t=[...e.matchAll(this.rex)],n=t.pop()?.index??0;if(n!==e.length)throw new Error("Unknown tokens at pos "+n+"/"+e.length+" starting with "+e.substring(n));return t.filter(a=>a[1]===void 0).map(a=>a[0])}},ae=new F("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");function ie(r,e){if(!e)return r;let t=new Set([...r]),s=0,n=[a=>{t=new Set([a]),s=1},a=>{t.add(a)},a=>{t.delete(a)}];for(let a of ae.split(e))a==="="?s=0:a==="+"?s=1:a==="-"?s=2:n[s](a);return t}function le(r,e){let t=new Set,s=new Set;for(let n=0;n<r.length;n++){let a=e.get(r[n])??0;a?a>1&&s.add(n):t.add(n)}return[t,s]}function he(r,e){for(let t of r)if(!e.has(t))return!1;return!0}B.exports={Tokenizer:F,restrict:ie,skipDup:le,isSubset:he}});var G=z((Ae,W)=>{"use strict";var{skipDup:oe,isSubset:ue}=$(),S={terse:!0,max:1e3,maxArgs:32},p=class r{constructor(){if(new.target===r)throw new Error("Attempt to instantiate abstract class Expr")}postParse(){return this}apply(...e){return e.length>0?new k(this,...e):this}expand(){return this}freeVars(){let e=this.getSymbols(),t=new Set;for(let[s,n]of e)s instanceof m&&t.add(s);return t}hasLambda(){return this.getSymbols().has(r.lambdaPlaceholder)}freeOnly(){for(let[e,t]of this.getSymbols())if(!(e instanceof m))return!1;return!0}getSymbols(){return new Map([[this,1]])}replace(e,t={}){let s=[];if(e.length===0)return this;for(let n of e){let a=Array.isArray(n)?n:[n,n];if(a[0]=a[0].guess(t).expr,!a[0])throw new Error("Failed to canonize term "+n);if(a.length!==2)throw new Error("Expected a pair of terms to replace, got "+n);s.push(a)}return this._replace(s,t)??this}_replace(e,t){let s=this.guess(t).expr;for(let[n,a]of e)if(s.equals(n))return a;return null}weight(){return 1}guess(e={}){let t=e.max??S.max,s=e.maxArgs??S.maxArgs;return this._guess({max:t,maxArgs:s,index:0})}_guess(e,t=[],s=0){if(t.length>e.maxArgs||s>e.max)return{normal:!1,steps:s};if(this.freeOnly())return{normal:!0,steps:s,...Q(t,this)};let n=this.run({max:(e.max-s)/3});if(s+=n.steps,!n.final)return{normal:!1,steps:s};if(n.steps!==0)return n.expr._guess(e,t,s);if(this._firstVar())return{normal:!1,steps:s};let a=U(t.length+e.index);return this.apply(a)._guess(e,[...t,a],s)}_aslist(){return[this]}_firstVar(){return!1}*lambdify(e={}){let t=j(this,e);yield*I(t,e)}*rewriteSKI(e={}){let t=0,s=this;for(;;){let n={max:e.max??1,steps:0},a=s._rski(n),l=n.steps===0;if(yield{expr:s,steps:t,final:l},l)break;s=a,t+=n.steps}}renameVars(e){return this}_rski(e){return this}reduce(e){return null}subst(e,t){return this===e?t:null}step(){return{expr:this,steps:0,changed:!1}}run(e={},...t){e instanceof r&&(t.unshift(e),e={});let s=t?this.apply(...t):this,n=e.steps??0,a=Math.max(e.max??S.max,1)+n,l=!1;for(;n<a;){let i=s.step();if(!i.changed){l=!0;break}n+=i.steps,s=i.expr}if(e.throw&&!l)throw new Error("Failed to compute expression in "+a+" steps");return{final:l,steps:n,expr:s}}*walk(e={}){let t=e.max??1/0,s=0,n=this,a=!1;for(;s<t;){let l=n.step();if(l.changed||(a=!0),yield{expr:n,steps:s,final:a},a)break;s+=l.steps,n=l.expr}}equals(e){return this===e?!0:e instanceof g?e.equals(this):!1}contains(e){return this===e||this.equals(e)}expect(e,t=""){if(t=t?t+": ":"",!(e instanceof r))throw new Error(t+"attempt to expect a combinator to equal something else: "+e);if(this.equals(e))return;let s=new Error(t+"found term "+this+" but expected "+e);throw s.expected=e.toString(),s.actual=this.toString(),s}toString(e={}){throw new Error("No toString() method defined in class "+this.constructor.name)}needsParens(e){return!1}_unspaced(e){return this.needsParens(!0)}format(e={}){let t=e.html?{brackets:["(",")"],space:" ",var:["<var>","</var>"],lambda:["","-&gt;",""],around:["",""],redex:["<b>","</b>"]}:{brackets:["(",")"],space:" ",var:["",""],lambda:["","->",""],around:["",""],redex:["",""]};return this._format({terse:e.terse??S.terse,brackets:e.brackets??t.brackets,space:e.space??t.space,var:e.var??t.var,lambda:e.lambda??t.lambda,around:e.around??t.around,redex:e.redex??t.redex,inventory:e.inventory},0)}_format(e,t){throw new Error("No _format() method defined in class "+this.constructor.name)}_declare(e,t,s){}toJSON(){return this.expand().toString({terse:!1})}},k=class r extends p{constructor(e,...t){if(t.length===0)throw new Error("Attempt to create an application with no arguments (likely interpreter bug)");super(),this.arg=t.pop(),this.fun=t.length?new r(e,...t):e,this.final=!1,this.arity=this.fun.arity>0?this.fun.arity-1:0}weight(){return this.fun.weight()+this.arg.weight()}getSymbols(){let e=this.fun.getSymbols();for(let[t,s]of this.arg.getSymbols())e.set(t,(e.get(t)??0)+s);return e}_guess(e,t=[],s=0){if(t.length>e.maxArgs||s>e.max)return{normal:!1,steps:s};let n=super._guess(e,t,s);if(n.normal)return n;s=n.steps;let[a,...l]=this._aslist();if(!(a instanceof m))return{normal:!1,steps:s};let i=!1,h=!1,o=[];for(let c of l){let u=c._guess({...e,maxArgs:e.maxArgs-t.length,max:e.max-s,index:t.length+e.index});if(s+=u.steps,!u.normal)return{normal:!1,steps:s};o.push(u.expr),i=i||u.discard,h=h||u.duplicate}return{normal:!0,steps:s,...Q(t,new r(a,...o),{discard:i,duplicate:h})}}_firstVar(){return this.fun._firstVar()}apply(...e){return e.length===0?this:new r(this,...e)}expand(){return this.fun.expand().apply(this.arg.expand())}_replace(e,t){let s=super._replace(e,t);if(s)return s;let[n,a]=this.split();return(n._replace(e,t)??n).apply(a._replace(e,t)??a)}renameVars(e){return this.fun.renameVars(e).apply(this.arg.renameVars(e))}subst(e,t){let s=this.fun.subst(e,t),n=this.arg.subst(e,t);return s||n?(s??this.fun).apply(n??this.arg):null}step(){if(!this.final){if(this.arity===0){let s=this.fun.reduce([this.arg]);if(s)return{expr:s,steps:1,changed:!0}}let e=this.fun.step();if(e.changed)return{expr:e.expr.apply(this.arg),steps:e.steps,changed:!0};let t=this.arg.step();if(t.changed)return{expr:this.fun.apply(t.expr),steps:t.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}reduce(e){return this.fun.reduce([this.arg,...e])}split(){return[this.fun,this.arg]}_aslist(){return[...this.fun._aslist(),this.arg]}_rski(e){return e.steps>=e.max?this:this.fun._rski(e).apply(this.arg._rski(e))}equals(e){return e instanceof r?this.fun.equals(e.fun)&&this.arg.equals(e.arg):super.equals(e)}contains(e){return this.fun.contains(e)||this.arg.contains(e)||super.contains(e)}needsParens(e){return!e}toString(e={}){let t=this.fun.toString(e),s=this.fun.needsParens(!0)?"("+t+")":t;if(e.terse??S.terse){let n=this.arg.toString(e);this.arg.needsParens(!1)&&(n="("+n+")");let a=s.match(/\)$/)||n.match(/^\(/)||s.match(/[A-Z]$/)&&n.match(/^[a-z]/i)?"":" ";return s+a+n}else return s+"("+this.arg.toString(e)+")"}_format(e,t){let s=this.fun._format(e,t+1),n=this.arg._format(e,0),a=t?["",""]:e.around;return e.terse&&!this.arg.needsParens(!1)?a[0]+s+(this.fun._unspaced(this.arg)?"":e.space)+n+a[1]:a[0]+s+e.brackets[0]+n+e.brackets[1]+a[1]}_declare(e,t,s){this.fun._declare(e,t,s),this.arg._declare(e,t,s)}_unspaced(e){return this.arg.needsParens(!1)?!0:this.arg._unspaced(e)}},E=class r extends p{constructor(e){if(super(),typeof e!="string"||e.length===0)throw new Error("Attempt to create a named term with improper name");this.name=e}toString(){return this.name}_unspaced(e){return!!(e instanceof r&&(this.name.match(/^[A-Z+]$/)&&e.name.match(/^[a-z+]/i)||this.name.match(/^[a-z+]/i)&&e.name.match(/^[A-Z+]$/)))}_format(e,t){return this.arity>0&&this.arity<=t?e.redex[0]+this.name+e.redex[1]:this.name}},ce=0,m=class extends E{constructor(e){super(e),this.id=++ce}weight(){return 0}_firstVar(){return!0}toString(e={}){return e.html&&/^[a-z]$/.test(this.name)?"<var>"+this.name+"</var>":this.name}_format(e,t){return e.var[0]+this.name+e.var[1]}},A=class extends E{constructor(e,t,s={}){super(e),this.impl=t,s.apply&&(this.onApply=s.apply),this.arity=s.arity??1;let n=s.canonize??!0?this.guess():{normal:!1};s.arity||(this.arity=n.arity||1),this.note=s.note??n.expr?.toString({terse:!0,html:!0})}apply(...e){if(this.onApply&&e.length>=1){if(typeof this.onApply!="function")throw new Error("Native combinator "+this+" has an invalid onApply property  of type"+typeof this.onApply+": "+this.onApply);let t=this.onApply(e[0]);if(t instanceof p)return t.apply(...e.slice(1))}return super.apply(...e)}_rski(e){if(this===w.I||this===w.K||this===w.S||e.steps>=e.max)return this;let t=this.guess().expr;return t?(e.steps++,t._rski(e)):this}reduce(e){if(e.length<this.arity)return null;let t=0,s=this.impl;for(;typeof s=="function";){if(t>=e.length)return null;s=s(e[t++])}if(!(s instanceof p))throw new Error("Native combinator "+this+" reduced to a non-expression: "+s);return s.apply(...e.slice(t))}toJSON(){return"Native:"+this.name}},w={};function _(r,e,t){w[r]=new A(r,e,t)}var x=class r extends p{constructor(e,t){if(Array.isArray(e)){if(e.length===0)throw new Error("empty argument list in lambda constructor");let[n,...a]=e,l=new Set([n.name]);for(;a.length>0;){let i=a.pop();if(l.has(i.name))throw new Error("Duplicate free var name "+i+" in lambda expression");l.add(i.name),t=new r(i,t)}e=n}super();let s=new m(e.name);this.arg=s,this.impl=t.subst(e,s)??t,this.arity=1}getSymbols(){let e=this.impl.getSymbols();return e.delete(this.arg),e.set(p.lambdaPlaceholder,(e.get(p.lambdaPlaceholder)??0)+1),e}weight(){return this.impl.weight()+1}_guess(e,t=[],s=0){if(t.length>e.maxArgs)return{normal:!1,steps:s};let n=U(t.length+e.index);return this.reduce([n])._guess(e,[...t,n],s+1)}reduce(e){if(e.length===0)return null;let[t,...s]=e;return(this.impl.subst(this.arg,t)??this.impl).apply(...s)}subst(e,t){if(e===this.arg)return null;let s=this.impl.subst(e,t);return s?new r(this.arg,s):null}expand(){return new r(this.arg,this.impl.expand())}renameVars(e){let t=new m(e.next().value),s=this.impl.subst(this.arg,t)??this.impl;return new r(t,s.renameVars(e))}_rski(e){let t=this.impl._rski(e);if(e.steps>=e.max)return new r(this.arg,t);if(e.steps++,t===this.arg)return w.I;if(!t.getSymbols().has(this.arg))return w.K.apply(t);if(t instanceof k){let[s,n]=t.split();return n===this.arg&&!s.getSymbols().has(this.arg)?s._rski(e):w.S.apply(new r(this.arg,s)._rski(e),new r(this.arg,n)._rski(e))}throw new Error("Don't know how to convert to SKI"+this)}_replace(e,t){let s=super._replace(e,t);return s||new r(this.arg,this.impl._replace(e,t)??this.impl)}equals(e){if(!(e instanceof r))return super.equals(e);let t=new m("t");return e.reduce([t]).equals(this.reduce([t]))}contains(e){return this.equals(e)||this.impl.contains(e)}toString(e={}){let t=e.html?" &mapsto; ":"->";return this.arg.toString(e)+t+this.impl.toString(e)}_format(e,t){return(t>0?e.brackets[0]:"")+e.lambda[0]+this.arg._format(e,0)+e.lambda[1]+this.impl._format(e,0)+e.lambda[2]+(t>0?e.brackets[1]:"")}_declare(e,t,s){this.impl._declare(e,t,s)}needsParens(e){return!0}},P=class r extends A{constructor(e){let t=Number.parseInt(e);if(!(t>=0))throw new Error("Church number must be a non-negative integer");let s=""+t,n=a=>l=>{let i=l;for(let h=t;h-- >0;)i=a.apply(i);return i};super(s,n,{arity:2,canonize:!1,note:s}),this.n=t,this.arity=2}equals(e){return e instanceof r?this.n===e.n:super.equals(e)}_unspaced(e){return!1}},g=class extends E{constructor(e,t,s={}){super(e),this.impl=t,s.note&&(this.note=s.note);let n=s.canonize?t.guess({max:s.max,maxArgs:s.maxArgs}):{normal:!1};this.arity=n.proper&&n.arity||0,this.proper=n.proper??!1,this.terminal=s.terminal??this.proper,this.canonical=n.expr}getSymbols(){return this.terminal?new Map([[this,1]]):this.impl.getSymbols()}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}subst(e,t){return this===e?t:this.impl.subst(e,t)}_guess(e,t=[],s=0){return this.impl._guess(e,t,s)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}reduce(e){return e.length<this.arity?null:this.impl.apply(...e)}_firstVar(){return this.impl._firstVar()}equals(e){return e.equals(this.impl)}contains(e){return this.impl.contains(e)}_rski(e){return this.impl._rski(e)}toString(e){return this.outdated?this.impl.toString(e):super.toString(e)}needsParens(e){return this.outdated?this.impl.needsParens():!1}_format(e,t){return(e.inventory?e.inventory[this.name]!==this:this.outdated)?this.impl._format(e,t):super._format(e,t)}_declare(e,t,s){s.has(this)||(s.add(this),this.impl._declare(e,t,s),t[this.name]===this&&e.push(this.name+"="+this.impl.format({terse:!0,inventory:t})))}};_("I",r=>r);_("K",r=>e=>r);_("S",r=>e=>t=>r.apply(t,e.apply(t)));_("B",r=>e=>t=>r.apply(e.apply(t)));_("C",r=>e=>t=>r.apply(t).apply(e));_("W",r=>e=>r.apply(e).apply(e));_("+",r=>e=>t=>e.apply(r.apply(e,t)),{note:"<var>n</var> &mapsto; <var>n</var> + 1 <i>or</i> SB",apply:r=>r instanceof P?new P(r.n+1):null});p.lambdaPlaceholder=new A("->",r=>r,{arity:1,canonize:!1,note:"Lambda placeholder",apply:r=>{throw new Error("Attempt to use a placeholder in expression")}});function fe(r){let e=Object.keys(r).filter(i=>!(r[i]instanceof E&&r[i].name===i)).map(i=>i+" = "+r[i]);if(e.length>0)throw new Error("Inventory must be a hash of named terms with matching names: "+e.join(", "));r={...r};let t=[],s=1;for(let i in w){if(!(r[i]instanceof g))continue;for(;"temp"+s in r;)s++;let h="temp"+s,o=r[i];delete r[i];let c=new g(h,o);for(let u in r)r[u]=r[u].subst(o,c)??r[u];r[h]=c,t.push([i,h])}let n=Object.values(r).filter(i=>i instanceof g).sort((i,h)=>i.name.localeCompare(h.name)),a=[],l=new Set;for(let i of n)i._declare(a,r,l);for(let[i,h]of t)a.push(i+"="+h),a.push(h+"=");return a}function Q(r,e,t={}){let s=e.getSymbols(),[n,a]=oe(r,s);return{expr:r.length?new x(r,e):e,...t.synth?{}:{arity:r.length},...n.size?{skip:n}:{},...a.size?{dup:a}:{},duplicate:!!a.size||t.duplicate||!1,discard:!!n.size||t.discard||!1,proper:ue(s.keys(),new Set(r))}}function j(r){if(r instanceof k)return j(r.fun).apply(j(r.arg));if(r instanceof x)return new x(r.arg,j(r.impl));if(r instanceof g)return j(r.impl);let e=r.guess();if(e.expr)return e.expr;throw new Error("Failed to canonize expression: "+r)}function U(r){return new m("abcdefgh"[r]??"x"+r)}function*I(r,e={},t={steps:0}){if(yield{expr:r,steps:t.steps,comment:"(self)"},r.freeOnly())return;let s=r.weight();if(r instanceof x)for(let a of I(r.impl,e,t)){let l=new x(r.arg,a.expr);l.weight()<s&&(s=l.weight(),yield{expr:l,steps:t.steps,comment:"(lambda)"+a.comment})}if(r instanceof k){let[a,l]=r.split();for(let i of I(a,e,t)){let h=i.expr.apply(l);h.weight()<s&&(s=h.weight(),a=i.expr,yield{expr:h,steps:t.steps,comment:"(fun)"+i.comment})}for(let i of I(l,e,t)){let h=a.apply(i.expr);h.weight()<s&&(s=h.weight(),yield{expr:h,steps:t.steps,comment:"(arg)"+i.comment})}}let n=r.guess({max:e.max,maxArgs:e.maxArgs});t.steps+=n.steps,n.expr&&n.expr.weight()<s&&(yield{expr:n.expr,steps:t.steps,comment:"(canonical)"})}W.exports={Expr:p,App:k,FreeVar:m,Lambda:x,Native:A,Alias:g,Church:P,globalOptions:S,native:w,declare:fe}});var R=z((qe,X)=>{var{Tokenizer:pe,restrict:C}=$(),{globalOptions:me,Expr:N,App:ve,FreeVar:V,Lambda:H,Native:de,Alias:y,Church:Z,native:O,declare:we}=G(),v=class extends N{apply(...e){return e.length?e.shift().apply(...e):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}},K=class r extends v{constructor(e,t={}){if(super(),this.impl=new v,e instanceof V)this.terms=[e];else if(e instanceof r){if(!(e.impl instanceof V))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...e.terms,e.impl]}else throw new Error("Expected FreeVar or PartialLambda")}apply(e,...t){if(e===null||t.length!==0)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(e),this}postParse(){return new H(this.terms,this.impl)}},ge=new pe("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+"),d=class r{constructor(e={}){if(this.annotate=e.annotate??!1,this.known={...O},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known)),Array.isArray(e.terms))this.bulkAdd(e.terms);else if(e.terms)for(let t in e.terms)e.terms[t].match(/^Native:/)||this.add(t,e.terms[t]);this.hasNumbers=e.numbers??!0,this.hasLambdas=e.lambdas??!0,e.allow&&this.restrict(e.allow)}add(e,t,s){if(typeof e=="string")if(typeof t=="string")e=new y(e,this.parse(t),{canonize:!0});else if(t instanceof N)e=new y(e,t,{canonize:!0});else throw new Error("add: term must be an Alias or a string and impl must be an Expr or a string");else e instanceof y&&(e=new y(e.name,e.impl,{canonize:!0}));if(!(e instanceof y))throw new Error("add: term must be an Alias or a string (accompanied with an implementation)");return this.annotate&&s===void 0&&e.canonical&&(s=e.canonical.toString({terse:!0,html:!0})),s!==void 0&&(e.note=s),this.known[e.name]&&(this.known[e.name].outdated=!0),this.known[e.name]=e,this.allow.add(e.name),this}maybeAdd(e,t){return this.known[e]?this.allow.add(e):this.add(e,t),this}bulkAdd(e){for(let t of e){let s=t.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);if(!s)throw new Error("bulkAdd: invalid declaration: "+t);s[2]===""?this.remove(s[1]):this.add(s[1],this.parse(s[2]))}return this}restrict(e){return this.allow=C(this.allow,e),this}showRestrict(e="+"){let t=[],s=!0;for(let n of[...C(this.allow,e)].sort()){let a=n.match(/^[A-Z]$/);t.length&&!(s&&a)&&t.push(" "),t.push(n),s=a}return t.join("")}remove(e){return this.known[e].outdated=!0,delete this.known[e],this.allow.delete(e),this}getTerms(){let e={};for(let t of Object.keys(this.known))this.allow.has(t)&&(e[t]=this.known[t]);return e}declare(){return we(this.getTerms())}parse(e,t={},s={}){if(typeof e!="string")throw new Error("parse: source must be a string, got "+typeof e);let n=e.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter(i=>i.match(/\S/)),a={...t},l=new v;for(let i of n){let[h,o,c]=i.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(l instanceof y&&(l.outdated=!0),l=this.parseLine(c,a,s),o!==void 0){if(a[o]!==void 0)throw new Error("Attempt to redefine a known term: "+o);l=new y(o,l),a[o]=l}}for(let i in a)!t[i]&&a[i]instanceof r.classes.FreeVar&&(t[i]=a[i]);return l}parseLine(e,t={},s={}){let n={numbers:s.numbers??this.hasNumbers,lambdas:s.lambdas??this.hasLambdas,allow:C(this.allow,s.allow)};n.numbers?n.allow.add("+"):n.allow.delete("+");let a=ge.split(e),l=new v,i=[l];for(let h of a)if(h==="(")i.push(l);else if(h===")"){if(i.length<2)throw new Error("unbalanced input: extra closing parenthesis"+e);let o=i.pop().postParse(),c=i.pop();i.push(c.apply(o))}else if(h==="->"){if(!n.lambdas)throw new Error("Lambdas not supported, allow them explicitly");i.push(new K(i.pop(),t))}else if(h.match(/^[0-9]+$/)){if(!n.numbers)throw new Error("Church numbers not supported, allow them explicitly");let o=i.pop();i.push(o.apply(new Z(h)))}else{let o=i.pop();if(!t[h]&&this.known[h]&&!n.allow.has(h))throw new Error("Term '"+h+"' is not in the restricted set "+[...n.allow].sort().join(" "));let c=t[h]??this.known[h]??(t[h]=new V(h));i.push(o.apply(c))}if(i.length!==1)throw new Error("unbalanced input: missing "+(i.length-1)+" closing parenthesis:"+e);return i.pop().postParse()}toJSON(){return{version:"1.1.1",allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,annotate:this.annotate,terms:this.declare()}}};d.free=(...r)=>r.map(e=>new V(e));d.church=r=>new Z(r);d.classes={Expr:N,Native:de,Alias:y,FreeVar:V,Lambda:H,Church:Z};for(let r in O)d[r]=O[r];d.native=O;d.options=me;d.lambdaPlaceholder=N.lambdaPlaceholder;X.exports={SKI:d}});var te=z((je,ee)=>{var{SKI:q}=R(),{Expr:ze,FreeVar:xe,Alias:Y,Lambda:ye}=q.classes,D=class{constructor(e={}){let{input:t,vars:s,cases:n,allow:a,numbers:l,lambdas:i,subst:h,engine:o,engineFull:c,...u}=e;this.engine=o??new q,this.engineFull=c??new q,this.restrict={allow:a,numbers:l??!1,lambdas:i??!1},this.vars={},this.subst=Array.isArray(h)?h:[h??"phi"];let T={};for(let f of s??[]){let b=this.engineFull.parse(f,T);if(b instanceof q.classes.Alias)this.vars[b.name]=new Y(b.name,b.impl,{terminal:!0,canonize:!1});else if(b instanceof q.classes.FreeVar)this.vars[b.name]=b;else throw new Error("Unsupported given variable type: "+f)}this.input=[];for(let f of Array.isArray(t)?t:[t])this.addInput(f);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");h&&(this.input[0].fancy=this.subst[0]),this.varsFull={...this.vars,...T};for(let f of this.input){if(f.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+f.name);this.varsFull[f.name]=f.placeholder}this.cases=[],this.title=u.title,u.descr=ke(u.descr),this.descr=u.descr,this.meta=u;for(let f of n??[])this.add(...f)}allowed(){let e=this.restrict.allow??"",t=Object.keys(this.vars).sort();return e?this.engine.showRestrict(e+"+"+t.join(" ")):t.map(s=>"+"+s).join(" ")}addInput(e){if(typeof e!="object"&&(e={name:e}),typeof e.name!="string")throw new Error("quest 'input' field must be a string or a {name: string, ...} object");[e.placeholder]=q.free(e.name),this.input.push(e)}add(e,...t){typeof e=="string"?(t.unshift(e),e={}):e={...e},e.engine=e.engine??this.engineFull,e.vars=e.vars??this.varsFull;let s=this.input.map(n=>n.placeholder);return this.cases.push(e.caps?new J(s,e,t):new M(s,e,t)),this}prepare(...e){if(e.length!==this.input.length)throw new Error("Solutions provided "+e.length+" terms where "+this.input.length+" are expected");let t=0,s=[],n={...this.vars};for(let a=0;a<e.length;a++){let l=this.input[a],i=this.engine.parse(e[a],n,{allow:l.allow??this.restrict.allow,numbers:l.numbers??this.restrict.numbers,lambdas:l.lambdas??this.restrict.lambdas});t+=i.weight();let h=i instanceof xe?i:new Y(l.fancy??l.name,i,{terminal:!0,canonize:!1});n[l.name]=h,s.push(h)}return{prepared:s,weight:t}}check(...e){try{let{prepared:t,weight:s}=this.prepare(...e),n=this.cases.map(i=>i.check(...t)),a=n.reduce((i,h)=>i&&h.pass,!0),l=n.reduce((i,h)=>i+h.steps,0);return{expr:t[0],input:t,pass:a,steps:l,details:n,weight:s}}catch(t){return{pass:!1,details:[],exception:t,steps:0,input:e}}}show(){return[...this.cases]}},L=class{constructor(e,t){this.max=t.max??1e3,this.note=t.note,this.vars={...t.vars??{}},this.input=e,this.engine=t.engine}parse(e){return new ye(this.input,this.engine.parse(e,this.vars))}check(...e){throw new Error("not implemented")}},M=class extends L{constructor(e,t,s){if(s.length!==2)throw new Error("Case accepts exactly 2 strings");super(e,t),[this.e1,this.e2]=s.map(n=>this.parse(n))}check(...e){let t=(i,h)=>i.reduce(h)??i.apply(...h),s=t(this.e1,e),n=s.run({max:this.max}),a=t(this.e2,e).run({max:this.max}),l=null;return!n.final||!a.final?l="failed to reach normal form in "+this.max+" steps":n.expr.equals(a.expr)||(l="expected: "+a.expr),{pass:!l,reason:l,steps:n.steps,start:s,found:n.expr,expected:a.expr,note:this.note,args:e,case:this}}},be={normal:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0},J=class extends L{constructor(e,t,s){if(super(e,t),s.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!t.caps||typeof t.caps!="object"||!Object.keys(t.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");let n=Object.keys(t.caps).filter(a=>!be[a]);if(n.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+n.join(", "));this.expr=this.parse(s[0]),this.caps=t.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.normal=!0),this.caps.affine&&(delete this.caps.affine,this.caps.normal=!0,this.caps.duplicate=!1)}check(...e){let t=this.expr.apply(...e),s=t.run({max:this.max}),n=s.expr.guess({max:this.max}),a=[];for(let l in this.caps)n[l]!==this.caps[l]&&a.push("expected property "+l+" to be "+this.caps[l]+", found "+n[l]);return{pass:!a.length,reason:a?a.join(`
`):null,steps:s.steps,start:t,found:s.expr,case:this,note:this.note,args:e}}};function ke(r){return r===void 0?r:Array.isArray(r)?r.join(" "):""+r}ee.exports={Quest:D}});var _e=z((Pe,ne)=>{var se=R(),re=te();ne.exports={...se,...re};typeof window<"u"&&(window.SKI=se.SKI,window.SKI.Quest=re.Quest)});_e();})();
//# sourceMappingURL=ski-interpreter.min.js.map
