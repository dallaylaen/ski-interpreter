(()=>{var S=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports);var D=S((Re,ne)=>{var $=class{constructor(...e){let t="$|(\\s+)|"+e.map(r=>"(?:"+r+")").sort((r,n)=>n.length-r.length).join("|");this.rex=new RegExp(t,"gys")}split(e){this.rex.lastIndex=0;let t=[...e.matchAll(this.rex)],n=t.pop()?.index??0;if(n!==e.length)throw new Error("Unknown tokens at pos "+n+"/"+e.length+" starting with "+e.substring(n));return t.filter(i=>i[1]===void 0).map(i=>i[0])}},ve=new $("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");function ke(s,e){if(!e)return s;let t=new Set([...s]),r={"=":i=>{t=new Set([i]),n="+"},"+":i=>{t.add(i)},"-":i=>{t.delete(i)}},n="=";for(let i of ve.split(e))r[i]?n=i:r[n](i);return t}var K=class{constructor(e,t){this.value=e,this.action=t}};function _e(s){return s instanceof K?[s.value??void 0,s.action]:[s??void 0,void 0]}function Ee(s){return e=>new K(e,s)}ne.exports={Tokenizer:$,restrict:ke,unwrap:_e,prepareWrapper:Ee}});var W=S((Te,oe)=>{"use strict";var{unwrap:b,prepareWrapper:M}=D(),U={max:1e3,maxArgs:32},v={descend:M("descend"),prune:M("prune"),stop:M("stop")},d=class s{constructor(){if(new.target===s)throw new Error("Attempt to instantiate abstract class Expr")}apply(...e){let t=this;for(let r of e)t=new g(t,r);return t}expand(){return this}freeOnly(){return!this.any(e=>!(e instanceof w||e instanceof g))}traverse(e){return e(this)}any(e){return e(this)}fold(e,t){let[r,n]=b(this._fold(e,t));return r??e}_fold(e,t){return t(e,this)}weight(){return 1}infer(e={}){let t=e.max??U.max,r=e.maxArgs??U.maxArgs;return this._infer({max:t,maxArgs:r,index:0})}_infer(e,t=[],r=0){if(t.length>e.maxArgs||r>e.max)return{normal:!1,steps:r};if(this.freeOnly())return{normal:!0,steps:r,...ie(t,this)};let n=this.run({max:(e.max-r)/3});if(r+=n.steps,!n.final)return{normal:!1,steps:r};if(n.steps!==0)return n.expr._infer(e,t,r);if(this.unroll()[0]instanceof w)return{normal:!1,steps:r};let i=ae(t.length+e.index);return this.apply(i)._infer(e,[...t,i],r)}unroll(){return[this]}*toLambda(e={}){let t=this.traverse(r=>{if(r instanceof w||r instanceof g||r instanceof E||r instanceof q)return null;let n=r.infer({max:e.max,maxArgs:e.maxArgs});if(!n.normal)throw new Error("Failed to infer an equivalent  lambda term for "+r);return n.expr})??this;yield*V(t,e)}*toSKI(e={}){let t=0,r=this;for(;;){let n={max:e.max??1,steps:0},i=r._rski(n),l=n.steps===0;if(yield{expr:r,steps:t,final:l},l)break;r=i,t+=n.steps}}_rski(e){return this}subst(e,t){return this===e?t:null}invoke(e){return null}step(){return{expr:this,steps:0,changed:!1}}run(e={},...t){e instanceof s&&(t.unshift(e),e={});let r=t?this.apply(...t):this,n=e.steps??0,i=Math.max(e.max??U.max,1)+n,l=!1;for(;n<i;){let a=r.step();if(!a.changed){l=!0;break}n+=a.steps,r=a.expr}if(e.throw&&!l)throw new Error("Failed to compute expression in "+i+" steps");return{final:l,steps:n,expr:r}}*walk(e={}){let t=e.max??1/0,r=0,n=this,i=!1;for(;r<t;){let l=n.step();if(l.changed||(i=!0),yield{expr:n,steps:r,final:i},i)break;r+=l.steps,n=l.expr}}equals(e){return!this.diff(e)}diff(e,t=!1){return this===e?null:e instanceof q?e.impl.diff(this,!t):t?"["+e+" != "+this+"]":"["+this+" != "+e+"]"}expect(e,t=""){if(t=t?t+": ":"",!(e instanceof s))throw new Error(t+"attempt to expect a combinator to equal something else: "+e);let r=this.diff(e);if(!r)return;let n=new Error(t+r);throw n.expected=e+"",n.actual=this+"",n}toString(){return this.format()}_braced(e){return!1}_unspaced(e){return this._braced(!0)}format(e={}){let t=e.html?{brackets:["(",")"],space:" ",var:["<var>","</var>"],lambda:["","-&gt;",""],around:["",""],redex:["",""]}:{brackets:["(",")"],space:" ",var:["",""],lambda:["","->",""],around:["",""],redex:["",""]};return this._format({terse:e.terse??!0,brackets:e.brackets??t.brackets,space:e.space??t.space,var:e.var??t.var,lambda:e.lambda??t.lambda,around:e.around??t.around,redex:e.redex??t.redex,inventory:e.inventory,html:e.html??!1},0)}_format(e,t){throw new Error("No _format() method defined in class "+this.constructor.name)}toJSON(){return this.format()}},g=class s extends d{constructor(e,t){super(),this.arg=t,this.fun=e,this.final=!1,this.arity=this.fun.arity>0?this.fun.arity-1:0}weight(){return this.fun.weight()+this.arg.weight()}_infer(e,t=[],r=0){if(t.length>e.maxArgs||r>e.max)return{normal:!1,steps:r};let n=super._infer(e,t,r);if(n.normal)return n;r=n.steps;let[i,...l]=this.unroll();if(!(i instanceof w))return{normal:!1,steps:r};let a=!1,o=!1,c=[];for(let f of l){let p=f._infer({...e,maxArgs:e.maxArgs-t.length,max:e.max-r,index:t.length+e.index});if(r+=p.steps,!p.normal)return{normal:!1,steps:r};c.push(p.expr),a=a||p.discard,o=o||p.duplicate}return{normal:!0,steps:r,...ie(t,i.apply(...c),{discard:a,duplicate:o})}}expand(){return this.fun.expand().apply(this.arg.expand())}traverse(e){let t=e(this);if(t instanceof d)return t;let r=this.fun.traverse(e),n=this.arg.traverse(e);return!r&&!n?null:(r??this.fun).apply(n??this.arg)}any(e){return e(this)||this.fun.any(e)||this.arg.any(e)}_fold(e,t){let[r=e,n="descend"]=b(t(e,this));if(n==="prune")return r;if(n==="stop")return v.stop(r);let[i=r,l="descend"]=b(this.fun._fold(r,t));if(l==="stop")return v.stop(i);let[a=i,o="descend"]=b(this.arg._fold(i,t));return o==="stop"?v.stop(a):a}subst(e,t){let r=this.fun.subst(e,t),n=this.arg.subst(e,t);return r||n?(r??this.fun).apply(n??this.arg):null}step(){if(!this.final){let e=this.fun.invoke(this.arg);if(e instanceof d)return{expr:e,steps:1,changed:!0};typeof e=="function"&&(this.invoke=e);let t=this.fun.step();if(t.changed)return{expr:t.expr.apply(this.arg),steps:t.steps,changed:!0};let r=this.arg.step();if(r.changed)return{expr:this.fun.apply(r.expr),steps:r.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}invoke(e){let t=this.fun.invoke(this.arg);return t instanceof d?t.apply(e):typeof t=="function"?(this.invoke=t,t(e)):(this.invoke=r=>null,null)}unroll(){return[...this.fun.unroll(),this.arg]}_rski(e){return e.steps>=e.max?this:this.fun._rski(e).apply(this.arg._rski(e))}diff(e,t=!1){if(!(e instanceof s))return super.diff(e,t);let r=this.fun.diff(e.fun,t);if(r)return r+"(...)";let n=this.arg.diff(e.arg,t);return n?this.fun+"("+n+")":null}_braced(e){return!e}_format(e,t){let r=this.fun._format(e,t+1),n=this.arg._format(e,0),i=t?["",""]:e.around;return e.terse&&!this.arg._braced(!1)?i[0]+r+(this.fun._unspaced(this.arg)?"":e.space)+n+i[1]:i[0]+r+e.brackets[0]+n+e.brackets[1]+i[1]}_unspaced(e){return this.arg._braced(!1)?!0:this.arg._unspaced(e)}},_=class s extends d{constructor(e){if(super(),typeof e!="string"||e.length===0)throw new Error("Attempt to create a named term with improper name");this.name=e}_unspaced(e){return!!(e instanceof s&&(this.name.match(/^[A-Z+]$/)&&e.name.match(/^[a-z+]/i)||this.name.match(/^[a-z+]/i)&&e.name.match(/^[A-Z+]$/)))}_format(e,t){let r=e.html?this.fancyName??this.name:this.name;return this.arity>0&&this.arity<=t?e.redex[0]+r+e.redex[1]:r}},Ae=0,w=class s extends _{constructor(e,t){super(e),this.id=++Ae,this.scope=t===void 0?this:t}weight(){return 0}diff(e,t=!1){if(!(e instanceof s))return super.diff(e,t);if(this.name===e.name&&this.scope===e.scope)return null;let r=this.name+"["+this.id+"]",n=e.name+"["+e.id+"]";return t?"["+n+" != "+r+"]":"["+r+" != "+n+"]"}subst(e,t){return e instanceof s&&e.name===this.name&&e.scope===this.scope?t:null}_format(e,t){let r=e.html?this.fancyName??this.name:this.name;return e.var[0]+r+e.var[1]}},j=class extends _{constructor(e,t,r={}){super(e),this.invoke=t;let n=r.canonize??!0?this.infer():{normal:!1};this.arity=r.arity||n.arity||1,this.note=r.note??n.expr?.format({terse:!0,html:!0,lambda:[""," &mapsto; ",""]})}_rski(e){if(this===k.I||this===k.K||this===k.S||e.steps>=e.max)return this;let t=this.infer().expr;return t?(e.steps++,t._rski(e)):this}},k={};function A(s,e,t){k[s]=new j(s,e,t)}var E=class s extends d{constructor(e,t){if(Array.isArray(e)){if(e.length===0)throw new Error("empty argument list in lambda constructor");let[n,...i]=e,l=new Set([n.name]);for(;i.length>0;){let a=i.pop();if(l.has(a.name))throw new Error("Duplicate free var name "+a+" in lambda expression");l.add(a.name),t=new s(a,t)}e=n}super();let r=new w(e.name,this);this.arg=r,this.impl=t.subst(e,r)??t,this.arity=1}weight(){return this.impl.weight()+1}_infer(e,t=[],r=0){if(t.length>e.maxArgs)return{normal:!1,steps:r};let n=ae(t.length+e.index);return this.invoke(n)._infer(e,[...t,n],r+1)}invoke(e){return this.impl.subst(this.arg,e)??this.impl}traverse(e){let t=e(this);if(t instanceof d)return t;let r=this.impl.traverse(e);return r?new s(this.arg,r):null}any(e){return e(this)||this.impl.any(e)}_fold(e,t){let[r=e,n="descend"]=b(t(e,this));if(n==="prune")return r;if(n==="stop")return v.stop(r);let[i,l]=b(this.impl._fold(r,t));return l==="stop"?v.stop(i):i??r}subst(e,t){if(e===this.arg)return null;let r=this.impl.subst(e,t);return r?new s(this.arg,r):null}expand(){return new s(this.arg,this.impl.expand())}_rski(e){let t=this.impl._rski(e);if(e.steps>=e.max)return new s(this.arg,t);if(e.steps++,t===this.arg)return k.I;if(!t.any(r=>r===this.arg))return k.K.apply(t);if(t instanceof g){let{fun:r,arg:n}=t;return n===this.arg&&!r.any(i=>i===this.arg)?r._rski(e):k.S.apply(new s(this.arg,r)._rski(e),new s(this.arg,n)._rski(e))}throw new Error("Don't know how to convert to SKI"+this)}diff(e,t=!1){if(!(e instanceof s))return super.diff(e,t);let r=new w("t"),n=this.invoke(r).diff(e.invoke(r),t);return n?"(t->"+n+")":null}_format(e,t){return(t>0?e.brackets[0]:"")+e.lambda[0]+this.arg._format(e,0)+e.lambda[1]+this.impl._format(e,0)+e.lambda[2]+(t>0?e.brackets[1]:"")}_braced(e){return!0}},L=class s extends j{constructor(e){let t=Number.parseInt(e);if(!(t>=0))throw new Error("Church number must be a non-negative integer");let r=""+t,n=i=>l=>{let a=l;for(let o=t;o-- >0;)a=i.apply(a);return a};super(r,n,{arity:2,canonize:!1,note:r}),this.n=t,this.arity=2}diff(e,t=!1){return e instanceof s?this.n===e.n?null:t?"["+e.n+" != "+this.n+"]":"["+this.n+" != "+e.n+"]":super.diff(e,t)}_unspaced(e){return!1}};function se(s,e){return t=>e<=1?s.apply(t):se(s.apply(t),e-1)}var q=class extends _{constructor(e,t,r={}){if(super(e),!(t instanceof d))throw new Error("Attempt to create an alias for a non-expression: "+t);this.impl=t,r.note&&(this.note=r.note);let n=r.canonize?t.infer({max:r.max,maxArgs:r.maxArgs}):{normal:!1};this.arity=n.proper&&n.arity||0,this.proper=n.proper??!1,this.terminal=r.terminal??this.proper,this.canonical=n.expr,this.invoke=se(t,this.arity)}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}traverse(e){return e(this)??this.impl.traverse(e)}any(e){return e(this)||this.impl.any(e)}_fold(e,t){let[r=e,n="descend"]=b(t(e,this));if(n==="prune")return r;if(n==="stop")return v.stop(r);let[i,l]=b(this.impl._fold(r,t));return l==="stop"?v.stop(i):i??r}subst(e,t){return this===e?t:this.impl.subst(e,t)}_infer(e,t=[],r=0){return this.impl._infer(e,t,r)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}diff(e,t=!1){return this===e?null:e.diff(this.impl,!t)}_rski(e){return this.impl._rski(e)}_braced(e){return this.outdated?this.impl._braced(e):!1}_format(e,t){return(e.inventory?e.inventory[this.name]!==this:this.outdated)?this.impl._format(e,t):super._format(e,t)}};A("I",s=>s);A("K",s=>e=>s);A("S",s=>e=>t=>s.apply(t,e.apply(t)));A("B",s=>e=>t=>s.apply(e.apply(t)));A("C",s=>e=>t=>s.apply(t).apply(e));A("W",s=>e=>s.apply(e).apply(e));A("+",s=>s instanceof L?new L(s.n+1):e=>t=>e.apply(s.apply(e,t)),{note:"Increase a Church numeral argument by 1, otherwise n => f => x => f(n f x)"});function ie(s,e,t={}){let r=new Array(s.length).fill(0),n=!0;e.traverse(a=>{if(a instanceof w){let o=s.findIndex(c=>c.name===a.name);if(o>=0){r[o]++;return}}a instanceof g||(n=!1)});let i=new Set,l=new Set;for(let a=0;a<s.length;a++)r[a]===0?i.add(a):r[a]>1&&l.add(a);return{expr:s.length?new E(s,e):e,...t.synth?{}:{arity:s.length},...i.size?{skip:i}:{},...l.size?{dup:l}:{},duplicate:!!l.size||t.duplicate||!1,discard:!!i.size||t.discard||!1,proper:n}}function ae(s){return new w("abcdefgh"[s]??"x"+s)}function*V(s,e={},t={steps:0}){if(yield{expr:s,steps:t.steps,comment:"(self)"},s.freeOnly())return;let r=s.weight();if(s instanceof E)for(let i of V(s.impl,e,t)){let l=new E(s.arg,i.expr);l.weight()<r&&(r=l.weight(),yield{expr:l,steps:t.steps,comment:"(lambda)"+i.comment})}if(s instanceof g){let{fun:i,arg:l}=s;for(let a of V(i,e,t)){let o=a.expr.apply(l);o.weight()<r&&(r=o.weight(),i=a.expr,yield{expr:o,steps:t.steps,comment:"(fun)"+a.comment})}for(let a of V(l,e,t)){let o=i.apply(a.expr);o.weight()<r&&(r=o.weight(),yield{expr:o,steps:t.steps,comment:"(arg)"+a.comment})}}let n=s.infer({max:e.max,maxArgs:e.maxArgs});t.steps+=n.steps,n.expr&&n.expr.weight()<r&&(yield{expr:n.expr,steps:t.steps,comment:"(canonical)"})}function Se(s,e){if(s)e||(e=Object.keys(s).sort().map(i=>s[i]));else{if(!e)return[];if(!s){s={};for(let i of e)if(i instanceof _){if(s[i.name])throw new Error("duplicate name "+i);s[i.name]=i}}}let t=[],r=new Set,n=i=>{r.has(i)||(i.fold(null,(l,a)=>{if(a!==i&&a instanceof _&&s[a.name]===a)return n(a),d.control.prune(null)}),t.push(i),r.add(i))};for(let i of e)n(i);return{list:t,env:s}}d.native=k;d.control=v;d.extras={toposort:Se};oe.exports={Expr:d,App:g,Named:_,FreeVar:w,Lambda:E,Native:j,Alias:q,Church:L}});var B=S((Me,fe)=>{"use strict";var{Tokenizer:ze,restrict:J}=D(),ce=W(),{Expr:O,Named:De,Native:Ie,Alias:x,FreeVar:N,Lambda:Fe,Church:ue}=ce,{native:P}=O,z=class extends O{apply(...e){return e.length?e.shift().apply(...e):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}},Q=class s extends z{constructor(e,t={}){if(super(),this.impl=new z,e instanceof N)this.terms=[e];else if(e instanceof s){if(!(e.impl instanceof N))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...e.terms,e.impl]}else throw new Error("Expected FreeVar or PartialLambda")}apply(e,...t){if(e===null||t.length!==0)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(e),this}postParse(){return new Fe(this.terms,this.impl)}};function le(s){return s.postParse?s.postParse():s}var je=new ze("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+"),y=class s{constructor(e={}){if(this.annotate=e.annotate??!1,this.known={...P},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known)),Array.isArray(e.terms))this.bulkAdd(e.terms);else if(e.terms)for(let t in e.terms)e.terms[t].match(/^Native:/)||this.add(t,e.terms[t]);this.hasNumbers=e.numbers??!0,this.hasLambdas=e.lambdas??!0,e.allow&&this.restrict(e.allow)}add(e,t,r){if(e=this._named(e,t),this.annotate&&r===void 0){let n=e.infer();n.expr&&(r=n.expr.format({terse:!0,html:!0,lambda:[""," &mapsto; ",""]}))}return r!==void 0&&(e.note=r),this.known[e.name]&&(this.known[e.name].outdated=!0),this.known[e.name]=e,this.allow.add(e.name),this}_named(e,t){if(e instanceof x)return new x(e.name,e.impl,{canonize:!0});if(typeof e!="string")throw new Error("add(): term must be an Alias or a string");if(t===void 0)throw new Error("add(): impl must be provided when term is a string");if(typeof t=="string")return new x(e,this.parse(t),{canonize:!0});if(t instanceof O)return new x(e,t,{canonize:!0});if(typeof t=="function")return new Ie(e,t);throw new Error("add(): impl must be an Expr, a string, or a function with a signature Expr => ... => Expr")}maybeAdd(e,t){return this.known[e]?this.allow.add(e):this.add(e,t),this}bulkAdd(e){for(let t of e){let r=t.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);if(!r)throw new Error("bulkAdd: invalid declaration: "+t);r[2]===""?this.remove(r[1]):this.add(r[1],this.parse(r[2]))}return this}restrict(e){return this.allow=J(this.allow,e),this}showRestrict(e="+"){let t=[],r=!0;for(let n of[...J(this.allow,e)].sort()){let i=n.match(/^[A-Z]$/);t.length&&!(r&&i)&&t.push(" "),t.push(n),r=i}return t.join("")}remove(e){return this.known[e].outdated=!0,delete this.known[e],this.allow.delete(e),this}getTerms(){let e={};for(let t of Object.keys(this.known))this.allow.has(t)&&(e[t]=this.known[t]);return e}declare(){let e=this.getTerms();for(let a in e)e[a]instanceof x||delete e[a];let t={},r=1;for(let a in P){if(!(e[a]instanceof x))continue;for(;"tmp"+r in e;)r++;let o=new x("tmp"+r,e[a]);t[o]=e[a],e[o]=o,delete e[a]}let n=O.extras.toposort(e).list,i=new Map;if(Object.keys(t).length){let a=o=>o.traverse(c=>{if(!(c instanceof x))return null;let f=i.get(c);return f||new x(c.name,a(c.impl))})??o;for(let o=0;o<n.length;o++)n[o]=a(n[o],i),i.set(t[n[o].name],n[o]),e[n[o].name]=n[o],console.log(`list[${o}] = ${n[o].name}=${n[o].impl};`);console.log("detour:",i)}let l=n.map(a=>t[a]?a.name+"="+t[a].name+"="+a.impl.format({inventory:e}):a.name+"="+a.impl.format({inventory:e}));for(let[a,o]of i)l.push(a+"="+o,o+"=");return l}parse(e,t={}){if(typeof e!="string")throw new Error("parse: source must be a string, got "+typeof e);let r=e.replace(/\/\/[^\n]*$/gm," ").replace(/\/\*.*?\*\//gs," ").trim().split(/\s*;[\s;]*/).filter(l=>l.match(/\S/)),n={...t.env},i=new z;for(let l of r){i instanceof x&&(i.outdated=!0);let a=l.match(/^([A-Z]|[a-z][a-z_0-9]*)\s*=(.*)$/s);if(a&&a[2]===""?i=new N(a[1],t.scope??s):i=this.parseLine(l,n,t),a){if(n[a[1]]!==void 0)throw new Error("Attempt to redefine a known term: "+a[1]);n[a[1]]=i}}return i.context={env:{...this.getTerms(),...n},scope:t.scope,src:e,parser:this},i}parseLine(e,t={},r={}){let n=e.match(/^\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*(.*)$/s);if(n)return new x(n[1],this.parseLine(n[2],t,r));let i={numbers:r.numbers??this.hasNumbers,lambdas:r.lambdas??this.hasLambdas,allow:J(this.allow,r.allow)};i.numbers?i.allow.add("+"):i.allow.delete("+");let l=je.split(e),a=new z,o=[a],c=r.scope||s;for(let f of l)if(f==="(")o.push(a);else if(f===")"){if(o.length<2)throw new Error("unbalanced input: extra closing parenthesis"+e);let p=le(o.pop()),h=o.pop();o.push(h.apply(p))}else if(f==="->"){if(!i.lambdas)throw new Error("Lambdas not supported, allow them explicitly");o.push(new Q(o.pop(),t))}else if(f.match(/^[0-9]+$/)){if(!i.numbers)throw new Error("Church numbers not supported, allow them explicitly");let p=o.pop();o.push(p.apply(new ue(f)))}else{let p=o.pop();if(!t[f]&&this.known[f]&&!i.allow.has(f))throw new Error("Term '"+f+"' is not in the restricted set "+[...i.allow].sort().join(" "));let h=t[f]??this.known[f]??(t[f]=new N(f,c));o.push(p.apply(h))}if(o.length!==1)throw new Error("unbalanced input: missing "+(o.length-1)+" closing parenthesis:"+e);return le(o.pop())}toJSON(){return{version:"1.1.1",allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,annotate:this.annotate,terms:this.declare()}}};y.vars=function(s={}){let e={};return new Proxy({},{get:(t,r)=>(r in e||(e[r]=new N(r,s)),e[r])})};y.church=s=>new ue(s);for(let s in P)y[s]=P[s];y.classes=ce;y.native=P;y.control=O.control;fe.exports={SKI:y}});var de=S((Je,pe)=>{var{SKI:I}=B(),{Expr:Ue,FreeVar:Le,Alias:he,Lambda:We}=I.classes,G=class{constructor(e={}){let{input:t,cases:r,allow:n,numbers:i,lambdas:l,engine:a,engineFull:o,...c}=e,f=e.env??e.vars;this.engine=a??new I,this.engineFull=o??new I,this.restrict={allow:n,numbers:i??!1,lambdas:l??!1},this.env={};let p={};for(let h of f??[]){let u=this.engineFull.parse(h,{env:p,scope:this});if(u instanceof I.classes.Alias)this.env[u.name]=new he(u.name,u.impl,{terminal:!0,canonize:!1});else if(u instanceof I.classes.FreeVar)this.env[u.name]=u;else throw new Error("Unsupported given variable type: "+h)}this.input=[];for(let h of Array.isArray(t)?t:[t])this.addInput(h);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");this.envFull={...this.env,...p};for(let h of this.input){if(h.name in this.envFull)throw new Error("input placeholder name is duplicated or clashes with env: "+h.name);this.envFull[h.name]=h.placeholder}this.cases=[],this.name=c.name??c.title,c.intro=Oe(c.intro??c.descr),this.intro=c.intro,this.id=c.id,this.meta=c;for(let h of r??[])this.add(...h)}allowed(){let e=this.restrict.allow??"",t=Object.keys(this.env).sort();return e?this.engine.showRestrict(e+"+"+t.join(" ")):t.map(r=>"+"+r).join(" ")}addInput(e){if(typeof e!="object"&&(e={name:e}),typeof e.name!="string")throw new Error("quest 'input' field must be a string or a {name: string, ...} object");e.placeholder=new I.classes.FreeVar(e.name),this.input.push(e)}add(e,...t){typeof e=="string"?(t.unshift(e),e={}):e={...e},e.engine=e.engine??this.engineFull,e.env=e.env??this.envFull;let r=this.input.map(n=>n.placeholder);return this.cases.push(e.caps?new X(r,e,t):new H(r,e,t)),this}prepare(...e){if(e.length!==this.input.length)throw new Error("Solutions provided "+e.length+" terms where "+this.input.length+" are expected");let t=0,r=[],n={...this.env};for(let i=0;i<e.length;i++){let l=this.input[i],a=this.engine.parse(e[i],{env:n,allow:l.allow??this.restrict.allow,numbers:l.numbers??this.restrict.numbers,lambdas:l.lambdas??this.restrict.lambdas});t+=a.weight();let o=a instanceof Le?a:new he(l.fancy??l.name,a,{terminal:!0,canonize:!1});n[l.name]=o,r.push(o)}return{prepared:r,weight:t}}check(...e){try{let{prepared:t,weight:r}=this.prepare(...e),n=this.cases.map(a=>a.check(...t)),i=n.reduce((a,o)=>a&&o.pass,!0),l=n.reduce((a,o)=>a+o.steps,0);return{expr:t[0],input:t,pass:i,steps:l,details:n,weight:r}}catch(t){return{pass:!1,details:[],exception:t,steps:0,input:e}}}show(){return[...this.cases]}},Z=class{constructor(e,t){this.max=t.max??1e3,this.note=t.note,this.env={...t.env??{}},this.input=e,this.engine=t.engine}parse(e){return new Y(this.engine.parse(e,{env:this.env,scope:this}),this.input)}check(...e){throw new Error("not implemented")}},H=class extends Z{constructor(e,t,r){if(r.length!==2)throw new Error("Case accepts exactly 2 strings");super(e,t),[this.e1,this.e2]=r.map(n=>this.parse(n))}check(...e){let t=this.e1.apply(e),r=t.run({max:this.max}),i=this.e2.apply(e).run({max:this.max}),l=null;return!r.final||!i.final?l="failed to reach normal form in "+this.max+" steps":l=r.expr.diff(i.expr),{pass:!l,reason:l,steps:r.steps,start:t,found:r.expr,expected:i.expr,note:this.note,args:e,case:this}}},qe={normal:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0},X=class extends Z{constructor(e,t,r){if(super(e,t),r.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!t.caps||typeof t.caps!="object"||!Object.keys(t.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");let n=Object.keys(t.caps).filter(i=>!qe[i]);if(n.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+n.join(", "));this.expr=this.parse(r[0]),this.caps=t.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.normal=!0),this.caps.affine&&(delete this.caps.affine,this.caps.normal=!0,this.caps.duplicate=!1)}check(...e){let t=this.expr.apply(e),r=t.run({max:this.max}),n=r.expr.infer({max:this.max}),i=[];for(let l in this.caps)n[l]!==this.caps[l]&&i.push("expected property "+l+" to be "+this.caps[l]+", found "+n[l]);return{pass:!i.length,reason:i?i.join(`
`):null,steps:r.steps,start:t,found:r.expr,case:this,note:this.note,args:e}}},Y=class{constructor(e,t){this.expr=e,this.env=t}apply(e){if(e.length!==this.env.length)throw new Error("Subst: expected "+this.env.length+" terms, got "+e.length);let t=this.expr;for(let r=0;r<this.env.length;r++)t=t.subst(this.env[r],e[r])??t;return t}};function Oe(s){return s===void 0||typeof s=="string"?s:Array.isArray(s)?s.join(" "):""+s}pe.exports={Quest:G}});var xe=S((Qe,we)=>{"use strict";var{Expr:me,Alias:Ne,FreeVar:Pe}=W();function $e(s,e,t){let{depth:r=16,infer:n=!0,progressInterval:i=1e3}=e,l=n&&!e.noskip,a=[[]],o=0,c=0,f={},p=u=>{o++;let m=n?u.infer({max:e.max,maxArgs:e.maxArgs}):null;if(l&&m.expr){if(f[m.expr])return{res:-1};f[m.expr]=!0}return c++,{res:t(u,m),props:m}};for(let u of s){let{res:m}=p(u);if(m>0)return{expr:u,total:o,probed:c,gen:1};if(m<0)continue;a[0].push(u)}let h;for(let u=1;u<r;u++){e.progress&&(e.progress({gen:u,total:o,probed:c,step:!0}),h=o);for(let m=0;m<u;m++)for(let te of a[u-m-1]||[])for(let be of a[m]||[]){if(o>=e.tries)return{total:o,probed:c,gen:u,...e.retain?{cache:a}:{}};e.progress&&o-h>=i&&(e.progress({gen:u,total:o,probed:c,step:!1}),h=o);let C=te.apply(be),{res:re,props:R}=p(C);if(re>0)return{expr:C,total:o,probed:c,gen:u,...e.retain?{cache:a}:{}};if(re<0)continue;let T=n?(R.expr?0:3)+(R.dup?1:0)+(R.proper?0:1):0;a[u+T]||(a[u+T]=[]),a[u+T].push(C)}}return{total:o,probed:c,gen:r,...e.retain?{cache:a}:{}}}function ee(s,e={}){if(s instanceof me)return s.format(e);if(Array.isArray(s))return s.map(ee);if(typeof s!="object"||s===null||s.constructor!==Object)return s;let t={};for(let r in s)t[r]=ee(s[r]);return t}function Ke(s,e){let t=me.extras.toposort(e,[s]);return t.list.map(r=>r instanceof Ne?r.name+"="+r.impl.format({inventory:t.env}):r instanceof Pe?r.name+"=":r.format({inventory:t.env})).join("; ")}we.exports={search:$e,deepFormat:ee,declare:Ke}});var Ze=S((Be,ye)=>{var{SKI:F}=B(),{Quest:ge}=de(),Ve=xe();F.Quest=ge;F.extras={...Ve,...F.classes.Expr.extras};typeof process=="object"&&process.env.SKI_REPL&&typeof global<"u"&&(global.SKI=F,console.log("SKI_REPL activated, try `new SKI();`"));typeof window<"u"&&(window.SKI=F);ye.exports={SKI:F,Quest:ge}});Ze();})();
//# sourceMappingURL=ski-interpreter.min.js.map
