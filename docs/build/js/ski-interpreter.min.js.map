{
  "version": 3,
  "sources": ["../../../lib/util.js", "../../../lib/expr.js", "../../../lib/parser.js", "../../../lib/quest.js", "../../../index.js"],
  "sourcesContent": ["class Tokenizer {\n  constructor (...terms) {\n    const src = '$|(\\\\s+)|' + terms\n      .map(s => '(?:' + s + ')')\n      .sort((a, b) => b.length - a.length)\n      .join('|');\n    this.rex = new RegExp(src, 'gys');\n  }\n\n  /**\n     *\n     * @param {string} str\n     * @return {string[]}\n     */\n  split (str) {\n    this.rex.lastIndex = 0;\n    const list = [...str.matchAll(this.rex)];\n\n    // did we parse everything?\n    const eol = list.pop();\n    const last = eol?.index ?? 0;\n\n    if (last !== str.length) {\n      throw new Error('Unknown tokens at pos ' + last + '/' + str.length\n                + ' starting with ' + str.substring(last));\n    }\n\n    // skip whitespace\n    return list.filter(x => x[1] === undefined).map(x => x[0]);\n  }\n}\n\nconst tokRestrict = new Tokenizer('[-=+]', '[A-Z]', '\\\\b[a-z_][a-z_0-9]*\\\\b');\nfunction restrict (set, spec) {\n  if (!spec)\n    return set;\n  let out = new Set([...set]);\n  let mode = 0;\n  const act = [\n    sym => { out = new Set([sym]); mode = 1; },\n    sym => { out.add(sym); },\n    sym => { out.delete(sym); },\n  ];\n  for (const sym of tokRestrict.split(spec)) {\n    if (sym === '=')\n      mode = 0;\n    else if (sym === '+')\n      mode = +1;\n    else if (sym === '-')\n      mode = 2;\n    else\n      act[mode](sym);\n  }\n  return out;\n}\n\nfunction skipDup (arr, map) {\n  const skip = new Set();\n  const dup = new Set();\n  for (let n = 0; n < arr.length; n++) {\n    const count = map.get(arr[n]) ?? 0;\n    if (!count)\n      skip.add(n);\n    else if (count > 1)\n      dup.add(n);\n  }\n  return [skip, dup];\n}\n\nfunction isSubset (a, b) {\n  for (const x of a) {\n    if (!b.has(x))\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = { Tokenizer, restrict, skipDup, isSubset };\n", "'use strict';\n\nconst { skipDup, isSubset } = require('./util');\n\nconst globalOptions = {\n  terse:   true,\n  max:     1000,\n  maxArgs: 32,\n};\n\nclass Expr {\n  /**\n   *  @descr A generic combinatory logic expression.\n   */\n  constructor () {\n    if (new.target === Expr)\n      throw new Error('Attempt to instantiate abstract class Expr');\n  }\n\n  /**\n     * postprocess term after parsing. typically return self but may return other term or die\n     * @return {Expr}\n     */\n  postParse () {\n    return this;\n  }\n\n  /**\n     * @desc apply self to zero or more terms and return the resulting term,\n     * without performing any calculations whatsoever\n     * @param {Expr} args\n     * @return {Expr}\n     */\n  apply (...args) {\n    return args.length > 0 ? new App(this, ...args) : this;\n  }\n\n  /**\n     * expand all terms but don't perform any calculations\n     * @return {Expr}\n     */\n  expand () {\n    return this;\n  }\n\n  /**\n   * @desc return all free variables within the term\n   * @return {Set<FreeVar>}\n   */\n  freeVars () {\n    const symbols = this.getSymbols();\n    const out = new Set();\n    for (const [key, _] of symbols) {\n      if (key instanceof FreeVar)\n        out.add(key);\n    }\n    return out;\n  }\n\n  hasLambda () {\n    const sym = this.getSymbols();\n    return sym.has(Expr.lambdaPlaceholder);\n  }\n\n  freeOnly () {\n    for (const [key, _] of this.getSymbols()) {\n      if (!(key instanceof FreeVar))\n        return false;\n    }\n    return true;\n  }\n\n  /**\n   * @desc return all terminal values within the term, that is, values not\n   * composed of other terms. For example, in S(KI)K, the terminals are S, K, I.\n   * @return {Map<Expr, number>}\n   */\n  getSymbols () {\n    // TODO better name!\n    return new Map([[this, 1]]);\n  }\n\n  /**\n   *   @desc Given a list of pairs of term, replaces every subtree\n   *         that is equivalent to the first term in pair with the second one.\n   *         If a simgle term is given, it is duplicated into a pair.\n   *\n   *   @example  S(SKK)(SKS).replace('I') = SII // we found 2 subtrees equivalent to I\n   *             and replaced them with I\n   *\n   *   @param {(Expr | [find: Expr, replace: Expr])[]} terms\n   *   @param {Object} [opt] - options\n   *   @return {Expr}\n   */\n  replace (terms, opt = {}) {\n    const pairs = [];\n    if (terms.length === 0)\n      return this; // nothing to replace, return self\n    for (const entry of terms) {\n      const pair = (Array.isArray(entry) ? entry : [entry, entry]);\n      pair[0] = pair[0].guess(opt).expr;\n      if (!pair[0])\n        throw new Error('Failed to canonize term ' + entry);\n      if (pair.length !== 2)\n        throw new Error('Expected a pair of terms to replace, got ' + entry);\n      pairs.push(pair);\n    }\n    return this._replace(pairs, opt) ?? this;\n  }\n\n  _replace (pairs, opt) {\n    const check = this.guess(opt).expr;\n    for (const [canon, term] of pairs) {\n      if (check.equals(canon))\n        return term;\n    }\n    return null;\n  }\n\n  /**\n   * @desc rought estimate of the complexity of the term\n   * @return {number}\n   */\n  weight () {\n    return 1;\n  }\n\n  /**\n   * @desc Try to find an equivalent lambda term for the expression,\n   *       returning also the term's arity and some other properties.\n   *\n   *       This is used internally when declaring a Native term,\n   *       unless {canonize: false} is used.\n   *\n   *       As of current it only recognizes terms that have a normal form,\n   *       perhaps after adding some variables. This may change in the future.\n   *\n   *       Use lambdify() if you want to get a lambda term in any case.\n   *\n   * @param {{max: number?, maxArgs: number?}} options\n   * @return {{\n   *    normal: boolean,\n   *    steps: number,\n   *    expr: Expr?,\n   *    arity: number?,\n   *    proper: boolean?,\n   *    discard: boolean?,\n   *    duplicate: boolean?,\n   *    skip: Set<number>?,\n   *    dup: Set<number>?\n   * }}\n   */\n  guess (options = {}) {\n    const max = options.max ?? globalOptions.max;\n    const maxArgs = options.maxArgs ?? globalOptions.maxArgs;\n    const out = this._guess({ max, maxArgs, index: 0 });\n    return out;\n  }\n\n  _guess (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs || steps > options.max)\n      return { normal: false, steps };\n\n    // happy case\n    if (this.freeOnly()) {\n      return {\n        normal: true,\n        steps,\n        ...maybeLambda(preArgs, this),\n      };\n    }\n\n    // try reaching the normal form\n    const next = this.run({ max: (options.max - steps) / 3 });\n    steps += next.steps;\n    if (!next.final)\n      return { normal: false, steps };\n\n    // normal form != this, redo exercise\n    if (next.steps !== 0)\n      return next.expr._guess(options, preArgs, steps);\n\n    if (this._firstVar())\n      return { normal: false, steps };\n\n    const push = nthvar(preArgs.length + options.index);\n    return this.apply(push)._guess(options, [...preArgs, push], steps);\n  }\n\n  _aslist () {\n    return [this];\n  }\n\n  _firstVar () {\n    // boolean, whether the expression starts with a free variable\n    // used by guess()\n    return false;\n  }\n\n  /**\n   * @desc Returns a series of lambda terms equivalent to the given expression,\n   *       up to the provided computation steps limit,\n   *       in decreasing weight order.\n   * @param {{\n   *   max: number?,\n   *   maxArgs: number?,\n   *   varGen: function(void): FreeVar?,\n   *   steps: number?,\n   *   html: boolean?,\n   *   latin: number?,\n   * }} options\n   * @param {number} [maxWeight] - maximum allowed weight of terms in the sequence\n   * @return {IterableIterator<{expr: Expr, steps: number?, comment: string?}>}\n   */\n  * lambdify (options = {}) {\n    const expr = naiveCanonize(this, options);\n    yield * simplifyLambda(expr, options);\n  }\n\n  /**\n   * @desc same semantics as walk() but rewrite step by step instead of computing\n   * @param {{max: number?}} options\n   * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}\n   */\n  * rewriteSKI (options = {}) {\n    // TODO options.max is not actually max, it's the number of steps in one iteration\n    let steps = 0;\n    let expr = this;\n    while (true) {\n      const opt = { max: options.max ?? 1, steps: 0 };\n      const next = expr._rski(opt);\n      const final = opt.steps === 0;\n      yield { expr, steps, final };\n      if (final)\n        break;\n      expr = next;\n      steps += opt.steps;\n    }\n  }\n\n  /**\n   * @desc Rename free variables in the expression using the given sequence\n   *       This is for eye-candy only, as the interpreter knows darn well hot to distinguish vars,\n   *       regardless of names.\n   * @param {IterableIterator<string>} seq\n   * @return {Expr}\n   */\n  renameVars (seq) {\n    return this;\n  }\n\n  _rski (options) {\n    return this;\n  }\n\n  /**\n     * Apply self to list of given args.\n     * Normally, only native combinators know how to do it.\n     * @param {Expr[]} args\n     * @return {Expr|null}\n     */\n  reduce (args) {\n    return null;\n  }\n\n  /**\n     * Replace all instances of free vars with corresponding values and return the resulting expression.\n     * return null if no changes could be made.\n     * @param {FreeVar} plug\n     * @param {Expr} value\n     * @return {Expr|null}\n     */\n  subst (plug, value) {\n    return null;\n  }\n\n  /**\n     * @desc iterate one step of calculation in accordance with known rules.\n     * @return {{expr: Expr, steps: number, changed: boolean}}\n     */\n  step () { return { expr: this, steps: 0, changed: false } }\n\n  /**\n     * @desc Run uninterrupted sequence of step() applications\n     *       until the expression is irreducible, or max number of steps is reached.\n     *       Default number of steps = 1000.\n     * @param {{max: number?, steps: number?, throw: boolean?}|Expr} [opt]\n     * @param {Expr} args\n     * @return {{expr: Expr, steps: number, final: boolean}}\n     */\n  run (opt = {}, ...args) {\n    if (opt instanceof Expr) {\n      args.unshift(opt);\n      opt = {};\n    }\n    let expr = args ? this.apply(...args) : this;\n    let steps = opt.steps ?? 0;\n    // make sure we make at least 1 step, to tell whether we've reached the normal form\n    const max = Math.max(opt.max ?? globalOptions.max, 1) + steps;\n    let final = false;\n    for (; steps < max; ) {\n      const next = expr.step();\n      if (!next.changed) {\n        final = true;\n        break;\n      }\n      steps += next.steps;\n      expr = next.expr;\n    }\n    if (opt.throw && !final)\n      throw new Error('Failed to compute expression in ' + max + ' steps');\n    return { final, steps, expr };\n  }\n\n  /**\n     * Execute step() while possible, yielding a brief description of events after each step.\n     * Mnemonics: like run() but slower.\n     * @param {{max: number?}} options\n     * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}\n     */\n  * walk (options = {}) {\n    const max = options.max ?? Infinity;\n    let steps = 0;\n    let expr = this;\n    let final = false;\n\n    while (steps < max) {\n      // 1. calculate\n      // 2. yield _unchanged_ expression\n      // 3. either advance or stop\n      const next = expr.step();\n      if (!next.changed)\n        final = true;\n      yield { expr, steps, final };\n      if (final)\n        break;\n      steps += next.steps;\n      expr = next.expr;\n    }\n  }\n\n  /**\n   *\n   * @param {Expr} other\n   * @return {boolean}\n   */\n  equals (other) {\n    if (this === other)\n      return true;\n    if (other instanceof Alias)\n      return other.equals(this);\n    return false;\n  }\n\n  contains (other) {\n    return this === other || this.equals(other);\n  }\n\n  /**\n   * @desc Assert expression equality. Can be used in tests.\n   * @param {Expr} expected\n   * @param {string} comment\n   */\n  expect (expected, comment = '') {\n    comment = comment ? comment + ': ' : '';\n    if (!(expected instanceof Expr))\n      throw new Error(comment + 'attempt to expect a combinator to equal something else: ' + expected);\n    if (this.equals(expected))\n      return;\n\n    // TODO wanna use AssertionError but webpack doesn't recognize it\n    // still the below hack works for mocha-based tests.\n    const poorMans = new Error(comment + 'found term ' + this + ' but expected ' + expected);\n    poorMans.expected = expected.toString();\n    poorMans.actual = this.toString();\n    throw poorMans;\n  }\n\n  /**\n   * @param {{terse: boolean?, html: boolean?}} [options]\n   * @return {string} string representation of the expression\n   */\n  toString (options = {}) {\n    // uncomment the following line if you want to debug the parser with prints\n    // return this.constructor.name\n    throw new Error( 'No toString() method defined in class ' + this.constructor.name );\n  }\n\n  /**\n   * @desc Whether the expression needs parentheses when printed.\n   * @param {boolean} [first] - whether this is the first term in a sequence\n   * @return {boolean}\n   */\n  needsParens (first) {\n    return false;\n  }\n\n  _spaced (arg) {\n    return false;\n  }\n\n  /**\n   * @desc    Stringify the expression with fancy formatting options.\n   * @param   {{\n   *    html: boolean?,\n   *    brackets: [string, string]?,\n   *    var:    [string, string]?,\n   * }} options\n   * @returns {string}\n   */\n\n  format (options = {}) {\n    const defaults = options.html\n      ? {\n        brackets: ['(', ')'],\n        space:    ' ',\n        var:      ['<var>', '</var>'],\n        lambda:   ['', '-&gt;', ''],\n        app:      ['', ''],\n        redex:    ['<b>', '</b>'],\n      }\n      : {\n        brackets: ['(', ')'],\n        space:    ' ',\n        var:      ['', ''],\n        lambda:   ['', '->', ''],\n        app:      ['', ''],\n        redex:    ['', ''],\n      }\n    return this._format({\n      terse:    options.terse ?? globalOptions.terse,\n      brackets: options.brackets ?? defaults.brackets,\n      space:    options.space    ?? defaults.space,\n      var:      options.var      ?? defaults.var,\n      lambda:   options.lambda   ?? defaults.lambda,\n      app:      options.app      ?? defaults.app,\n      redex:    options.redex    ?? defaults.redex,\n    }, 0);\n  }\n\n  _format (options, nargs) {\n    throw new Error( 'No _format() method defined in class ' + this.constructor.name );\n  }\n\n  /**\n   *\n   * @return {string}\n   */\n  toJSON () {\n    return this.expand().toString({ terse: false });\n  }\n}\n\nclass App extends Expr {\n  /**\n   * @desc Application of fun() to args.\n   * Never ever use new App(fun, ...args) directly, use fun.apply(...args) instead.\n   * @param {Expr} fun\n   * @param {Expr} args\n   */\n  constructor (fun, ...args) {\n    if (args.length === 0)\n      throw new Error('Attempt to create an application with no arguments (likely interpreter bug)');\n    super();\n\n    this.arg = args.pop();\n    this.fun = args.length ? new App(fun, ...args) : fun;\n    this.final = false;\n    this.arity = this.fun.arity > 0 ? this.fun.arity - 1 : 0;\n  }\n\n  weight () {\n    return this.fun.weight() + this.arg.weight();\n  }\n\n  getSymbols () {\n    const out = this.fun.getSymbols();\n    for (const [key, value] of this.arg.getSymbols())\n      out.set(key, (out.get(key) ?? 0) + value);\n    return out;\n  }\n\n  _guess (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs || steps > options.max)\n      return { normal: false, steps };\n\n    /*\n     * inside and App there are 3 main possibilities:\n     * 1) The parent guess() actually is able to do the job. Then we just proxy the result.\n     * 2) Both `fun` and `arg` form good enough lambda terms. Then lump them together & return.\n     * 3) We literally have no idea, so we just pick the shortest defined term from the above.\n     */\n\n    const proxy = super._guess(options, preArgs, steps);\n    if (proxy.normal)\n      return proxy;\n    steps = proxy.steps; // reimport extra iterations\n\n    const [first, ...list] = this._aslist();\n    if (!(first instanceof FreeVar))\n      return { normal: false, steps }\n    // TODO maybe do it later\n\n    let discard = false;\n    let duplicate = false;\n    const out = [];\n    for (const term of list) {\n      const guess = term._guess({\n        ...options,\n        maxArgs: options.maxArgs - preArgs.length,\n        max:     options.max - steps,\n        index:   preArgs.length + options.index,\n      });\n      steps += guess.steps;\n      if (!guess.normal)\n        return { normal: false, steps };\n      out.push(guess.expr);\n      discard = discard || guess.discard;\n      duplicate = duplicate || guess.duplicate;\n    }\n\n    return {\n      normal: true,\n      steps,\n      ...maybeLambda(preArgs, new App(first, ...out), {\n        discard,\n        duplicate,\n      }),\n    };\n  }\n\n  _firstVar () {\n    return this.fun._firstVar();\n  }\n\n  apply (...args) {\n    if (args.length === 0)\n      return this;\n    return new App(this, ...args);\n  }\n\n  expand () {\n    return this.fun.expand().apply(this.arg.expand());\n  }\n\n  _replace (pairs, opt) {\n    const maybe = super._replace(pairs, opt);\n    if (maybe)\n      return maybe;\n    const [fun, arg] = this.split();\n    return (fun._replace(pairs, opt) ?? fun).apply(arg._replace(pairs, opt) ?? arg);\n  }\n\n  renameVars (seq) {\n    return this.fun.renameVars(seq).apply(this.arg.renameVars(seq));\n  }\n\n  subst (plug, value) {\n    const fun = this.fun.subst(plug, value);\n    const arg = this.arg.subst(plug, value);\n\n    return (fun || arg) ? (fun ?? this.fun).apply(arg ?? this.arg) : null;\n  }\n\n  /**\n   * @return {{expr: Expr, steps: number}}\n   */\n\n  step () {\n    // normal reduction order: first try root, then at most 1 step\n    if (!this.final) {\n      if (this.arity === 0) {\n        // aha! we have just fulfilled some previous function's argument demands\n        const reduced = this.fun.reduce([this.arg]);\n        // should always be true, but whatever\n        if (reduced)\n          return { expr: reduced, steps: 1, changed: true };\n      }\n      // now try recursing\n\n      const fun = this.fun.step();\n      if (fun.changed)\n        return { expr: fun.expr.apply(this.arg), steps: fun.steps, changed: true };\n\n      const arg = this.arg.step();\n      if (arg.changed)\n        return { expr: this.fun.apply(arg.expr), steps: arg.steps, changed: true };\n\n      this.final = true;\n    }\n    return { expr: this, steps: 0, changed: false };\n  }\n\n  reduce (args) {\n    return this.fun.reduce([this.arg, ...args]);\n  }\n\n  split () {\n    // pretend we are an elegant (cons fun arg) and not a sleazy imperative array\n    return [this.fun, this.arg];\n  }\n\n  _aslist () {\n    return [...this.fun._aslist(), this.arg];\n  }\n\n  /**\n   * @desc Convert the expression to SKI combinatory logic\n   * @return {Expr}\n   */\n\n  _rski (options) {\n    if (options.steps >= options.max)\n      return this;\n    return this.fun._rski(options).apply(this.arg._rski(options));\n  }\n\n  equals (other) {\n    if (!(other instanceof App))\n      return super.equals(other);\n\n    return this.fun.equals(other.fun) && this.arg.equals(other.arg);\n  }\n\n  contains (other) {\n    return this.fun.contains(other) || this.arg.contains(other) || super.contains(other);\n  }\n\n  needsParens (first) {\n    return !first;\n  }\n\n  toString (opt = {}) {\n    const fun = this.fun.toString(opt);\n    const root = this.fun.needsParens(true) ? '(' + fun + ')' : fun;\n    if (opt.terse ?? globalOptions.terse) {\n      // terse mode: omit whitespace and parens if possible\n      let arg = this.arg.toString(opt);\n      if (this.arg.needsParens(false))\n        arg = '(' + arg + ')';\n      const space = (root.match(/\\)$/) || arg.match(/^\\(/))\n        || (root.match(/[A-Z]$/) && arg.match(/^[a-z]/i))\n        ? ''\n        : ' ';\n      return root + space + arg;\n    } else\n      return root + '(' + this.arg.toString(opt) + ')';\n  }\n\n  _format (options, nargs) {\n    const fun = this.fun._format(options, nargs + 1);\n    const arg = this.arg._format(options, 0);\n    // TODO ignore terse for now\n    if (options.terse && !this.arg.needsParens(false))\n      return options.app[0] + fun + (this.fun._spaced(this.arg) ? options.space : '') + arg + options.app[1];\n\n    else\n      return options.app[0] + fun + options.brackets[0] + arg + options.brackets[1] + options.app[1];\n  }\n\n  _spaced (arg) {\n    return this.arg.needsParens(false) ? false : this.arg._spaced(arg);\n  }\n}\n\nclass Named extends Expr {\n  /**\n     * @desc a constant named 'name'\n     * @param {String} name\n     */\n  constructor (name) {\n    super();\n    if (typeof name !== 'string' || name.length === 0)\n      throw new Error('Attempt to create a named term with improper name');\n    this.name = name;\n  }\n\n  toString () {\n    return this.name;\n  }\n\n  _spaced (arg) {\n    return !(this.name.match(/^[A-Z+]$/) || arg.name.match(/^[A-Z+]$/));\n  }\n}\n\nlet freeId = 0;\n\nclass FreeVar extends Named {\n  constructor (name) {\n    super(name);\n    this.id = ++freeId;\n  }\n\n  subst (plug, value) {\n    if (this === plug)\n      return value;\n    return null;\n  }\n\n  weight () {\n    return 0;\n  }\n\n  _firstVar () {\n    return true;\n  }\n\n  toString ( opt = {} ) {\n    return (opt.html && /^[a-z]$/.test(this.name)) ? '<var>' + this.name + '</var>' : this.name;\n  }\n\n  _format (options, nargs) {\n    return options.var[0] + this.name + options.var[1];\n  }\n}\n\n/**\n * @typedef {function(Expr): Expr | AnyArity} AnyArity\n */\n\nclass Native extends Named {\n  /**\n   * @desc A term named 'name' that converts next 'arity' arguments into\n   *       an expression returned by 'impl' function\n   *       If an apply: Expr=>Expr|null function is given, it will be attempted upon application\n   *       before building an App object. This allows to plug in argument coercions,\n   *       e.g. instantly perform a numeric operation natively if the next term is a number.\n   * @param {String} name\n   * @param {AnyArity} impl\n   * @param {{note: string?, arity: number?, canonize: boolean?, apply: function(Expr):(Expr|null) }} [opt]\n   */\n  constructor (name, impl, opt = {}) {\n    super(name);\n    // setup essentials\n    this.impl  = impl;\n    if (opt.apply)\n      this.onApply = opt.apply;\n    this.arity = opt.arity ?? 1;\n\n    // try to bootstrap and guess some of our properties\n    const guess = (opt.canonize ?? true) ? this.guess() : { normal: false };\n\n    if (!opt.arity)\n      this.arity = guess.arity || 1;\n\n    this.note = opt.note ?? guess.expr?.toString({ terse: true, html: true });\n  }\n\n  apply (...args) {\n    if (this.onApply && args.length >= 1) {\n      if (typeof this.onApply !== 'function') {\n        throw new Error('Native combinator ' + this + ' has an invalid onApply property  of type'\n          + typeof this.onApply + ': ' + this.onApply);\n      }\n      const subst = this.onApply(args[0]);\n      if (subst instanceof Expr)\n        return subst.apply(...args.slice(1));\n    }\n    return super.apply(...args);\n  }\n\n  _rski (options) {\n    if (this === native.I || this === native.K || this === native.S || (options.steps >= options.max))\n      return this;\n    const canon = this.guess().expr;\n    if (!canon)\n      return this;\n    options.steps++;\n    return canon._rski(options);\n  }\n\n  reduce (args) {\n    if (args.length < this.arity)\n      return null;\n    let egde = 0;\n    let step = this.impl;\n    while (typeof step === 'function') {\n      if (egde >= args.length)\n        return null;\n      step = step(args[egde++]);\n    }\n    if (!(step instanceof Expr))\n      throw new Error('Native combinator ' + this + ' reduced to a non-expression: ' + step);\n    return step.apply(...args.slice(egde));\n  }\n\n  toJSON () {\n    return 'Native:' + this.name;\n  }\n\n  _format (options, nargs) {\n    return (this.arity > 0 && this.arity <= nargs)\n      ? options.redex[0] + this.name + options.redex[1]\n      : this.name;\n  }\n}\n\nconst native = {};\nfunction addNative (name, impl, opt) {\n  native[name] = new Native(name, impl, opt);\n}\n\nclass Lambda extends Expr {\n  /**\n     * @param {FreeVar|FreeVar[]} arg\n     * @param {Expr} impl\n     */\n  constructor (arg, impl) {\n    if (Array.isArray(arg)) {\n      // check args before everything\n      if (arg.length === 0)\n        throw new Error('empty argument list in lambda constructor');\n\n      const [my, ...tail] = arg;\n      const known = new Set([my.name]);\n\n      while (tail.length > 0) {\n        const last = tail.pop();\n        if (known.has(last.name))\n          throw new Error('Duplicate free var name ' + last + ' in lambda expression');\n        known.add(last.name);\n\n        // TODO keep track of arity to speed up execution\n        impl = new Lambda(last, impl);\n      }\n      arg = my;\n    }\n\n    super();\n\n    // localize argument variable as it may appear elsewhere\n    const local = new FreeVar(arg.name);\n    this.arg = local;\n    this.impl = impl.subst(arg, local) ?? impl;\n    this.arity = 1;\n  }\n\n  getSymbols () {\n    const out = this.impl.getSymbols();\n    out.delete(this.arg);\n    out.set(Expr.lambdaPlaceholder, (out.get(Expr.lambdaPlaceholder) ?? 0) + 1);\n    return out;\n  }\n\n  weight () {\n    return this.impl.weight() + 1;\n  }\n\n  _guess (options, preArgs = [], steps = 0) {\n    if (preArgs.length > options.maxArgs)\n      return { normal: false, steps };\n\n    const push = nthvar(preArgs.length + options.index);\n    return this.reduce([push])._guess(options, [...preArgs, push], steps + 1);\n  }\n\n  reduce (input) {\n    if (input.length === 0)\n      return null;\n\n    const [head, ...tail] = input;\n\n    return (this.impl.subst(this.arg, head) ?? this.impl).apply(...tail);\n  }\n\n  subst (plug, value) {\n    if (plug === this.arg)\n      return null;\n    const change = this.impl.subst(plug, value);\n    if (change)\n      return new Lambda(this.arg, change);\n    return null;\n  }\n\n  expand () {\n    return new Lambda(this.arg, this.impl.expand());\n  }\n\n  renameVars (seq) {\n    const arg = new FreeVar(seq.next().value);\n    const impl = this.impl.subst(this.arg, arg) ?? this.impl;\n    return new Lambda(arg, impl.renameVars(seq));\n  }\n\n  _rski (options) {\n    const impl = this.impl._rski(options);\n    if (options.steps >= options.max)\n      return new Lambda(this.arg, impl);\n    options.steps++;\n    if (impl === this.arg)\n      return native.I;\n    if (!impl.getSymbols().has(this.arg))\n      return native.K.apply(impl);\n    if (impl instanceof App) {\n      const [fst, snd] = impl.split();\n      // try eta reduction\n      if (snd === this.arg && !fst.getSymbols().has(this.arg))\n        return fst._rski(options);\n      // fall back to S\n      return native.S.apply(\n        (new Lambda(this.arg, fst))._rski(options),\n        (new Lambda(this.arg, snd))._rski(options)\n      );\n    }\n    throw new Error('Don\\'t know how to convert to SKI' + this);\n  }\n\n  _replace (pairs, opt) {\n    const maybe = super._replace(pairs, opt);\n    if (maybe)\n      return maybe;\n    // TODO filter out terms containing this.arg\n    return new Lambda(this.arg, this.impl._replace(pairs, opt) ?? this.impl);\n  }\n\n  equals (other) {\n    if (!(other instanceof Lambda))\n      return super.equals(other);\n\n    const t = new FreeVar('t');\n\n    return other.reduce([t]).equals(this.reduce([t]));\n  }\n\n  contains (other) {\n    return this.equals(other) || this.impl.contains(other);\n  }\n\n  toString (opt = {}) {\n    const mapsto = opt.html ? ' &mapsto; ' : '->';\n    return this.arg.toString(opt) + mapsto + this.impl.toString(opt);\n  }\n\n  _format (options, nargs) {\n    return (nargs > 0 ? options.brackets[0] : '')\n      + options.lambda[0] + this.arg._format(options, 0)\n      + options.lambda[1]\n      + this.impl._format(options, 0) + options.lambda[2]\n      + (nargs > 0 ? options.brackets[1] : '');\n  }\n\n  needsParens (first) {\n    return true;\n  }\n}\n\nclass Church extends Native {\n  constructor (n) {\n    const p = Number.parseInt(n);\n    if (!(p >= 0))\n      throw new Error('Church number must be a non-negative integer');\n    const name = '' + p;\n    const impl = x => y => {\n      let expr = y;\n      for (let i = p; i-- > 0; )\n        expr = x.apply(expr);\n      return expr;\n    };\n\n    super(name, impl, { arity: 2, canonize: false, note: name });\n\n    this.n = p;\n    this.arity = 2;\n  }\n\n  equals (other) {\n    if (other instanceof Church)\n      return this.n === other.n;\n    return super.equals(other);\n  }\n\n  _spaced (arg) {\n    return true;\n  }\n}\n\nclass Alias extends Named {\n  /**\n   * @desc An existing expression under a different name.\n   * @param {String} name\n   * @param {Expr} impl\n   * @param {{canonize: boolean?, max: number?, maxArgs: number?, note: string?, terminal: boolean?}} [options]\n   */\n  constructor (name, impl, options = {}) {\n    super(name);\n    this.impl = impl;\n\n    if (options.note)\n      this.note = options.note;\n\n    const guess = options.canonize\n      ? impl.guess({ max: options.max, maxArgs: options.maxArgs })\n      : { normal: false };\n    this.arity = (guess.proper && guess.arity) || 0;\n    this.proper = guess.proper ?? false;\n    this.terminal = options.terminal ?? this.proper;\n    this.canonical = guess.expr;\n  }\n\n  getSymbols () {\n    return this.terminal ? new Map([[this, 1]]) : this.impl.getSymbols();\n  }\n\n  weight () {\n    return this.terminal ? 1 : this.impl.weight();\n  }\n\n  expand () {\n    return this.impl.expand();\n  }\n\n  subst (plug, value) {\n    return this.impl.subst(plug, value);\n  }\n\n  _guess (options, preArgs = [], steps = 0) {\n    return this.impl._guess(options, preArgs, steps);\n  }\n\n  /**\n   *\n   * @return {{expr: Expr, steps: number}}\n   */\n  step () {\n    // arity known = waiting for args to expand\n    if (this.arity > 0)\n      return { expr: this, steps: 0, changed: false };\n    // expanding is a change but it takes 0 steps\n    return { expr: this.impl, steps: 0, changed: true };\n  }\n\n  reduce (args) {\n    if (args.length < this.arity)\n      return null;\n    return this.impl.apply(...args);\n  }\n\n  _firstVar () {\n    return this.impl._firstVar();\n  }\n\n  equals (other) {\n    return other.equals(this.impl);\n  }\n\n  contains (other) {\n    return this.impl.contains(other);\n  }\n\n  _rski (options) {\n    return this.impl._rski(options);\n  }\n\n  toString (opt) {\n    return this.outdated ? this.impl.toString(opt) : super.toString(opt);\n  }\n\n  needsParens (first) {\n    return this.outdated ? this.impl.needsParens() : false;\n  }\n\n  _format (options, nargs) {\n    if (this.outdated)\n      return this.impl._format(options, nargs);\n    // same as Native -- refactor?\n    return (this.arity > 0 && this.arity <= nargs)\n      ? options.redex[0] + this.name + options.redex[1]\n      : this.name;\n  }\n}\n\n// ----- Expr* classes end here -----\n\n// declare native combinators\naddNative('I', x => x);\naddNative('K', x => _ => x);\naddNative('S', x => y => z => x.apply(z, y.apply(z)));\naddNative('B', x => y => z => x.apply(y.apply(z)));\naddNative('C', x => y => z => x.apply(z).apply(y));\naddNative('W', x => y => x.apply(y).apply(y));\n\naddNative('+', x => y => z => y.apply(x.apply(y, z)), {\n  note:  '<var>n</var> &mapsto; <var>n</var> + 1 <i>or</i> SB',\n  apply: arg => arg instanceof Church ? new Church(arg.n + 1) : null\n});\n\nfunction maybeLambda (args, expr, caps = {}) {\n  const sym = expr.getSymbols();\n\n  const [skip, dup] = skipDup(args, sym);\n\n  return {\n    expr:      args.length ? new Lambda(args, expr) : expr,\n    ...(caps.synth ? {} : { arity: args.length }),\n    ...(skip.size ? { skip } : {}),\n    ...(dup.size ? { dup } : {}),\n    duplicate: !!dup.size  || caps.duplicate || false,\n    discard:   !!skip.size || caps.discard   || false,\n    proper:    isSubset(sym.keys(), new Set(args)),\n  };\n}\n\nfunction naiveCanonize (expr) {\n  if (expr instanceof App)\n    return naiveCanonize(expr.fun).apply(naiveCanonize(expr.arg));\n\n  if (expr instanceof Lambda)\n    return new Lambda(expr.arg, naiveCanonize(expr.impl));\n\n  if (expr instanceof Alias)\n    return naiveCanonize(expr.impl);\n\n  const canon = expr.guess();\n  if (canon.expr)\n    return canon.expr;\n\n  throw new Error('Failed to canonize expression: ' + expr);\n}\n\n/**\n *\n * @param {Expr} expr\n * @param {{max: number?, maxArgs: number?}} options\n * @param {number} maxWeight\n * @yields {{expr: Expr, steps: number?, comment: string?}}\n */\nfunction * simplifyLambda (expr, options = {}, state = { steps: 0 }) {\n  // expr is a lambda, free variable, or an application thereof\n  // we want to find an equivalent lambda term with less weight\n  // which we do sequentially from leaves to the root of the AST\n\n  yield { expr, steps: state.steps, comment: '(self)' };\n\n  // short-circuit\n  if (expr.freeOnly())\n    return;\n\n  let maxWeight = expr.weight();\n\n  if (expr instanceof Lambda) {\n    for (const term of simplifyLambda(expr.impl, options, state)) {\n      const candidate = new Lambda(expr.arg, term.expr);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        yield { expr: candidate, steps: state.steps, comment: '(lambda)' + term.comment };\n      }\n    }\n  }\n\n  // fun * arg Descartes product\n  if (expr instanceof App) {\n    // try to split into fun+arg, then try canonization but exposing each step\n    let [fun, arg] = expr.split();\n\n    for (const term of simplifyLambda(fun, options, state)) {\n      const candidate = term.expr.apply(arg);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        fun = term.expr;\n        yield { expr: candidate, steps: state.steps, comment: '(fun)' + term.comment };\n      }\n    }\n\n    for (const term of simplifyLambda(arg, options, state)) {\n      const candidate = fun.apply(term.expr);\n      if (candidate.weight() < maxWeight) {\n        maxWeight = candidate.weight();\n        yield { expr: candidate, steps: state.steps, comment: '(arg)' + term.comment };\n      }\n    }\n  }\n\n  const canon = expr.guess({ max: options.max, maxArgs: options.maxArgs });\n  state.steps += canon.steps;\n  if (canon.expr && canon.expr.weight() < maxWeight)\n    yield { expr: canon.expr, steps: state.steps, comment: '(canonical)' };\n}\n\nfunction nthvar (n) {\n  return new FreeVar('abcdefgh'[n] ?? 'x' + n);\n}\n\n// A global value meaning \"lambda is used somewhere in this expression\"\n// Can't be used (at least for now) to construct lambda expressions, or anything at all.\n// See also getSymbols().\nExpr.lambdaPlaceholder = new Native('->', x => x, {\n  arity:    1,\n  canonize: false,\n  note:     'Lambda placeholder',\n  apply:    x => { throw new Error('Attempt to use a placeholder in expression') }\n});\n\nmodule.exports = { Expr, App, FreeVar, Lambda, Native, Alias, Church, globalOptions, native };\n", "/**\n * Combinatory logic simulator\n */\n\nconst { Tokenizer, restrict } = require('./util');\nconst { globalOptions, Expr, App, FreeVar, Lambda, Native, Alias, Church, native } = require('./expr');\n\nclass Empty extends Expr {\n  apply (...args) {\n    return args.length ? args.shift().apply(...args) : this;\n  }\n\n  postParse () {\n    throw new Error('Attempt to use empty expression () as a term');\n  }\n}\n\nclass PartialLambda extends Empty {\n  // TODO mutable! rewrite ro when have time\n  constructor (term, known = {}) {\n    super();\n    this.impl = new Empty();\n    if (term instanceof FreeVar)\n      this.terms = [term];\n    else if (term instanceof PartialLambda) {\n      if (!(term.impl instanceof FreeVar))\n        throw new Error('Expected FreeVar->...->FreeVar->Expr');\n      this.terms = [...term.terms, term.impl];\n    } else\n      throw new Error('Expected FreeVar or PartialLambda');\n  }\n\n  apply (term, ...tail) {\n    if (term === null || tail.length !== 0 )\n      throw new Error('bad syntax in partial lambda expr');\n    this.impl = this.impl.apply(term);\n    return this;\n  }\n\n  postParse () {\n    return new Lambda(this.terms, this.impl);\n  }\n\n  // uncomment if debugging with prints\n  /* toString () {\n    return this.terms.join('->') + '->' + (this.impl ?? '???');\n  } */\n}\n\nconst combChars = new Tokenizer(\n  '[()]', '[A-Z]', '[a-z_][a-z_0-9]*', '\\\\b[0-9]+\\\\b', '->', '\\\\+'\n);\n\nclass SKI {\n  /**\n   *\n   * @param {{\n   *    allow: string?,\n   *    numbers: boolean?,\n   *    lambdas: boolean?,\n   *    terms: { [key: string]: Expr|string}?,\n   *    annotate: boolean?,\n   * }} [options]\n   */\n  constructor (options = {}) {\n    this.annotate = options.annotate ?? false;\n    this.known = { ...native };\n    this.hasNumbers = true;\n    this.hasLambdas = true;\n    this.allow = new Set(Object.keys(this.known));\n\n    // Import terms, if any. Omit native ones\n    for (const name in options.terms ?? {}) {\n      // Native terms already handled by allow\n      if (!options.terms[name].match(/^Native:/))\n        this.add(name, options.terms[name]);\n    }\n\n    // Finally, impose restrictions\n    // We must do it after recreating terms, or else terms reliant on forbidden terms will fail\n    this.hasNumbers = options.numbers ?? true;\n    this.hasLambdas = options.lambdas ?? true;\n    if (options.allow)\n      this.restrict(options.allow);\n  }\n\n  /**\n   *\n   * @param {Alias|String} term\n   * @param {Expr|String|[number, function(...Expr): Expr, {note: string?, fast: boolean?}]} [impl]\n   * @param {String} [note]\n   * @return {SKI} chainable\n   */\n  add (term, impl, note ) {\n    if (typeof term === 'string') {\n      if (typeof impl === 'string')\n        term = new Alias(term, this.parse(impl), { canonize: true });\n      else if (impl instanceof Expr)\n        term = new Alias(term, impl, { canonize: true });\n      else\n        throw new Error('add: term must be an Alias or a string and impl must be an Expr or a string');\n    } else if (term instanceof Alias)\n      term = new Alias(term.name, term.impl, { canonize: true });\n\n    // This should normally be unreachable but let's keep just in case\n    if (!(term instanceof Alias))\n      throw new Error('add: term must be an Alias or a string (accompanied with an implementation)');\n\n    if (this.annotate && note === undefined && term.canonical)\n      note = term.canonical.toString({ terse: true, html: true });\n    if (note !== undefined)\n      term.note = note;\n\n    this.known['' + term] = term;\n    this.allow.add('' + term);\n\n    return this;\n  }\n\n  maybeAdd (name, impl) {\n    if (this.known[name])\n      this.allow.add(name);\n    else\n      this.add(name, impl);\n    return this;\n  }\n\n  /**\n   * Restrict the interpreter to given terms. Terms prepended with '+' will be added\n   * and terms preceeded with '-' will be removed.\n   * @example ski.restrict('SK') // use the basis\n   * @example ski.restrict('+I') // allow I now\n   * @example ski.restrict('-SKI +BCKW' ); // switch basis\n   * @example ski.restrict('-foo -bar'); // forbid some user functions\n   * @param {string} spec\n   * @return {SKI} chainable\n   */\n  restrict (spec) {\n    this.allow = restrict(this.allow, spec);\n    return this;\n  }\n\n  /**\n   *\n   * @param {string} spec\n   * @return {string}\n   */\n  showRestrict (spec = '+') {\n    const out = [];\n    let prevShort = true;\n    for (const term of [...restrict(this.allow, spec)].sort()) {\n      const nextShort = term.match(/^[A-Z]$/);\n      if (out.length && !(prevShort && nextShort))\n        out.push(' ');\n      out.push(term);\n      prevShort = nextShort;\n    }\n    return out.join('');\n  }\n\n  /**\n   *\n   * @param {String} name\n   * @return {SKI}\n   */\n  remove (name) {\n    this.known[name].outdated = true;\n    delete this.known[name];\n    this.allow.delete(name);\n    return this;\n  }\n\n  /**\n   *\n   * @return {{[key:string]: Native|Alias}}\n   */\n  getTerms () {\n    const out = {};\n    for (const name of Object.keys(this.known)) {\n      if (this.allow.has(name))\n        out[name] = this.known[name];\n    }\n    return out;\n  }\n\n  /**\n   *\n   * @param {string} source\n   * @param {{[keys: string]: Expr}} vars\n   * @param {{numbers: boolean?, lambdas: boolean?, allow: string?}} options\n   * @return {Expr}\n   */\n  parse (source, vars = {}, options = {}) {\n    if (typeof source !== 'string')\n      throw new Error('parse: source must be a string, got ' + typeof source);\n\n    const lines = source.replace(/\\/\\/[^\\n]*$/gm, '')\n      .split(/\\s*;[\\s;]*/).filter( s => s.match(/\\S/));\n\n    const jar = { ...vars };\n\n    let expr = new Empty();\n    for (const item of lines) {\n      const [_, save, str] = item.match(/^(?:\\s*([A-Z]|[a-z][a-z_0-9]*)\\s*=\\s*)?(.*)$/s);\n      if (expr instanceof Alias)\n        expr.outdated = true;\n      expr = this.parseLine(str, jar, options);\n\n      if (save !== undefined) {\n        if (jar[save] !== undefined)\n          throw new Error('Attempt to redefine a known term: ' + save);\n        expr = new Alias(save, expr);\n        jar[save] = expr;\n      }\n\n      // console.log('parsed line:', item, '; got:', expr,'; jar now: ', jar);\n    }\n\n    // reimport free variables, so that co-parsing x(y(z)) and z(x(y)) with the same jar\n    //     results in _equal_ free vars and not just ones with the same name\n    for (const name in jar) {\n      if (!vars[name] && jar[name] instanceof SKI.classes.FreeVar)\n        vars[name] = jar[name];\n    }\n\n    return expr;\n  }\n\n  /**\n   *\n   * @param {String} source S(KI)I\n   * @param {{[keys: string]: Expr}} vars\n   * @param {{numbers: boolean?, lambdas: boolean?, allow: string?}} options\n   * @return {Expr} parsed expression\n   */\n  parseLine (source, vars = {}, options = {}) {\n    const opt = {\n      numbers: options.numbers ?? this.hasNumbers,\n      lambdas: options.lambdas ?? this.hasLambdas,\n      allow:   restrict(this.allow, options.allow),\n    };\n    // make sure '+' usage is in sync with numerals\n    opt.numbers ? opt.allow.add('+') : opt.allow.delete('+');\n\n    const tokens = combChars.split(source);\n\n    const empty = new Empty();\n    /** @type {Expr[]} */\n    const stack = [empty];\n\n    // TODO each token should carry along its position in source\n    for (const c of tokens) {\n      // console.log(\"parseLine: found \"+c+\"; stack =\", stack.join(\", \"));\n      if (c === '(')\n        stack.push(empty);\n      else if (c === ')') {\n        if (stack.length < 2)\n          throw new Error('unbalanced input: extra closing parenthesis' + source);\n        const x = stack.pop().postParse();\n        const f = stack.pop();\n        stack.push(f.apply(x));\n      } else if (c === '->') {\n        if (!opt.lambdas)\n          throw new Error('Lambdas not supported, allow them explicitly');\n        stack.push(new PartialLambda(stack.pop(), vars));\n      } else if (c.match(/^[0-9]+$/)) {\n        if (!opt.numbers)\n          throw new Error('Church numbers not supported, allow them explicitly');\n        const f = stack.pop();\n        stack.push(f.apply(new Church(c)));\n      } else {\n        const f = stack.pop();\n        if (!vars[c] && this.known[c] && !opt.allow.has(c)) {\n          throw new Error('Term \\'' + c + '\\' is not in the restricted set '\n            + [...opt.allow].sort().join(' '));\n        }\n        // look in temp vars first, then in known terms, then fallback to creating free var\n        const x = vars[c] ?? this.known[c] ?? (vars[c] = new FreeVar(c));\n        stack.push(f.apply(x));\n      }\n    }\n\n    if (stack.length !== 1) {\n      throw new Error('unbalanced input: missing '\n          + (stack.length - 1) + ' closing parenthesis:' + source);\n    }\n\n    return stack.pop().postParse();\n  }\n\n  toJSON () {\n    return {\n      allow:    this.showRestrict('+'),\n      numbers:  this.hasNumbers,\n      lambdas:  this.hasLambdas,\n      terms:    this.getTerms(),\n      annotate: this.annotate,\n    }\n  }\n}\n\n// Create shortcuts for common terms\n/**\n * Create free var(s) for subsequent use\n * @param {String} names\n * @return {FreeVar[]}\n */\nSKI.free = (...names) => names.map(s => new FreeVar(s));\n\n/**\n * Convert a number to Church encoding\n * @param {number} n\n * @return {Church}\n */\nSKI.church = n => new Church(n);\nSKI.classes = { Expr, Native, Alias, FreeVar, Lambda, Church };\n\n/**\n *\n * @type {{[key: string]: Native}}\n */\n\nfor (const name in native)\n  SKI[name] = native[name];\nSKI.native = native;\nSKI.options = globalOptions;\nSKI.lambdaPlaceholder = Expr.lambdaPlaceholder;\n\nmodule.exports = { SKI };\n", "const { SKI } = require('./parser');\nconst { Expr, FreeVar, Alias, Lambda } = SKI.classes;\n\n/**\n * @typedef {{\n *   pass: boolean,\n *   reason: string?,\n *   steps: number,\n *   start: Expr,\n *   found: Expr,\n *   expected: Expr,\n *   note: string?,\n *   args: Expr[],\n *   case: Case\n * }} CaseResult\n */\n\n/**\n * @typedef {{\n *   linear: boolean?,\n *   affine: boolean?,\n *   normal: boolean?,\n *   proper: boolean?,\n *   discard: boolean?,\n *   duplicate: boolean?,\n *   arity: number?,\n * }} Capability\n */\n\n/**\n * @typedef {\n *   [string, string]\n *   | [{max: number?}, string, string]\n *   | [{caps: Capability, max: number?}, string]\n * } TestCase\n */\n\nclass Quest {\n  /**\n   * @description A combinator problem with a set of test cases for the proposed solution.\n   * @param {{\n   *    title: string?,\n   *    descr: string?,\n   *    subst: string?,\n   *    allow: string?,\n   *    numbers: boolean?,\n   *    vars: string[]?,\n   *    engine: SKI?,\n   *    engineFull: SKI?,\n   *    cases: TestCase[],\n   * }} options\n   */\n  constructor (options = {}) {\n    const { input, vars, cases, allow, numbers, lambdas, subst, engine, engineFull, ...meta } = options;\n\n    //\n    this.engine = engine ?? new SKI();\n    this.engineFull = engineFull ?? new SKI();\n    this.restrict = { allow, numbers: numbers ?? false, lambdas: lambdas ?? false };\n    this.vars = {};\n    this.subst = Array.isArray(subst) ? subst : [subst ?? 'phi'];\n\n    const jar = {};\n\n    // options.vars is a list of expressions.\n    // we suck all free variables + all term declarations from there into this.vars\n    // to feed it later to every case's parser.\n    for (const term of vars ?? []) {\n      const expr = this.engineFull.parse(term, jar);\n      if (expr instanceof SKI.classes.Alias)\n        this.vars[expr.name] = new Alias(expr.name, expr.impl, { terminal: true, canonize: false });\n        // Canonized aliases won't expand with insufficient arguments,\n        // causing correct solutions to fail, so alas...\n      else if (expr instanceof SKI.classes.FreeVar)\n        this.vars[expr.name] = expr;\n      else\n        throw new Error('Unsupported given variable type: ' + term);\n    }\n\n    this.input = [];\n    for (const term of Array.isArray(input) ? input : [input])\n      this.addInput(term);\n    if (!this.input.length)\n      throw new Error('Quest needs at least one input placeholder');\n    if (subst)\n      this.input[0].fancy = this.subst[0];\n\n    this.varsFull = { ...this.vars, ...jar };\n    for (const term of this.input) {\n      if (term.name in this.varsFull)\n        throw new Error('input placeholder name is duplicated or clashes with vars: ' + term.name);\n      this.varsFull[term.name] = term.placeholder;\n    }\n\n    this.cases = [];\n    this.title = meta.title;\n    meta.descr = list2str(meta.descr);\n    this.descr = meta.descr;\n    this.meta = meta;\n\n    for (const c of cases ?? [])\n      this.add(...c);\n  }\n\n  /**\n   *   Display allowed terms based on what engine thinks of this.vars + this.restrict.allow\n   *   @return {string}\n   */\n  allowed () {\n    const allow = this.restrict.allow ?? '';\n    const vars = Object.keys(this.vars).sort();\n    // In case vars are present and restrictions aren't, don't clutter the output with all the known terms\n    return allow\n      ? this.engine.showRestrict(allow + '+' + vars.join(' '))\n      : vars.map( s => '+' + s).join(' ');\n  }\n\n  addInput (term) {\n    if (typeof term !== 'object')\n      term = { name: term };\n    if (typeof term.name !== 'string')\n      throw new Error(\"quest 'input' field must be a string or a {name: string, ...} object\");\n\n    [term.placeholder] = SKI.free(term.name);\n    // TODO more checks\n    this.input.push(term);\n  }\n\n  /**\n   *\n   * @param {{} | string} opt\n   * @param {string} terms\n   * @return {Quest}\n   */\n  add (opt, ...terms) {\n    if (typeof opt === 'string') {\n      terms.unshift(opt);\n      opt = {};\n    } else\n      opt = { ...opt };\n\n    opt.engine = opt.engine  ?? this.engineFull;\n    opt.vars = opt.vars ?? this.varsFull;\n\n    const input = this.input.map( t => t.placeholder );\n    this.cases.push(\n      opt.caps\n        ? new PropertyCase(input, opt, terms)\n        : new ExprCase(input, opt, terms)\n    );\n    return this;\n  }\n\n  /**\n   * @description Statefully parse a list of strings into expressions or fancy aliases thereof.\n   * @param {string[]} input\n   * @return {{terms: Expr[], weight: number}}\n   */\n  prepare (...input) {\n    if (input.length !== this.input.length)\n      throw new Error('Solutions provided ' + input.length + ' terms where ' + this.input.length + ' are expected');\n\n    let weight = 0;\n    const prepared = [];\n    const jar = { ...this.vars };\n    for (let i = 0; i < input.length; i++) {\n      const spec = this.input[i];\n      const impl = this.engine.parse(input[i], jar, {\n        allow:   spec.allow ?? this.restrict.allow,\n        numbers: spec.numbers ?? this.restrict.numbers,\n        lambdas: spec.lambdas ?? this.restrict.lambdas,\n      });\n      weight += impl.weight();\n      const expr = impl instanceof FreeVar\n        ? impl\n        : new Alias(spec.fancy ?? spec.name, impl, { terminal: true, canonize: false });\n      jar[spec.name] = expr;\n      prepared.push(expr);\n    }\n    return {\n      prepared,\n      weight,\n    };\n  }\n\n  /**\n   *\n   * @param {string} input\n   * @return {{\n   *             expr: Expr?,\n   *             pass: boolean,\n   *             details: CaseResult[],\n   *             exception: Error?,\n   *             steps: number,\n   *             input: Expr[]|string[],\n   *             weight: number?\n   *         }}\n   */\n  check (...input) {\n    try {\n      const { prepared, weight } = this.prepare(...input);\n      const details = this.cases.map( c => c.check(...prepared) );\n      const pass = details.reduce((acc, val) => acc && val.pass, true);\n      const steps = details.reduce((acc, val) => acc + val.steps, 0);\n      return {\n        expr:  prepared[0],\n        input: prepared,\n        pass,\n        steps,\n        details,\n        weight,\n      };\n    } catch (e) {\n      return { pass: false, details: [], exception: e, steps: 0, input };\n    }\n  }\n\n  /**\n     *\n     * @return {TestCase[]}\n     */\n  show () {\n    return [...this.cases];\n  }\n}\n\nclass Case {\n  constructor (input, options) {\n    this.max = options.max ?? 1000;\n    this.note = options.note;\n    this.vars = { ...(options.vars ?? {}) }; // shallow copy to avoid modifying the original\n    this.input = input;\n    this.engine = options.engine;\n  }\n\n  parse (src) {\n    return new Lambda(this.input, this.engine.parse(src, this.vars));\n  }\n\n  /**\n   * @param {Expr} expr\n   * @return {CaseResult}\n   */\n  check ( ...expr ) {\n    throw new Error('not implemented');\n  }\n}\n\nclass ExprCase extends Case {\n  /**\n   * @param {FreeVar[]} input\n   * @param {{\n   *    max: number?,\n   *    note: string?,\n   *    vars: {string: Expr}?,\n   *    engine: SKI?\n   * }} options\n   * @param {[e1: string, e2: string]} terms\n   */\n  constructor (input, options, terms) {\n    if (terms.length !== 2)\n      throw new Error('Case accepts exactly 2 strings');\n\n    super(input, options);\n\n    [this.e1, this.e2] = terms.map(src => this.parse(src));\n  }\n\n  check (...expr) {\n    // we do it the fancy way and instead of just \"apply\" to avoid\n    // displaying (foo->foo this that)(user input) as 1st step\n    const subst = (outer, inner) => outer.reduce(inner) ?? outer.apply(...inner);\n\n    const start = subst(this.e1, expr);\n    const r1 = start.run({ max: this.max });\n    const r2 = subst(this.e2, expr).run({ max: this.max });\n    let reason = null;\n    if (!r1.final || !r2.final)\n      reason = 'failed to reach normal form in ' + this.max + ' steps';\n    else if (!r1.expr.equals(r2.expr))\n      reason = 'expected: ' + r2.expr;\n    // NOTE maybe there should be expand() on both sides of equal() but we'll see.\n\n    return {\n      pass:     !reason,\n      reason,\n      steps:    r1.steps,\n      start,\n      found:    r1.expr,\n      expected: r2.expr,\n      note:     this.note,\n      args:     expr,\n      case:     this,\n    };\n  }\n}\n\nconst knownCaps = {\n  normal:    true,\n  proper:    true,\n  discard:   true,\n  duplicate: true,\n  linear:    true,\n  affine:    true,\n  arity:     true,\n}\n\nclass PropertyCase extends Case {\n  // test that an expression uses all of its inputs exactly once\n  constructor (input, options, terms) {\n    super(input, options);\n    if (terms.length > 1)\n      throw new Error('PropertyCase accepts exactly 1 string');\n    if (!options.caps || typeof options.caps !== 'object' || !Object.keys(options.caps).length)\n      throw new Error('PropertyCase requires a caps object with at least one capability');\n    const unknown = Object.keys(options.caps).filter( c => !knownCaps[c] );\n    if (unknown.length)\n      throw new Error('PropertyCase: don\\'t know how to test these capabilities: ' + unknown.join(', '));\n\n    this.expr = this.parse(terms[0]);\n    this.caps = options.caps;\n\n    if (this.caps.linear) {\n      delete this.caps.linear;\n      this.caps.duplicate = false;\n      this.caps.discard = false;\n      this.caps.normal = true;\n    }\n\n    if (this.caps.affine) {\n      delete this.caps.affine;\n      this.caps.normal = true;\n      this.caps.duplicate = false;\n    }\n  }\n\n  check (...expr) {\n    const start = this.expr.apply(...expr);\n    const r = start.run({ max: this.max });\n    const guess = r.expr.guess({ max: this.max });\n\n    const reason = [];\n    for (const cap in this.caps) {\n      if (guess[cap] !== this.caps[cap])\n        reason.push('expected property ' + cap + ' to be ' + this.caps[cap] + ', found ' + guess[cap]);\n    }\n\n    return {\n      pass:   !reason.length,\n      reason: reason ? reason.join('\\n') : null,\n      steps:  r.steps,\n      start,\n      found:  r.expr,\n      case:   this,\n      note:   this.note,\n      args:   expr,\n    };\n  }\n}\n\nfunction list2str (str) {\n  if (str === undefined)\n    return str;\n  return Array.isArray(str) ? str.join(' ') : '' + str;\n}\n\nmodule.exports = { Quest };\n", "const ski = require('./lib/parser');\nconst quest = require('./lib/quest');\n\nmodule.exports = { ...ski, ...quest };\nif (typeof window !== 'undefined') {\n  window.SKI = ski.SKI;\n  window.SKI.Quest = quest.Quest;\n}\n"],
  "mappings": "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",
  "names": ["require_util", "__commonJSMin", "exports", "module", "Tokenizer", "terms", "src", "a", "b", "str", "list", "last", "x", "tokRestrict", "restrict", "set", "spec", "out", "mode", "act", "sym", "skipDup", "arr", "map", "skip", "dup", "n", "count", "isSubset", "require_expr", "__commonJSMin", "exports", "module", "skipDup", "isSubset", "globalOptions", "Expr", "_Expr", "args", "App", "symbols", "out", "key", "_", "FreeVar", "terms", "opt", "pairs", "entry", "pair", "check", "canon", "term", "options", "max", "maxArgs", "preArgs", "steps", "maybeLambda", "next", "push", "nthvar", "expr", "naiveCanonize", "simplifyLambda", "final", "seq", "plug", "value", "other", "Alias", "expected", "comment", "poorMans", "first", "arg", "defaults", "nargs", "_App", "fun", "proxy", "list", "discard", "duplicate", "guess", "maybe", "reduced", "root", "space", "Named", "name", "freeId", "Native", "impl", "subst", "native", "egde", "step", "addNative", "Lambda", "_Lambda", "my", "tail", "known", "last", "local", "input", "head", "change", "fst", "snd", "mapsto", "Church", "_Church", "n", "p", "x", "y", "i", "z", "caps", "sym", "skip", "dup", "state", "maxWeight", "candidate", "require_parser", "__commonJSMin", "exports", "module", "Tokenizer", "restrict", "globalOptions", "Expr", "App", "FreeVar", "Lambda", "Native", "Alias", "Church", "native", "Empty", "args", "PartialLambda", "_PartialLambda", "term", "known", "tail", "combChars", "SKI", "_SKI", "options", "name", "impl", "note", "spec", "out", "prevShort", "nextShort", "source", "vars", "lines", "s", "jar", "expr", "item", "_", "save", "str", "opt", "tokens", "empty", "stack", "c", "x", "f", "names", "require_quest", "__commonJSMin", "exports", "module", "SKI", "Expr", "FreeVar", "Alias", "Lambda", "Quest", "options", "input", "vars", "cases", "allow", "numbers", "lambdas", "subst", "engine", "engineFull", "meta", "jar", "term", "expr", "list2str", "opt", "terms", "t", "PropertyCase", "ExprCase", "weight", "prepared", "i", "spec", "impl", "details", "c", "pass", "acc", "val", "steps", "e", "Case", "src", "outer", "inner", "start", "r1", "r2", "reason", "knownCaps", "unknown", "r", "guess", "cap", "str", "require_index", "__commonJSMin", "exports", "module", "ski", "quest"]
}
