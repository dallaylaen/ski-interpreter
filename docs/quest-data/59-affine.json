{
  "id": "ZBSnYgvf",
  "created_at": "2025-08-01T00:52:21",
  "name": "Affine logic",
  "intro": [
    "<p>Much like the linear logic, affine logic allows for a restricted subset of operations,",
    "namely, it can swap, discard, and compose terms, but not duplicate them.",
    "It is not therefore Turing complete, which may actually be beneficial in some applications.</p>"
  ],
  "content": [
    {
      "id": "Jv13RWtU",
      "created_at": "2025-08-01T00:52:21",
      "name": "Identity",
      "intro": [
        "<p>Unlike in linear logic, identity is not required to be present in the initial set. ",
        "This is because discarding is allowed and either <code>K x &lt;something&gt;</code> or",
        "some variant of <code>KI</code> can be built.</p>",
        "<p>Create identity from <code>B</code>, <code>K</code> and <code>T</code> combinators.",
        "<i>(<code>C</code> would've been too easy...)</i></p>"
      ],
      "env": ["T=CI"],
      "allow": "BK",
      "input": "phi",
      "cases": [
        [ "phi x", "x" ]
      ]
    },

    {
      "id": "BWom23jE",
      "created_at": "2025-08-01T00:52:21",
      "name": "To rule them all",
      "intro": [
        "<p>Create a monobasis for affine logic. ",
        "I made mine by taking <code>x&rarr;x</code>, attaching random affine combinators to the right, ",
        "plugging the resulting function into itself, and shaking it violently.</p>"
      ],
      "input": [
        {
          "name": "X",
          "allow": "I-I",
          "lambdas": true,
          "note": "Declare your own combinator <code>X</code>. It should not duplicate variables."
        },
        {
          "name": "b",
          "allow": "X",
          "note": "Derive <code>B</code> from <code>X</code>."
        },
        {
          "name": "k",
          "allow": "X",
          "note": "Derive <code>K</code> from <code>X</code>."
        },
        {
          "name": "t",
          "allow": "X",
          "note": "Derive <code>T</code> from <code>X</code>."
        }
      ],
      "cases": [
        [ {"caps": { "affine" : true}}, "X"],
        [ "b x y z", "x (y z)" ],
        [ "k x y", "x" ],
        [ "t x y", "y x" ]
      ]
    },
    {
      "id": "9AOyLk8v",
      "created_at": "2025-07-23T00:08:30",
      "name": "Triple trouble",
      "intro": [
        "<p>Think making <code>W</code> from <code>M</code> was hard?",
        "This time you are given <code>triple x = x x x</code> instead of <code>M</code>. Find <code>M</code>.</p>",
        "<p><i>(Can you also build <code>W</code>?)</i></p>",
        "<p>Of course you can't use any duplicating combinators except <code>triple</code>.</p>"
      ],
      "env": ["triple=WW"],
      "allow": "BCVIKT",
      "input": "phi",
      "cases": [
        [ "phi x", "x x" ]
      ]
    },
    {
      "id": "Ci0vMhSM",
      "created_at": "2025-08-22T01:14:01",
      "name": "Taming the infinity",
      "intro": [
        "<p>You are given a non-terminating fixed-point combinator, <code>Y</code>: ",
        "<code>Y f = f(Y f) = f(f(Y f)) = ...</code>.",
        "No other duplicating terms are allowed.</p>",
        "<p>Build <code>M x = x x</code>.</p>"
      ],
      "env": ["Y=WI(BWB(SI))"],
      "allow": "BCVIKT",
      "input": "phi",
      "cases": [
        [ "phi x", "x x" ]
      ]
    }
  ]
}
